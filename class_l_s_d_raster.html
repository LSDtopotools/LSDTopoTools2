<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LSDTopoTools2: LSDRaster Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LSDTopoTools2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_l_s_d_raster-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LSDRaster Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main analysis object to interface with other LSD objects.  
 <a href="class_l_s_d_raster.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_l_s_d_raster_8hpp_source.html">LSDRaster.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LSDRaster:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_l_s_d_raster.png" usemap="#LSDRaster_map" alt=""/>
  <map id="LSDRaster_map" name="LSDRaster_map">
<area href="class_l_s_d_catchment_model.html" title="This object is used to model the hydrology, sediment transport and evolution of individual basins..." alt="LSDCatchmentModel" shape="rect" coords="0,56,130,80"/>
<area href="class_l_s_d_raster_maker.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. " alt="LSDRasterMaker" shape="rect" coords="140,56,270,80"/>
<area href="class_l_s_d_raster_spectral.html" title="This object performs spectral analysis. " alt="LSDRasterSpectral" shape="rect" coords="280,56,410,80"/>
<area href="class_l_s_d_soil_hydro_raster.html" alt="LSDSoilHydroRaster" shape="rect" coords="420,56,550,80"/>
<area href="class_l_s_d_model_driver.html" title="This is a class to manage running LSDTopoTools. It parses a parameter file and then manages running o..." alt="LSDModelDriver" shape="rect" coords="0,112,130,136"/>
<area href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. " alt="LSDRasterModel" shape="rect" coords="280,112,410,136"/>
<area href="class_l_s_d_model_driver.html" title="This is a class to manage running LSDTopoTools. It parses a parameter file and then manages running o..." alt="LSDModelDriver" shape="rect" coords="280,168,410,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af845252cdd4bc8d2487386ba929f9bcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af845252cdd4bc8d2487386ba929f9bcc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#af845252cdd4bc8d2487386ba929f9bcc">LSDRaster</a> ()</td></tr>
<tr class="memdesc:af845252cdd4bc8d2487386ba929f9bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The create function. This is default and throws an error. <br/></td></tr>
<tr class="separator:af845252cdd4bc8d2487386ba929f9bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1cb2277ff6670a4452a60156bae824"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a0e1cb2277ff6670a4452a60156bae824">LSDRaster</a> (string filename, string extension)</td></tr>
<tr class="memdesc:a0e1cb2277ff6670a4452a60156bae824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> from a file. Uses a filename and file extension.  <a href="#a0e1cb2277ff6670a4452a60156bae824">More...</a><br/></td></tr>
<tr class="separator:a0e1cb2277ff6670a4452a60156bae824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed823ec252536362362c1eccd90be6b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aed823ec252536362362c1eccd90be6b2">LSDRaster</a> (int nrows, int ncols, float xmin, float ymin, float cellsize, float ndv, Array2D&lt; float &gt; data)</td></tr>
<tr class="memdesc:aed823ec252536362362c1eccd90be6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> from memory.  <a href="#aed823ec252536362362c1eccd90be6b2">More...</a><br/></td></tr>
<tr class="separator:aed823ec252536362362c1eccd90be6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bce22c0ea43adab9572e8f7ab0a94ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a0bce22c0ea43adab9572e8f7ab0a94ef">LSDRaster</a> (int nrows, int ncols, double xmin, double ymin, double cellsize, double ndv, Array2D&lt; double &gt; data)</td></tr>
<tr class="memdesc:a0bce22c0ea43adab9572e8f7ab0a94ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> from memory, with the elvation data stored as double precision floats.  <a href="#a0bce22c0ea43adab9572e8f7ab0a94ef">More...</a><br/></td></tr>
<tr class="separator:a0bce22c0ea43adab9572e8f7ab0a94ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33936fc57aac1a226186f7330abad2fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a33936fc57aac1a226186f7330abad2fa">LSDRaster</a> (int nrows, int ncols, float xmin, float ymin, float cellsize, float ndv, Array2D&lt; float &gt; data, map&lt; string, string &gt; temp_GRS)</td></tr>
<tr class="memdesc:a33936fc57aac1a226186f7330abad2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> from memory, includes georeferencing.  <a href="#a33936fc57aac1a226186f7330abad2fa">More...</a><br/></td></tr>
<tr class="separator:a33936fc57aac1a226186f7330abad2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e25cc15564f15dccb8b66b8d4bd7d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a08e25cc15564f15dccb8b66b8d4bd7d2">get_NRows</a> () const </td></tr>
<tr class="separator:a08e25cc15564f15dccb8b66b8d4bd7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ce4ec03dd1d0616a9577a338f69da8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac9ce4ec03dd1d0616a9577a338f69da8">get_NCols</a> () const </td></tr>
<tr class="separator:ac9ce4ec03dd1d0616a9577a338f69da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e759b3e01ea8860a4ccb63cb7c975b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a15e759b3e01ea8860a4ccb63cb7c975b">get_XMinimum</a> () const </td></tr>
<tr class="separator:a15e759b3e01ea8860a4ccb63cb7c975b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bcd4d45f9e84eaf037bd4d3e6e653d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac2bcd4d45f9e84eaf037bd4d3e6e653d">get_YMinimum</a> () const </td></tr>
<tr class="separator:ac2bcd4d45f9e84eaf037bd4d3e6e653d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468965d3781bd8ea55365eaf77fc9e3d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a468965d3781bd8ea55365eaf77fc9e3d">get_DataResolution</a> () const </td></tr>
<tr class="separator:a468965d3781bd8ea55365eaf77fc9e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7f3b7c0908779a7e1060dfe9f4cd4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a3c7f3b7c0908779a7e1060dfe9f4cd4c">get_NoDataValue</a> () const </td></tr>
<tr class="separator:a3c7f3b7c0908779a7e1060dfe9f4cd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd72008a20563ba21caf7c0d8ba41be2"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abd72008a20563ba21caf7c0d8ba41be2">get_RasterData</a> () const </td></tr>
<tr class="separator:abd72008a20563ba21caf7c0d8ba41be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01e17bc56551571e8c2f127e3718174"><td class="memItemLeft" align="right" valign="top">Array2D&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aa01e17bc56551571e8c2f127e3718174">get_RasterData_dbl</a> () const </td></tr>
<tr class="memdesc:aa01e17bc56551571e8c2f127e3718174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw raster data, double format.  <a href="#aa01e17bc56551571e8c2f127e3718174">More...</a><br/></td></tr>
<tr class="separator:aa01e17bc56551571e8c2f127e3718174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332a70547de45e7662eb27c0b6ef2f29"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a332a70547de45e7662eb27c0b6ef2f29">get_RasterData_int</a> () const </td></tr>
<tr class="memdesc:a332a70547de45e7662eb27c0b6ef2f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw raster data, integer format.  <a href="#a332a70547de45e7662eb27c0b6ef2f29">More...</a><br/></td></tr>
<tr class="separator:a332a70547de45e7662eb27c0b6ef2f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938ce9854d96267267f06694ef84de3b"><td class="memItemLeft" align="right" valign="top">map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a938ce9854d96267267f06694ef84de3b">get_GeoReferencingStrings</a> () const </td></tr>
<tr class="separator:a938ce9854d96267267f06694ef84de3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9f3397df5b3cf89ec8b4d31b4aa522"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a0e9f3397df5b3cf89ec8b4d31b4aa522">get_data_element</a> (int row, int column)</td></tr>
<tr class="memdesc:a0e9f3397df5b3cf89ec8b4d31b4aa522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raster data at a specified location.  <a href="#a0e9f3397df5b3cf89ec8b4d31b4aa522">More...</a><br/></td></tr>
<tr class="separator:a0e9f3397df5b3cf89ec8b4d31b4aa522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521142e6e1f812b104aa80e7be86af1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a521142e6e1f812b104aa80e7be86af1f">set_data_element</a> (int row, int column, float value)</td></tr>
<tr class="memdesc:a521142e6e1f812b104aa80e7be86af1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the raster data at a specified location.  <a href="#a521142e6e1f812b104aa80e7be86af1f">More...</a><br/></td></tr>
<tr class="separator:a521142e6e1f812b104aa80e7be86af1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf859d3f4272ce634028fe1686dcc3f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf859d3f4272ce634028fe1686dcc3f7"></a>
<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aaf859d3f4272ce634028fe1686dcc3f7">operator=</a> (const <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;LSDR)</td></tr>
<tr class="memdesc:aaf859d3f4272ce634028fe1686dcc3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr class="separator:aaf859d3f4272ce634028fe1686dcc3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95d817228d0efa166a601c406aa7862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac95d817228d0efa166a601c406aa7862">read_raster</a> (string filename, string extension)</td></tr>
<tr class="memdesc:ac95d817228d0efa166a601c406aa7862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a raster into memory from a file.  <a href="#ac95d817228d0efa166a601c406aa7862">More...</a><br/></td></tr>
<tr class="separator:ac95d817228d0efa166a601c406aa7862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa8d06ed84b1dab76bb414634699b07"><td class="memItemLeft" align="right" valign="top">TNT::Array2D&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aaaa8d06ed84b1dab76bb414634699b07">get_ascii_raster</a> (string FILENAME)</td></tr>
<tr class="memdesc:aaaa8d06ed84b1dab76bb414634699b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a raster from an ascii file for use in <a class="el" href="class_l_s_d_catchment_model.html" title="This object is used to model the hydrology, sediment transport and evolution of individual basins...">LSDCatchmentModel</a>.  <a href="#aaaa8d06ed84b1dab76bb414634699b07">More...</a><br/></td></tr>
<tr class="separator:aaaa8d06ed84b1dab76bb414634699b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e219b52a85ddce8659acb87248833de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e219b52a85ddce8659acb87248833de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>read_ascii_raster</b> (string FILENAME)</td></tr>
<tr class="separator:a1e219b52a85ddce8659acb87248833de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc85ecbaf0891c9f31ed6b886feb2860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abc85ecbaf0891c9f31ed6b886feb2860">read_ascii_raster_integers</a> (string FILENAME)</td></tr>
<tr class="memdesc:abc85ecbaf0891c9f31ed6b886feb2860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a raster of integers and populates <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> integer array member data.  <a href="#abc85ecbaf0891c9f31ed6b886feb2860">More...</a><br/></td></tr>
<tr class="separator:abc85ecbaf0891c9f31ed6b886feb2860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fce06a9e645907f3b44788dc9926f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#af8fce06a9e645907f3b44788dc9926f2">write_raster</a> (string filename, string extension)</td></tr>
<tr class="memdesc:af8fce06a9e645907f3b44788dc9926f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a raster from memory to a file.  <a href="#af8fce06a9e645907f3b44788dc9926f2">More...</a><br/></td></tr>
<tr class="separator:af8fce06a9e645907f3b44788dc9926f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dca7a4de099dc3b3defa5d1f8c5050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a72dca7a4de099dc3b3defa5d1f8c5050">write_double_raster</a> (string filename, string extension)</td></tr>
<tr class="memdesc:a72dca7a4de099dc3b3defa5d1f8c5050"><td class="mdescLeft">&#160;</td><td class="mdescRight">This calls raster write functions, writing from Arrays of type &lt;double&gt; to raster format.  <a href="#a72dca7a4de099dc3b3defa5d1f8c5050">More...</a><br/></td></tr>
<tr class="separator:a72dca7a4de099dc3b3defa5d1f8c5050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31f5d2372a9b7bc844994f74e401a7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae31f5d2372a9b7bc844994f74e401a7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae31f5d2372a9b7bc844994f74e401a7b">write_double_asc_raster</a> (string string_filename)</td></tr>
<tr class="memdesc:ae31f5d2372a9b7bc844994f74e401a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes out a double array to an ascii. <br/></td></tr>
<tr class="separator:ae31f5d2372a9b7bc844994f74e401a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027ffd3801bbd522b439c1d230029d1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a027ffd3801bbd522b439c1d230029d1a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a027ffd3801bbd522b439c1d230029d1a">write_double_flt_raster</a> (string filename, string string_filename)</td></tr>
<tr class="memdesc:a027ffd3801bbd522b439c1d230029d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes out a double array to a binary flt file. <br/></td></tr>
<tr class="separator:a027ffd3801bbd522b439c1d230029d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ed4d63b576662474713a7a6dd30fff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a04ed4d63b576662474713a7a6dd30fff">write_double_bil_raster</a> (string filename, string string_filename)</td></tr>
<tr class="memdesc:a04ed4d63b576662474713a7a6dd30fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes out a double array to a ENVI bil file (untested!)  <a href="#a04ed4d63b576662474713a7a6dd30fff">More...</a><br/></td></tr>
<tr class="separator:a04ed4d63b576662474713a7a6dd30fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00583bd08c65fa2f2b997b1ab7844c7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a00583bd08c65fa2f2b997b1ab7844c7c">does_raster_have_same_dimensions</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Compare_raster)</td></tr>
<tr class="memdesc:a00583bd08c65fa2f2b997b1ab7844c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if two rasters have the same dimensions  Does NOT check georeferencing.  <a href="#a00583bd08c65fa2f2b997b1ab7844c7c">More...</a><br/></td></tr>
<tr class="separator:a00583bd08c65fa2f2b997b1ab7844c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272891c6cf512ff95f489f06ef7cc042"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a272891c6cf512ff95f489f06ef7cc042">does_raster_have_same_dimensions</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Compare_raster)</td></tr>
<tr class="memdesc:a272891c6cf512ff95f489f06ef7cc042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if two rasters have the same dimensions  Does NOT check georeferencing.  <a href="#a272891c6cf512ff95f489f06ef7cc042">More...</a><br/></td></tr>
<tr class="separator:a272891c6cf512ff95f489f06ef7cc042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e5df5e08ad139f8b3abba7eae414b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a31e5df5e08ad139f8b3abba7eae414b1">does_raster_have_same_dimensions_and_georeferencing</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Compare_raster)</td></tr>
<tr class="memdesc:a31e5df5e08ad139f8b3abba7eae414b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if two rasters have the same georeferencing.  <a href="#a31e5df5e08ad139f8b3abba7eae414b1">More...</a><br/></td></tr>
<tr class="separator:a31e5df5e08ad139f8b3abba7eae414b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f34429a41eefb8397fb5a7257b7f737"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2f34429a41eefb8397fb5a7257b7f737">does_raster_have_same_dimensions_and_georeferencing</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Compare_raster)</td></tr>
<tr class="memdesc:a2f34429a41eefb8397fb5a7257b7f737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if two rasters have the same georeferencing.  <a href="#a2f34429a41eefb8397fb5a7257b7f737">More...</a><br/></td></tr>
<tr class="separator:a2f34429a41eefb8397fb5a7257b7f737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad561bc23880faa84f0bb8b1b04e365fc"><td class="memItemLeft" align="right" valign="top">map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad561bc23880faa84f0bb8b1b04e365fc">Update_GeoReferencingStrings</a> (float NewXmin, float NewYmax)</td></tr>
<tr class="memdesc:ad561bc23880faa84f0bb8b1b04e365fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method which takes a new xmin and ymax value and modifys the GeoReferencingStrings map_info line to contain these new values.  <a href="#ad561bc23880faa84f0bb8b1b04e365fc">More...</a><br/></td></tr>
<tr class="separator:ad561bc23880faa84f0bb8b1b04e365fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31031dfeb7aa365fa0219268f2c94ac9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a31031dfeb7aa365fa0219268f2c94ac9">Update_GeoReferencingStrings</a> ()</td></tr>
<tr class="memdesc:a31031dfeb7aa365fa0219268f2c94ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method which updates the map info element of the georeferencing strings based on information within the datamembers of the raster.  <a href="#a31031dfeb7aa365fa0219268f2c94ac9">More...</a><br/></td></tr>
<tr class="separator:a31031dfeb7aa365fa0219268f2c94ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea551343b827e83267b01eac832aafda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aea551343b827e83267b01eac832aafda">impose_georeferencing_UTM</a> (int zone, string NorS)</td></tr>
<tr class="memdesc:aea551343b827e83267b01eac832aafda"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method imposes georefereing strings assuming the coordinate system is UTM.  <a href="#aea551343b827e83267b01eac832aafda">More...</a><br/></td></tr>
<tr class="separator:aea551343b827e83267b01eac832aafda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fe2d220b79452468d401aacafdcf77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a89fe2d220b79452468d401aacafdcf77">Find_UTM_central_meridian</a> (int UTM_zone)</td></tr>
<tr class="memdesc:a89fe2d220b79452468d401aacafdcf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method looks up the central meridian given a UTM zone.  <a href="#a89fe2d220b79452468d401aacafdcf77">More...</a><br/></td></tr>
<tr class="separator:a89fe2d220b79452468d401aacafdcf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a888311e20677e866da63c9bc508d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac3a888311e20677e866da63c9bc508d9">get_UTM_information</a> (int &amp;UTM_zone, bool &amp;is_North)</td></tr>
<tr class="memdesc:ac3a888311e20677e866da63c9bc508d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function gets the UTM_zone and a boolean that is true if the map is in the northern hemisphere  <a href="#ac3a888311e20677e866da63c9bc508d9">More...</a><br/></td></tr>
<tr class="separator:ac3a888311e20677e866da63c9bc508d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ca0ab8a3c7fe16ef16b25a6bbc9805"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab9ca0ab8a3c7fe16ef16b25a6bbc9805">get_x_and_y_locations</a> (int row, int col, double &amp;x_loc, double &amp;y_loc)</td></tr>
<tr class="memdesc:ab9ca0ab8a3c7fe16ef16b25a6bbc9805"><td class="mdescLeft">&#160;</td><td class="mdescRight">this gets the x and y location of a node at row and column  <a href="#ab9ca0ab8a3c7fe16ef16b25a6bbc9805">More...</a><br/></td></tr>
<tr class="separator:ab9ca0ab8a3c7fe16ef16b25a6bbc9805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6d6796b91782832d3afab303effa9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abc6d6796b91782832d3afab303effa9e">get_x_and_y_locations</a> (int row, int col, float &amp;x_loc, float &amp;y_loc)</td></tr>
<tr class="memdesc:abc6d6796b91782832d3afab303effa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">this gets the x and y location of a node at row and column  <a href="#abc6d6796b91782832d3afab303effa9e">More...</a><br/></td></tr>
<tr class="separator:abc6d6796b91782832d3afab303effa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad904ac3a113434319b9eec0857479343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad904ac3a113434319b9eec0857479343">get_lat_and_long_locations</a> (int row, int col, double &amp;lat, double &amp;longitude, <a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a> Converter)</td></tr>
<tr class="memdesc:ad904ac3a113434319b9eec0857479343"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function to get the lat and long of a node in the raster  Assumes WGS84 ellipsiod  <a href="#ad904ac3a113434319b9eec0857479343">More...</a><br/></td></tr>
<tr class="separator:ad904ac3a113434319b9eec0857479343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6f687663706b020002604533a08379"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acc6f687663706b020002604533a08379">get_easting_and_northing_vectors</a> (vector&lt; float &gt; &amp;Eastings, vector&lt; float &gt; &amp;Northings)</td></tr>
<tr class="memdesc:acc6f687663706b020002604533a08379"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns vectors of all the easting and northing points in the raster Used for interpolations.  <a href="#acc6f687663706b020002604533a08379">More...</a><br/></td></tr>
<tr class="separator:acc6f687663706b020002604533a08379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c2b31fb34a041c4bf240650103f645"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a24c2b31fb34a041c4bf240650103f645">interpolate_points_bilinear</a> (vector&lt; float &gt; UTMEvec, vector&lt; float &gt; UTMNvec)</td></tr>
<tr class="memdesc:a24c2b31fb34a041c4bf240650103f645"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interpolates a vector of points onto the raster. Uses bilinear interpolation.  <a href="#a24c2b31fb34a041c4bf240650103f645">More...</a><br/></td></tr>
<tr class="separator:a24c2b31fb34a041c4bf240650103f645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad40fa659801ff5624d2d449c242fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abad40fa659801ff5624d2d449c242fdc">fill_with_interpolated_data</a> (vector&lt; int &gt; rows_of_nodes, vector&lt; int &gt; cols_of_nodes, vector&lt; float &gt; interpolated_data)</td></tr>
<tr class="memdesc:abad40fa659801ff5624d2d449c242fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fills a raster with precalculated interpolated data.  <a href="#abad40fa659801ff5624d2d449c242fdc">More...</a><br/></td></tr>
<tr class="separator:abad40fa659801ff5624d2d449c242fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f2a2a2545c77b481c04b8d7adffd44"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a91f2a2a2545c77b481c04b8d7adffd44">get_value_of_point</a> (float UTME, float UTMN)</td></tr>
<tr class="memdesc:a91f2a2a2545c77b481c04b8d7adffd44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the value at a point in UTM coordinates.  <a href="#a91f2a2a2545c77b481c04b8d7adffd44">More...</a><br/></td></tr>
<tr class="separator:a91f2a2a2545c77b481c04b8d7adffd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972d9ed0805f6a9fe83e313c32ad656a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a972d9ed0805f6a9fe83e313c32ad656a">check_if_point_is_in_raster</a> (float X_coordinate, float Y_coordinate)</td></tr>
<tr class="memdesc:a972d9ed0805f6a9fe83e313c32ad656a"><td class="mdescLeft">&#160;</td><td class="mdescRight">this check to see if a point is within the raster  <a href="#a972d9ed0805f6a9fe83e313c32ad656a">More...</a><br/></td></tr>
<tr class="separator:a972d9ed0805f6a9fe83e313c32ad656a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad690e009f9f019da688d553789f6ae8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad690e009f9f019da688d553789f6ae8f">get_row_and_col_of_a_point</a> (float X_coordinate, float Y_coordinate, int &amp;row, int &amp;col)</td></tr>
<tr class="memdesc:ad690e009f9f019da688d553789f6ae8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the row and column of a point in the raster.  <a href="#ad690e009f9f019da688d553789f6ae8f">More...</a><br/></td></tr>
<tr class="separator:ad690e009f9f019da688d553789f6ae8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67188d97c05315c98e4672081b5af33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac67188d97c05315c98e4672081b5af33"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_row_and_col_of_a_point</b> (double X_coordinate, double Y_coordinate, int &amp;row, int &amp;col)</td></tr>
<tr class="separator:ac67188d97c05315c98e4672081b5af33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace29fbf034c7af2dc70eb5c58db57bfb"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ace29fbf034c7af2dc70eb5c58db57bfb">get_XY_MinMax</a> ()</td></tr>
<tr class="memdesc:ace29fbf034c7af2dc70eb5c58db57bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a vector with the X adn Y minimum and max values.  <a href="#ace29fbf034c7af2dc70eb5c58db57bfb">More...</a><br/></td></tr>
<tr class="separator:ace29fbf034c7af2dc70eb5c58db57bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfb4efd91861f3977426004ccbe5443"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a4dfb4efd91861f3977426004ccbe5443">get_RasterData_vector</a> ()</td></tr>
<tr class="memdesc:a4dfb4efd91861f3977426004ccbe5443"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the raster data as a vector.  <a href="#a4dfb4efd91861f3977426004ccbe5443">More...</a><br/></td></tr>
<tr class="separator:a4dfb4efd91861f3977426004ccbe5443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f6f87c568b3b187861cba4822b027e"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a06f6f87c568b3b187861cba4822b027e">get_RasterData_vector_No_NDVs</a> ()</td></tr>
<tr class="memdesc:a06f6f87c568b3b187861cba4822b027e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the raster data as a vector, ignoring NDVs.  <a href="#a06f6f87c568b3b187861cba4822b027e">More...</a><br/></td></tr>
<tr class="separator:a06f6f87c568b3b187861cba4822b027e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bc58532a0ed8acccea68da9a787760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a97bc58532a0ed8acccea68da9a787760">write_RasterData_to_text_file</a> (string filename)</td></tr>
<tr class="memdesc:a97bc58532a0ed8acccea68da9a787760"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the raster data as text file.  <a href="#a97bc58532a0ed8acccea68da9a787760">More...</a><br/></td></tr>
<tr class="separator:a97bc58532a0ed8acccea68da9a787760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00b501f9761192ca7a5f4f417bdecfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae00b501f9761192ca7a5f4f417bdecfa">rewrite_with_random_values</a> (float range)</td></tr>
<tr class="memdesc:ae00b501f9761192ca7a5f4f417bdecfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">rewrite all the data array values with random numbers (with a uniform distribution).  <a href="#ae00b501f9761192ca7a5f4f417bdecfa">More...</a><br/></td></tr>
<tr class="separator:ae00b501f9761192ca7a5f4f417bdecfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2063e4b0055740837635911886f27e62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2063e4b0055740837635911886f27e62">create_raster_nodata</a> ()</td></tr>
<tr class="memdesc:a2063e4b0055740837635911886f27e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a raster in of the same number of rows and cols with nodata.  <a href="#a2063e4b0055740837635911886f27e62">More...</a><br/></td></tr>
<tr class="separator:a2063e4b0055740837635911886f27e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c74ca7454b451b85a680eb581fbf7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a00c74ca7454b451b85a680eb581fbf7c">RasterTrimmer</a> ()</td></tr>
<tr class="memdesc:a00c74ca7454b451b85a680eb581fbf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the minimum bounding rectangle for an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> Object and crop out all the surrounding NoDataValues to reduce the size and load times of output rasters.  <a href="#a00c74ca7454b451b85a680eb581fbf7c">More...</a><br/></td></tr>
<tr class="separator:a00c74ca7454b451b85a680eb581fbf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33720ffe99abb3ed10264c679b9a608c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a33720ffe99abb3ed10264c679b9a608c">RasterTrimmerPadded</a> (int padded_pixels)</td></tr>
<tr class="memdesc:a33720ffe99abb3ed10264c679b9a608c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the minimum bounding rectangle for an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> Object and crop out all the surrounding NoDataValues to reduce the size and load times of output rasters. Similar to RasterTrimmer but has a pixel buffer. Useful for CRN data since sometimes the channel in the DEM does not correspond exactly with the data point.  <a href="#a33720ffe99abb3ed10264c679b9a608c">More...</a><br/></td></tr>
<tr class="separator:a33720ffe99abb3ed10264c679b9a608c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b61cc0f912f93dc6e5483ce03ef468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a47b61cc0f912f93dc6e5483ce03ef468">RasterTrimmerSpiral</a> ()</td></tr>
<tr class="memdesc:a47b61cc0f912f93dc6e5483ce03ef468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a raster and trims nodata from around the edges to result in a rectangular <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>.  <a href="#a47b61cc0f912f93dc6e5483ce03ef468">More...</a><br/></td></tr>
<tr class="separator:a47b61cc0f912f93dc6e5483ce03ef468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cb08ebbbaf25149d14552164671ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a41cb08ebbbaf25149d14552164671ce4">clip_to_smaller_raster</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;smaller_raster)</td></tr>
<tr class="memdesc:a41cb08ebbbaf25149d14552164671ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a clipped raster that has the same dimensions as the smaller raster.  <a href="#a41cb08ebbbaf25149d14552164671ce4">More...</a><br/></td></tr>
<tr class="separator:a41cb08ebbbaf25149d14552164671ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ed4e5c0efe368c2a3c9708a71fd6f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a84ed4e5c0efe368c2a3c9708a71fd6f2">clip_to_smaller_raster</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;smaller_raster)</td></tr>
<tr class="memdesc:a84ed4e5c0efe368c2a3c9708a71fd6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a clipped raster that has the same dimensions as the smaller raster.  <a href="#a84ed4e5c0efe368c2a3c9708a71fd6f2">More...</a><br/></td></tr>
<tr class="separator:a84ed4e5c0efe368c2a3c9708a71fd6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a22acd87d2a12a9fef0ced5c34cc8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae5a22acd87d2a12a9fef0ced5c34cc8d">LSDRasterTemplate</a> (Array2D&lt; float &gt; InputData)</td></tr>
<tr class="memdesc:ae5a22acd87d2a12a9fef0ced5c34cc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object using a 'template' raster and an Array2D of data.  <a href="#ae5a22acd87d2a12a9fef0ced5c34cc8d">More...</a><br/></td></tr>
<tr class="separator:ae5a22acd87d2a12a9fef0ced5c34cc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb2a79bbdc11675ebb1c93c705bf01a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a6cb2a79bbdc11675ebb1c93c705bf01a">strip_raster_padding</a> ()</td></tr>
<tr class="memdesc:a6cb2a79bbdc11675ebb1c93c705bf01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the edge rows/columns of a <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> on each side of the array.  <a href="#a6cb2a79bbdc11675ebb1c93c705bf01a">More...</a><br/></td></tr>
<tr class="separator:a6cb2a79bbdc11675ebb1c93c705bf01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7071ad2969e75a43477e90fe50e9e544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a7071ad2969e75a43477e90fe50e9e544">BufferRasterData</a> (float window_radius)</td></tr>
<tr class="memdesc:a7071ad2969e75a43477e90fe50e9e544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffers a raster using a circular kernel of a user-defined radius (m)  <a href="#a7071ad2969e75a43477e90fe50e9e544">More...</a><br/></td></tr>
<tr class="separator:a7071ad2969e75a43477e90fe50e9e544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe374373ec34318878a49acde9a7e59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebe374373ec34318878a49acde9a7e59"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aebe374373ec34318878a49acde9a7e59">PadSmallerRaster</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;smaller_raster)</td></tr>
<tr class="memdesc:aebe374373ec34318878a49acde9a7e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad one smaller raster to the same extent as a bigger raster by adding no data around the edges. <br/></td></tr>
<tr class="separator:aebe374373ec34318878a49acde9a7e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10deff45b25c7dfb065df33d057be3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae10deff45b25c7dfb065df33d057be3d">calculate_relief</a> (float kernelWidth, int kernelType)</td></tr>
<tr class="memdesc:ae10deff45b25c7dfb065df33d057be3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a relief raster.  <a href="#ae10deff45b25c7dfb065df33d057be3d">More...</a><br/></td></tr>
<tr class="separator:ae10deff45b25c7dfb065df33d057be3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d1dd8fb4dbecd7aa84641c06effe7d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a94d1dd8fb4dbecd7aa84641c06effe7d">mean_elevation</a> (void)</td></tr>
<tr class="memdesc:a94d1dd8fb4dbecd7aa84641c06effe7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates mean elevation of a raster.  <a href="#a94d1dd8fb4dbecd7aa84641c06effe7d">More...</a><br/></td></tr>
<tr class="separator:a94d1dd8fb4dbecd7aa84641c06effe7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc84f4343f835502a05bf1933fa8a368"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acc84f4343f835502a05bf1933fa8a368">max_elevation</a> (void)</td></tr>
<tr class="memdesc:acc84f4343f835502a05bf1933fa8a368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates max elevation of a raster.  <a href="#acc84f4343f835502a05bf1933fa8a368">More...</a><br/></td></tr>
<tr class="separator:acc84f4343f835502a05bf1933fa8a368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa43db51b8b8f11f36a16e43d8228b9f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aaa43db51b8b8f11f36a16e43d8228b9f">mean_relief</a> (float kernelsize)</td></tr>
<tr class="memdesc:aaa43db51b8b8f11f36a16e43d8228b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates mean relief of a raster, it defaults to a circular kernal.  <a href="#aaa43db51b8b8f11f36a16e43d8228b9f">More...</a><br/></td></tr>
<tr class="separator:aaa43db51b8b8f11f36a16e43d8228b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf499bc742ba424266af5e0917440cb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a3cf499bc742ba424266af5e0917440cb">difference_rasters</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;compare_raster)</td></tr>
<tr class="memdesc:a3cf499bc742ba424266af5e0917440cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mean difference between two rasters.  <a href="#a3cf499bc742ba424266af5e0917440cb">More...</a><br/></td></tr>
<tr class="separator:a3cf499bc742ba424266af5e0917440cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d568d1e13391c0296652f1ab217b5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a33d568d1e13391c0296652f1ab217b5f">raster_multiplier</a> (float multiplier)</td></tr>
<tr class="memdesc:a33d568d1e13391c0296652f1ab217b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This multiplies the raster data by a multiplier  Note that values are replaced.  <a href="#a33d568d1e13391c0296652f1ab217b5f">More...</a><br/></td></tr>
<tr class="separator:a33d568d1e13391c0296652f1ab217b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cac2e67a21fbcc84ff76e617d516a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a13cac2e67a21fbcc84ff76e617d516a9">MapAlgebra_multiply</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;M_raster)</td></tr>
<tr class="memdesc:a13cac2e67a21fbcc84ff76e617d516a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This multiplies two rasters, elementwise  Simple elementwise multiplictation.  <a href="#a13cac2e67a21fbcc84ff76e617d516a9">More...</a><br/></td></tr>
<tr class="separator:a13cac2e67a21fbcc84ff76e617d516a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040d9da2e9fadc56445df513aab735ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a040d9da2e9fadc56445df513aab735ba">MapAlgebra_divide</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;M_raster)</td></tr>
<tr class="memdesc:a040d9da2e9fadc56445df513aab735ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This divides two rasters, elementwise  Simple elementwise division.  <a href="#a040d9da2e9fadc56445df513aab735ba">More...</a><br/></td></tr>
<tr class="separator:a040d9da2e9fadc56445df513aab735ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929bdcffb9dc23cf174724bf4b57a2e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a929bdcffb9dc23cf174724bf4b57a2e3">MapAlgebra_add</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;M_raster)</td></tr>
<tr class="memdesc:a929bdcffb9dc23cf174724bf4b57a2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This add two rasters, elementwise  Simple elementwise addition.  <a href="#a929bdcffb9dc23cf174724bf4b57a2e3">More...</a><br/></td></tr>
<tr class="separator:a929bdcffb9dc23cf174724bf4b57a2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa5745b2cf30b3183076aab49bf7016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2aa5745b2cf30b3183076aab49bf7016">MapAlgebra_subtract</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;M_raster)</td></tr>
<tr class="memdesc:a2aa5745b2cf30b3183076aab49bf7016"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subtracts two rasters, elementwise  Simple elementwise subtraction.  <a href="#a2aa5745b2cf30b3183076aab49bf7016">More...</a><br/></td></tr>
<tr class="separator:a2aa5745b2cf30b3183076aab49bf7016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd69705ea2bdb06af1703a111d8da599"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abd69705ea2bdb06af1703a111d8da599">WrapSample</a> (int row, int col)</td></tr>
<tr class="memdesc:abd69705ea2bdb06af1703a111d8da599"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a value from the array data element but wraps around the array dimensions so that row &gt; NRows (for example) returns a value.  <a href="#abd69705ea2bdb06af1703a111d8da599">More...</a><br/></td></tr>
<tr class="separator:abd69705ea2bdb06af1703a111d8da599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258644dc36c4ed6e04011ff2419074a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a258644dc36c4ed6e04011ff2419074a8">SetWrapSample</a> (int row, int col, float value)</td></tr>
<tr class="memdesc:a258644dc36c4ed6e04011ff2419074a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets a value in the data array withthe added feature that it wraps beyond NRows and NCols.  <a href="#a258644dc36c4ed6e04011ff2419074a8">More...</a><br/></td></tr>
<tr class="separator:a258644dc36c4ed6e04011ff2419074a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8665f8057d8050cb61ccc1404c6f80c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a8665f8057d8050cb61ccc1404c6f80c5">DSSetFeatureCorners</a> (int featuresize, float scale)</td></tr>
<tr class="memdesc:a8665f8057d8050cb61ccc1404c6f80c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets the corners of features as the first step in the diamond square algorithm.  <a href="#a8665f8057d8050cb61ccc1404c6f80c5">More...</a><br/></td></tr>
<tr class="separator:a8665f8057d8050cb61ccc1404c6f80c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0aff5f6e1cdb4a1801419e5e63e9d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2e0aff5f6e1cdb4a1801419e5e63e9d5">DSSampleSquare</a> (int row, int col, int size, float value)</td></tr>
<tr class="memdesc:a2e0aff5f6e1cdb4a1801419e5e63e9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the square sampling step of the diamond square algorithm: it takes the average of the four corners and adds a random number to set the centrepoint of a square.  <a href="#a2e0aff5f6e1cdb4a1801419e5e63e9d5">More...</a><br/></td></tr>
<tr class="separator:a2e0aff5f6e1cdb4a1801419e5e63e9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e384d147a6a22b929020f97b0f16f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac5e384d147a6a22b929020f97b0f16f0">DSSampleDiamond</a> (int row, int col, int size, float value)</td></tr>
<tr class="memdesc:ac5e384d147a6a22b929020f97b0f16f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the diamond sampling step of the diamond square algorithm: it takes the average of the four corners and adds a random number to set the centrepoint of a diamond.  <a href="#ac5e384d147a6a22b929020f97b0f16f0">More...</a><br/></td></tr>
<tr class="separator:ac5e384d147a6a22b929020f97b0f16f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dca3c985ce96fa98df6b1f5e325f3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a86dca3c985ce96fa98df6b1f5e325f3f">DiamondSquare_SampleStep</a> (int stepsize, float scale)</td></tr>
<tr class="memdesc:a86dca3c985ce96fa98df6b1f5e325f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the sampling function for the diamond square algorithm: it runs both a diamond and a square sampling for each step.  <a href="#a86dca3c985ce96fa98df6b1f5e325f3f">More...</a><br/></td></tr>
<tr class="separator:a86dca3c985ce96fa98df6b1f5e325f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49cd0617a2eaccc60e03cededbd79ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac49cd0617a2eaccc60e03cededbd79ba">DiamondSquare</a> (int feature_order, float scale)</td></tr>
<tr class="memdesc:ac49cd0617a2eaccc60e03cededbd79ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the driving function for the diamond square algorithm.  <a href="#ac49cd0617a2eaccc60e03cededbd79ba">More...</a><br/></td></tr>
<tr class="separator:ac49cd0617a2eaccc60e03cededbd79ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b1fd5b037bac76a4f26c821f1d854e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a69b1fd5b037bac76a4f26c821f1d854e">hillshade</a> ()</td></tr>
<tr class="memdesc:a69b1fd5b037bac76a4f26c821f1d854e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a hillshade raster.  <a href="#a69b1fd5b037bac76a4f26c821f1d854e">More...</a><br/></td></tr>
<tr class="separator:a69b1fd5b037bac76a4f26c821f1d854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73eb390174187d2aa8ee2f57debdf8c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73eb390174187d2aa8ee2f57debdf8c8"></a>
<a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hillshade</b> (float altitude, float azimuth, float z_factor)</td></tr>
<tr class="separator:a73eb390174187d2aa8ee2f57debdf8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc990b240756b3683628d0881f28bbb"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#adbc990b240756b3683628d0881f28bbb">Shadow</a> (int theta, int phi)</td></tr>
<tr class="memdesc:adbc990b240756b3683628d0881f28bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a hillshade derivative raster using the algorithm outlined in Codilean (2006).  <a href="#adbc990b240756b3683628d0881f28bbb">More...</a><br/></td></tr>
<tr class="separator:adbc990b240756b3683628d0881f28bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbcd3609a0d99e74900435020af4d88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2bbcd3609a0d99e74900435020af4d88">CastShadows</a> (int Azimuth, int ZenithAngle)</td></tr>
<tr class="memdesc:a2bbcd3609a0d99e74900435020af4d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine areas of a DEM that are in shadow from a given radiation source defined by an Azimuth and Zenith following Codilean (2006).  <a href="#a2bbcd3609a0d99e74900435020af4d88">More...</a><br/></td></tr>
<tr class="separator:a2bbcd3609a0d99e74900435020af4d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef61f081a68a6677698daa2bd55033d"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aaef61f081a68a6677698daa2bd55033d">Shadows</a> (int Azimuth, int ZenithAngle)</td></tr>
<tr class="memdesc:aaef61f081a68a6677698daa2bd55033d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine areas of a DEM that are in shadow from a given radiation source defined by an Azimuth and Zenith following Codilean (2006).  <a href="#aaef61f081a68a6677698daa2bd55033d">More...</a><br/></td></tr>
<tr class="separator:aaef61f081a68a6677698daa2bd55033d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa2dc8f6e3e1c62e9e3fb74225c8aa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a1fa2dc8f6e3e1c62e9e3fb74225c8aa7">TopographicShielding</a> (int theta_step, int phi_step)</td></tr>
<tr class="memdesc:a1fa2dc8f6e3e1c62e9e3fb74225c8aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a topographic shielding raster using the algorithm outlined in Codilean (2006).  <a href="#a1fa2dc8f6e3e1c62e9e3fb74225c8aa7">More...</a><br/></td></tr>
<tr class="separator:a1fa2dc8f6e3e1c62e9e3fb74225c8aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4349f4cf7d4d587c05d5eddce3a8a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef4349f4cf7d4d587c05d5eddce3a8a9"></a>
<a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TopographicShielding</b> ()</td></tr>
<tr class="separator:aef4349f4cf7d4d587c05d5eddce3a8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb6f3aa7b196ade7283dc77ae52640a"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aefb6f3aa7b196ade7283dc77ae52640a">calculate_polyfit_surface_metrics</a> (float window_radius, vector&lt; int &gt; raster_selection)</td></tr>
<tr class="memdesc:aefb6f3aa7b196ade7283dc77ae52640a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface polynomial fitting and extraction of topographic metrics.  <a href="#aefb6f3aa7b196ade7283dc77ae52640a">More...</a><br/></td></tr>
<tr class="separator:aefb6f3aa7b196ade7283dc77ae52640a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277eed7fed092e06fc22d05bebb24aaf"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a277eed7fed092e06fc22d05bebb24aaf">calculate_polyfit_surface_metrics_directional_gradients</a> (float window_radius, vector&lt; int &gt; raster_selection)</td></tr>
<tr class="memdesc:a277eed7fed092e06fc22d05bebb24aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface polynomial fitting and extraction of topographic metrics. Same as above function but in this case one can opt for directional gradients. Added as another function to ensure legacy code is not broken.  A six term polynomial surface is fitted to all the points that lie within circular neighbourhood that is defined by the designated window radius. The user also inputs a binary raster, which tells the program which rasters it wants to create (label as "1" to produce them, "0" to ignore them. This has 8 elements, as listed below: 0 -&gt; Elevation (smoothed by surface fitting) 1 -&gt; Slope 2 -&gt; Aspect 3 -&gt; Curvature 4 -&gt; Planform Curvature 5 -&gt; Profile Curvature 6 -&gt; Tangential Curvature 7 -&gt; Stationary point classification (1=peak, 2=depression, 3=saddle) 8 -&gt; Directional gradients (dz/dx and dz,dy) The program returns a vector of LSDRasters. For options marked "false" in boolean input raster, the returned <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> houses a blank raster, as this metric has not been calculated. The desired <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> can be retrieved from the output vector by using the cell reference shown in the list above i.e. it is the same as the reference in the input boolean vector.  <a href="#a277eed7fed092e06fc22d05bebb24aaf">More...</a><br/></td></tr>
<tr class="separator:a277eed7fed092e06fc22d05bebb24aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb085209c3dc12eb6b59ed0dc58e4ba3"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aeb085209c3dc12eb6b59ed0dc58e4ba3">calculate_polyfit_roughness_metrics</a> (float window_radius1, float window_radius2, vector&lt; int &gt; raster_selection)</td></tr>
<tr class="memdesc:aeb085209c3dc12eb6b59ed0dc58e4ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface polynomial fitting and extraction of roughness metrics.  <a href="#aeb085209c3dc12eb6b59ed0dc58e4ba3">More...</a><br/></td></tr>
<tr class="separator:aeb085209c3dc12eb6b59ed0dc58e4ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fe83faa31eabe0ef3b5e5ca8333254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a04fe83faa31eabe0ef3b5e5ca8333254">calculate_polyfit_coefficient_matrices</a> (float window_radius, Array2D&lt; float &gt; &amp;a, Array2D&lt; float &gt; &amp;b, Array2D&lt; float &gt; &amp;c, Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e, Array2D&lt; float &gt; &amp;f)</td></tr>
<tr class="memdesc:a04fe83faa31eabe0ef3b5e5ca8333254"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates 6 coefficient matrices that allow the user to then calcualte slope, curvature, aspect, a classification for finding saddles and peaks and other metrics.  <a href="#a04fe83faa31eabe0ef3b5e5ca8333254">More...</a><br/></td></tr>
<tr class="separator:a04fe83faa31eabe0ef3b5e5ca8333254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6aa4aee4586df345a2cfcfe2adf6f9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad6aa4aee4586df345a2cfcfe2adf6f9a">calculate_polyfit_elevation</a> (Array2D&lt; float &gt; &amp;f)</td></tr>
<tr class="memdesc:ad6aa4aee4586df345a2cfcfe2adf6f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the elevation based on a polynomial fit.  <a href="#ad6aa4aee4586df345a2cfcfe2adf6f9a">More...</a><br/></td></tr>
<tr class="separator:ad6aa4aee4586df345a2cfcfe2adf6f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae2eadcadcd924ebb7e4e4eeac3cd7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a9ae2eadcadcd924ebb7e4e4eeac3cd7a">calculate_polyfit_slope</a> (Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e)</td></tr>
<tr class="memdesc:a9ae2eadcadcd924ebb7e4e4eeac3cd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the slope based on a polynomial fit.  <a href="#a9ae2eadcadcd924ebb7e4e4eeac3cd7a">More...</a><br/></td></tr>
<tr class="separator:a9ae2eadcadcd924ebb7e4e4eeac3cd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7b1dfb873b632a49c8aa755eb399db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a9c7b1dfb873b632a49c8aa755eb399db">calculate_polyfit_aspect</a> (Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e)</td></tr>
<tr class="memdesc:a9c7b1dfb873b632a49c8aa755eb399db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the aspect based on a polynomial fit.  <a href="#a9c7b1dfb873b632a49c8aa755eb399db">More...</a><br/></td></tr>
<tr class="separator:a9c7b1dfb873b632a49c8aa755eb399db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b313feafa3a2e9ab790389976f522ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a7b313feafa3a2e9ab790389976f522ce">calculate_polyfit_curvature</a> (Array2D&lt; float &gt; &amp;a, Array2D&lt; float &gt; &amp;b)</td></tr>
<tr class="memdesc:a7b313feafa3a2e9ab790389976f522ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the curvature based on a polynomial fit.  <a href="#a7b313feafa3a2e9ab790389976f522ce">More...</a><br/></td></tr>
<tr class="separator:a7b313feafa3a2e9ab790389976f522ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf3bb49b83db88798647b8ceee85c94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aeaf3bb49b83db88798647b8ceee85c94">calculate_polyfit_planform_curvature</a> (Array2D&lt; float &gt; &amp;a, Array2D&lt; float &gt; &amp;b, Array2D&lt; float &gt; &amp;c, Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e)</td></tr>
<tr class="memdesc:aeaf3bb49b83db88798647b8ceee85c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the planform curvature based on a polynomial fit.  <a href="#aeaf3bb49b83db88798647b8ceee85c94">More...</a><br/></td></tr>
<tr class="separator:aeaf3bb49b83db88798647b8ceee85c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4da58e27375a3609942872e1dd45341"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aa4da58e27375a3609942872e1dd45341">calculate_polyfit_profile_curvature</a> (Array2D&lt; float &gt; &amp;a, Array2D&lt; float &gt; &amp;b, Array2D&lt; float &gt; &amp;c, Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e)</td></tr>
<tr class="memdesc:aa4da58e27375a3609942872e1dd45341"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the profile curvature based on a polynomial fit.  <a href="#aa4da58e27375a3609942872e1dd45341">More...</a><br/></td></tr>
<tr class="separator:aa4da58e27375a3609942872e1dd45341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5b09464e02fac88cf06563b4c16eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aea5b09464e02fac88cf06563b4c16eb6">calculate_polyfit_tangential_curvature</a> (Array2D&lt; float &gt; &amp;a, Array2D&lt; float &gt; &amp;b, Array2D&lt; float &gt; &amp;c, Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e)</td></tr>
<tr class="memdesc:aea5b09464e02fac88cf06563b4c16eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the tangential curvature based on a polynomial fit.  <a href="#aea5b09464e02fac88cf06563b4c16eb6">More...</a><br/></td></tr>
<tr class="separator:aea5b09464e02fac88cf06563b4c16eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50913916b5a16f90470d5bf7b14741b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a50913916b5a16f90470d5bf7b14741b7">calculate_polyfit_classification</a> (Array2D&lt; float &gt; &amp;a, Array2D&lt; float &gt; &amp;b, Array2D&lt; float &gt; &amp;c, Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e)</td></tr>
<tr class="memdesc:a50913916b5a16f90470d5bf7b14741b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function identifies approximate position of stationary points within discrete surface using a threshold slope.  <a href="#a50913916b5a16f90470d5bf7b14741b7">More...</a><br/></td></tr>
<tr class="separator:a50913916b5a16f90470d5bf7b14741b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17fbce489da7ed4f49cab22f993cb0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad17fbce489da7ed4f49cab22f993cb0a">get_hilltop_curvature</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;curvature, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Hilltops)</td></tr>
<tr class="memdesc:ad17fbce489da7ed4f49cab22f993cb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the hilltop curvature raster.  <a href="#ad17fbce489da7ed4f49cab22f993cb0a">More...</a><br/></td></tr>
<tr class="separator:ad17fbce489da7ed4f49cab22f993cb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccac8e8ee1daaf3a6751e67b4874319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a7ccac8e8ee1daaf3a6751e67b4874319">remove_positive_hilltop_curvature</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;hilltop_curvature)</td></tr>
<tr class="memdesc:a7ccac8e8ee1daaf3a6751e67b4874319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes positive hilltop curvature values.  <a href="#a7ccac8e8ee1daaf3a6751e67b4874319">More...</a><br/></td></tr>
<tr class="separator:a7ccac8e8ee1daaf3a6751e67b4874319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b5fecd2a59a3fedf8019f78d8adede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae5b5fecd2a59a3fedf8019f78d8adede">remove_positive_values</a> ()</td></tr>
<tr class="memdesc:ae5b5fecd2a59a3fedf8019f78d8adede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes positive values from a raster.  <a href="#ae5b5fecd2a59a3fedf8019f78d8adede">More...</a><br/></td></tr>
<tr class="separator:ae5b5fecd2a59a3fedf8019f78d8adede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7b0e0fc28fae36bbfb37ad8efcb2ee"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2c7b0e0fc28fae36bbfb37ad8efcb2ee">get_percentage_bedrock_ridgetops</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;roughness, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;hilltop_curvature, float threshold)</td></tr>
<tr class="memdesc:a2c7b0e0fc28fae36bbfb37ad8efcb2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the percentage of bedrock ridges.  <a href="#a2c7b0e0fc28fae36bbfb37ad8efcb2ee">More...</a><br/></td></tr>
<tr class="separator:a2c7b0e0fc28fae36bbfb37ad8efcb2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398ed8c6898a690f851f49bef41e18f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a398ed8c6898a690f851f49bef41e18f2">calculate_slope_angles</a> ()</td></tr>
<tr class="memdesc:a398ed8c6898a690f851f49bef41e18f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates slope angle in radians. Needs the slope raster.  <a href="#a398ed8c6898a690f851f49bef41e18f2">More...</a><br/></td></tr>
<tr class="separator:a398ed8c6898a690f851f49bef41e18f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129887343a9122cb5b3fd65a3854e850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a129887343a9122cb5b3fd65a3854e850">calculate_water_supply_rate_for_saturation</a> (float soil_thick, float K, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ContributingArea, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;SlopeAngle)</td></tr>
<tr class="memdesc:a129887343a9122cb5b3fd65a3854e850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the water supply rate required for saturation of the hillslope soil.  <a href="#a129887343a9122cb5b3fd65a3854e850">More...</a><br/></td></tr>
<tr class="separator:a129887343a9122cb5b3fd65a3854e850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5caf033ba21aeec45e774595292be2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad5caf033ba21aeec45e774595292be2c">calculate_factor_of_safety_at_saturation</a> (float C_r, float rho_s, float soil_thick, float tan_phi, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;SlopeAngle)</td></tr>
<tr class="memdesc:ad5caf033ba21aeec45e774595292be2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This calculates the factor of safety if the soil is completely saturated.  <a href="#ad5caf033ba21aeec45e774595292be2c">More...</a><br/></td></tr>
<tr class="separator:ad5caf033ba21aeec45e774595292be2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0beaa7242443b3421ae97d5402752454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a0beaa7242443b3421ae97d5402752454">calculate_polyfit_directional_cosines</a> (Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e, Array2D&lt; float &gt; &amp;l, Array2D&lt; float &gt; &amp;m, Array2D&lt; float &gt; &amp;n)</td></tr>
<tr class="memdesc:a0beaa7242443b3421ae97d5402752454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithm that assesses surface roughness based on a polynomial fit.  <a href="#a0beaa7242443b3421ae97d5402752454">More...</a><br/></td></tr>
<tr class="separator:a0beaa7242443b3421ae97d5402752454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae417692b85ad0880acdf60af4e61ea22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae417692b85ad0880acdf60af4e61ea22">calculate_orientation_matrix_eigenvalues</a> (float window_radius, Array2D&lt; float &gt; &amp;l, Array2D&lt; float &gt; &amp;m, Array2D&lt; float &gt; &amp;n, Array2D&lt; float &gt; &amp;s1, Array2D&lt; float &gt; &amp;s2, Array2D&lt; float &gt; &amp;s3)</td></tr>
<tr class="memdesc:ae417692b85ad0880acdf60af4e61ea22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find eigenvalues for orientation matrix.  <a href="#ae417692b85ad0880acdf60af4e61ea22">More...</a><br/></td></tr>
<tr class="separator:ae417692b85ad0880acdf60af4e61ea22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfa6f1e75d776f505d3067816876f06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aadfa6f1e75d776f505d3067816876f06">calculate_plane_coefficient_matrices</a> (float window_radius, Array2D&lt; float &gt; &amp;a_plane, Array2D&lt; float &gt; &amp;b_plane, Array2D&lt; float &gt; &amp;c_plane)</td></tr>
<tr class="memdesc:aadfa6f1e75d776f505d3067816876f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a wrapper to get the three roughness eigenvalues s1, s2 and s3.  <a href="#aadfa6f1e75d776f505d3067816876f06">More...</a><br/></td></tr>
<tr class="separator:aadfa6f1e75d776f505d3067816876f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a6dd434f0c62f00f0657cf79c7a4ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a17a6dd434f0c62f00f0657cf79c7a4ea">calculate_REI</a> (Array2D&lt; float &gt; &amp;a_plane, Array2D&lt; float &gt; &amp;b_plane, float CriticalSlope)</td></tr>
<tr class="memdesc:a17a6dd434f0c62f00f0657cf79c7a4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the REI raster.  <a href="#a17a6dd434f0c62f00f0657cf79c7a4ea">More...</a><br/></td></tr>
<tr class="separator:a17a6dd434f0c62f00f0657cf79c7a4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf94a0a1d208e3916b6c9fbd90c8c2fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abf94a0a1d208e3916b6c9fbd90c8c2fe">calculate_REI</a> (float window_radius, float CriticalSlope)</td></tr>
<tr class="memdesc:abf94a0a1d208e3916b6c9fbd90c8c2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the REI raster (imporoved wrapper) Rock exposure index defined as areas with local slope exceeding some critical slope as defined by DiBiase et al. (2012)  <a href="#abf94a0a1d208e3916b6c9fbd90c8c2fe">More...</a><br/></td></tr>
<tr class="separator:abf94a0a1d208e3916b6c9fbd90c8c2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca50a43384109d85912fb825f1250c44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aca50a43384109d85912fb825f1250c44">calculate_and_print_polyfit_rasters</a> (float window_radius, string file_prefix, vector&lt; int &gt; file_list)</td></tr>
<tr class="memdesc:aca50a43384109d85912fb825f1250c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function takes the polyfit functions and requires a window radius and a vector telling the function which rasters to print to file.  <a href="#aca50a43384109d85912fb825f1250c44">More...</a><br/></td></tr>
<tr class="separator:aca50a43384109d85912fb825f1250c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae206ccc0de12e1b0dfa6ae1370337898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae206ccc0de12e1b0dfa6ae1370337898">calculate_and_print_polyfit_and_roughness_rasters</a> (float window_radius, float roughness_radius, string file_prefix, vector&lt; int &gt; file_list)</td></tr>
<tr class="memdesc:ae206ccc0de12e1b0dfa6ae1370337898"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the combines the polyfit functions and the roughness function in one package.  <a href="#ae206ccc0de12e1b0dfa6ae1370337898">More...</a><br/></td></tr>
<tr class="separator:ae206ccc0de12e1b0dfa6ae1370337898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ec635af20e1808fdd245d4f61d2fd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad0ec635af20e1808fdd245d4f61d2fd5">calculate_roughness_rasters</a> (float window_radius, float roughness_radius, string file_prefix, vector&lt; int &gt; file_code)</td></tr>
<tr class="memdesc:ad0ec635af20e1808fdd245d4f61d2fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the combines the roughness functions in one package.  <a href="#ad0ec635af20e1808fdd245d4f61d2fd5">More...</a><br/></td></tr>
<tr class="separator:ad0ec635af20e1808fdd245d4f61d2fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe32afe622883ef703bbac4d997ad7a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abe32afe622883ef703bbac4d997ad7a1">remove_seas</a> ()</td></tr>
<tr class="memdesc:abe32afe622883ef703bbac4d997ad7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function changes any elevation &lt;= 0 to NoDataValue.  <a href="#abe32afe622883ef703bbac4d997ad7a1">More...</a><br/></td></tr>
<tr class="separator:abe32afe622883ef703bbac4d997ad7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26453b71595e28f065cd383e585f05a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae26453b71595e28f065cd383e585f05a">mask_to_nodata_below_threshold</a> (float threshold)</td></tr>
<tr class="memdesc:ae26453b71595e28f065cd383e585f05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function changes any elevation &lt;= threshold to NoDataValue.  <a href="#ae26453b71595e28f065cd383e585f05a">More...</a><br/></td></tr>
<tr class="separator:ae26453b71595e28f065cd383e585f05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1786c3a7aecae312c603b8c4468202b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a1786c3a7aecae312c603b8c4468202b5">mask_to_nodata_using_threshold</a> (float threshold, bool belowthresholdisnodata)</td></tr>
<tr class="memdesc:a1786c3a7aecae312c603b8c4468202b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function changes any data point either above or below threshold to NoDataValue.  <a href="#a1786c3a7aecae312c603b8c4468202b5">More...</a><br/></td></tr>
<tr class="separator:a1786c3a7aecae312c603b8c4468202b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f9ec033f242844ee71dbbfd6ce77f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aa2f9ec033f242844ee71dbbfd6ce77f8">mask_to_nodata_using_threshold_using_other_raster</a> (float threshold, bool belowthresholdisnodata, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;MaskingRaster)</td></tr>
<tr class="memdesc:aa2f9ec033f242844ee71dbbfd6ce77f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function changes any data point either above or below threshold to NoDataValue The threshold is determined by a second raster.  <a href="#aa2f9ec033f242844ee71dbbfd6ce77f8">More...</a><br/></td></tr>
<tr class="separator:aa2f9ec033f242844ee71dbbfd6ce77f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ea0cf684b50c7857ae2eff6942f181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a66ea0cf684b50c7857ae2eff6942f181">mask_to_indexraster_using_threshold</a> (float threshold, bool belowthresholdisnodata)</td></tr>
<tr class="memdesc:a66ea0cf684b50c7857ae2eff6942f181"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creats an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> mask (with true == 1 and otherwise nodata) from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. Can mask either above or below a threshold.  <a href="#a66ea0cf684b50c7857ae2eff6942f181">More...</a><br/></td></tr>
<tr class="separator:a66ea0cf684b50c7857ae2eff6942f181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a75facf0f59d77d39d9e908e4d3ea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#af9a75facf0f59d77d39d9e908e4d3ea4">mask_to_nodata_with_mask_raster</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Mask_raster, int mask_value)</td></tr>
<tr class="memdesc:af9a75facf0f59d77d39d9e908e4d3ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function masks a raster to nodata based on a mask value and a mask raster.  <a href="#af9a75facf0f59d77d39d9e908e4d3ea4">More...</a><br/></td></tr>
<tr class="separator:af9a75facf0f59d77d39d9e908e4d3ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef40878b1deabc0c81c79a9675eb1890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aef40878b1deabc0c81c79a9675eb1890">fill</a> ()</td></tr>
<tr class="memdesc:aef40878b1deabc0c81c79a9675eb1890"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills pits/sinks in a DEM by incrementing elevations for cells with no downslope neighbour. The process is repeated adnausium until no cells require incrementing.  <a href="#aef40878b1deabc0c81c79a9675eb1890">More...</a><br/></td></tr>
<tr class="separator:aef40878b1deabc0c81c79a9675eb1890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29cb6b8a0ceeeaa361b94197e0e0f09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab29cb6b8a0ceeeaa361b94197e0e0f09">fill_iterator</a> (Array2D&lt; float &gt; &amp;fill_data, int i, int j)</td></tr>
<tr class="memdesc:ab29cb6b8a0ceeeaa361b94197e0e0f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a recursive algorithm that is called by the fill function.  <a href="#ab29cb6b8a0ceeeaa361b94197e0e0f09">More...</a><br/></td></tr>
<tr class="separator:ab29cb6b8a0ceeeaa361b94197e0e0f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8464ee1d76a8b6b4de78e828400e727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac8464ee1d76a8b6b4de78e828400e727">fill</a> (float &amp;MinSlope)</td></tr>
<tr class="memdesc:ac8464ee1d76a8b6b4de78e828400e727"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills pits/sinks in a DEM by checking for pits from lowest to highest elevation, starting at the DEM boundary (raster edge or adjacent to NDVs).  <a href="#ac8464ee1d76a8b6b4de78e828400e727">More...</a><br/></td></tr>
<tr class="separator:ac8464ee1d76a8b6b4de78e828400e727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2f4870e7575dcc983845eaab2c976d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#afe2f4870e7575dcc983845eaab2c976d">MDFlow</a> (vector&lt; string &gt; BoundaryConditions)</td></tr>
<tr class="memdesc:afe2f4870e7575dcc983845eaab2c976d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a flow area raster using a multi direction algorithm.  <a href="#afe2f4870e7575dcc983845eaab2c976d">More...</a><br/></td></tr>
<tr class="separator:afe2f4870e7575dcc983845eaab2c976d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167eac046b8207dc711962847f737ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a167eac046b8207dc711962847f737ccc">FreemanMDFlow</a> ()</td></tr>
<tr class="memdesc:a167eac046b8207dc711962847f737ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a flow area raster using a multi direction algorithm.  <a href="#a167eac046b8207dc711962847f737ccc">More...</a><br/></td></tr>
<tr class="separator:a167eac046b8207dc711962847f737ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496d804e34d7ec4c030d6eea2ae90cb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a496d804e34d7ec4c030d6eea2ae90cb2">FreemanMDFlow_SingleSource</a> (int i_source, int j_source)</td></tr>
<tr class="memdesc:a496d804e34d7ec4c030d6eea2ae90cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Route flow from one source pixel using FreemanMDFlow. Adapted from SWDG's code above.  <a href="#a496d804e34d7ec4c030d6eea2ae90cb2">More...</a><br/></td></tr>
<tr class="separator:a496d804e34d7ec4c030d6eea2ae90cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fa0ff6fdbb7700d35d594c24d39cc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad8fa0ff6fdbb7700d35d594c24d39cc5">FMDChannelsFromChannelHeads</a> (vector&lt; int &gt; &amp;channel_heads_rows, vector&lt; int &gt; &amp;channel_heads_cols, float R_threshold)</td></tr>
<tr class="memdesc:ad8fa0ff6fdbb7700d35d594c24d39cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a multi-pixel channel network, as opposed to a single thread channel, using method outlined in Pelletier, 2013, WRR; A robust, two-parameter method for the extraction of drainage networks from high-resolution digital elevation models (DEMs): Evaluation using synthetic and real-world DEMs.  <a href="#ad8fa0ff6fdbb7700d35d594c24d39cc5">More...</a><br/></td></tr>
<tr class="separator:ad8fa0ff6fdbb7700d35d594c24d39cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e484a0efe3df226c1ecf69d11eb114b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a5e484a0efe3df226c1ecf69d11eb114b">QuinnMDFlow</a> ()</td></tr>
<tr class="memdesc:a5e484a0efe3df226c1ecf69d11eb114b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a flow area raster using a multi direction algorithm.  <a href="#a5e484a0efe3df226c1ecf69d11eb114b">More...</a><br/></td></tr>
<tr class="separator:a5e484a0efe3df226c1ecf69d11eb114b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9629de0411ee55d57b9f3b7020265d0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a9629de0411ee55d57b9f3b7020265d0f">M2DFlow</a> ()</td></tr>
<tr class="memdesc:a9629de0411ee55d57b9f3b7020265d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a flow area raster using a multi 2-direction algorithm.  <a href="#a9629de0411ee55d57b9f3b7020265d0f">More...</a><br/></td></tr>
<tr class="separator:a9629de0411ee55d57b9f3b7020265d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca4a22a3e5ea44a2eb2d0224ec40766"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#afca4a22a3e5ea44a2eb2d0224ec40766">RidgeSample</a> (Array2D&lt; float &gt; &amp;Ridges)</td></tr>
<tr class="memdesc:afca4a22a3e5ea44a2eb2d0224ec40766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module to sample <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> values running along a ridgetop network.  <a href="#afca4a22a3e5ea44a2eb2d0224ec40766">More...</a><br/></td></tr>
<tr class="separator:afca4a22a3e5ea44a2eb2d0224ec40766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83502ee2ffab4935277aec652ab4a789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a83502ee2ffab4935277aec652ab4a789">RidgeSmoother</a> (int WindowRadius)</td></tr>
<tr class="memdesc:a83502ee2ffab4935277aec652ab4a789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass a smoothing window over a ridge <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object to calculate an average value running along the ridgetop.  <a href="#a83502ee2ffab4935277aec652ab4a789">More...</a><br/></td></tr>
<tr class="separator:a83502ee2ffab4935277aec652ab4a789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21318933bf408b932c053465d0f0aa7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a21318933bf408b932c053465d0f0aa7a">RidgeBuffer</a> (int BufferRadius)</td></tr>
<tr class="memdesc:a21318933bf408b932c053465d0f0aa7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass a buffer over a ridge <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object to increase sampling area.  <a href="#a21318933bf408b932c053465d0f0aa7a">More...</a><br/></td></tr>
<tr class="separator:a21318933bf408b932c053465d0f0aa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d6f6dc51982fb2a57fb8cda09d53b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab4d6f6dc51982fb2a57fb8cda09d53b6">BasinAverager</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Basins)</td></tr>
<tr class="memdesc:ab4d6f6dc51982fb2a57fb8cda09d53b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module assigns an average <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> value to each basin.  <a href="#ab4d6f6dc51982fb2a57fb8cda09d53b6">More...</a><br/></td></tr>
<tr class="separator:ab4d6f6dc51982fb2a57fb8cda09d53b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c7f7dcdd605a47e0413d1fd08927bd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a28c7f7dcdd605a47e0413d1fd08927bd">SingleBasinAverager</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Basin)</td></tr>
<tr class="memdesc:a28c7f7dcdd605a47e0413d1fd08927bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module calculates an average value to each for a given raster from within a basin.  <a href="#a28c7f7dcdd605a47e0413d1fd08927bd">More...</a><br/></td></tr>
<tr class="separator:a28c7f7dcdd605a47e0413d1fd08927bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d26db29e36eb4d025f03d01a10577c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a54d26db29e36eb4d025f03d01a10577c">BasinArea</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Basins)</td></tr>
<tr class="memdesc:a54d26db29e36eb4d025f03d01a10577c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the area(in spatial units) of each basin to the basin's pixels.  <a href="#a54d26db29e36eb4d025f03d01a10577c">More...</a><br/></td></tr>
<tr class="separator:a54d26db29e36eb4d025f03d01a10577c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32129c11234059809449a3619d2bd84f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a32129c11234059809449a3619d2bd84f">GetBasinVector</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Basins, int BasinOfInterest)</td></tr>
<tr class="memdesc:a32129c11234059809449a3619d2bd84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a basin, given by a basin ID, into a chain of xy coordinates for fast plotting of vector basin outlines.  <a href="#a32129c11234059809449a3619d2bd84f">More...</a><br/></td></tr>
<tr class="separator:a32129c11234059809449a3619d2bd84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0215007ed0ee4132dc409687be0a89"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aca0215007ed0ee4132dc409687be0a89">BasinPuncher</a> (vector&lt; int &gt; basin_ids, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> BasinArray)</td></tr>
<tr class="memdesc:aca0215007ed0ee4132dc409687be0a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Punch basins out of an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to create DEMs of a single catchment.  <a href="#aca0215007ed0ee4132dc409687be0a89">More...</a><br/></td></tr>
<tr class="separator:aca0215007ed0ee4132dc409687be0a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ab990fdcde1aa7d4c2cfcfa3124ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae2ab990fdcde1aa7d4c2cfcfa3124ad8">CookieCutRaster</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Cutter)</td></tr>
<tr class="memdesc:ae2ab990fdcde1aa7d4c2cfcfa3124ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cookie cut a raster using a smaller raster.  <a href="#ae2ab990fdcde1aa7d4c2cfcfa3124ad8">More...</a><br/></td></tr>
<tr class="separator:ae2ab990fdcde1aa7d4c2cfcfa3124ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879a99a63a916a31a2c8eb868733eccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a879a99a63a916a31a2c8eb868733eccd">CollectBasinMetrics</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Basins, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Slope, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Elevation, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Aspect, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Area, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;<a class="el" href="class_l_s_d_raster.html#acb6d3568dc1191e7b69b6606602ac515">DrainageDensity</a>, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Cht, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;HillslopeLength, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;MeanSlope, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Relief, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;MeanAspect, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;LH_drainage_density, Array2D&lt; float &gt; LH_Data, float CriticalSlope, string RasterFilename)</td></tr>
<tr class="memdesc:a879a99a63a916a31a2c8eb868733eccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all basin average metrics into a single file.  <a href="#a879a99a63a916a31a2c8eb868733eccd">More...</a><br/></td></tr>
<tr class="separator:a879a99a63a916a31a2c8eb868733eccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0173327e0a52943052f8a3486c382e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aeb0173327e0a52943052f8a3486c382e">raster_statistics_by_index</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;IndexRaster, vector&lt; float &gt; &amp;mean_vector, vector&lt; float &gt; &amp;sd_vector, vector&lt; float &gt; &amp;serr_vector, vector&lt; int &gt; &amp;Npts_vector)</td></tr>
<tr class="memdesc:aeb0173327e0a52943052f8a3486c382e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a raster and a corresponding index raster, and calculates the mean, sd and standard error by index. Returns four vectors: mean, st.dev., st.err and Number of points for each category.  <a href="#aeb0173327e0a52943052f8a3486c382e">More...</a><br/></td></tr>
<tr class="separator:aeb0173327e0a52943052f8a3486c382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ceb6c4b936bb1b7bc8120f1e34cc2a"><td class="memItemLeft" align="right" valign="top">pair&lt; float, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab6ceb6c4b936bb1b7bc8120f1e34cc2a">Boomerang</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Slope, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;<a class="el" href="class_l_s_d_raster.html#a331723d71e095e496a4467578e26dafb">D_inf</a>, string RasterFilename, float log_bin_width=0.1, int SplineResolution=200, float bin_threshold=0.05)</td></tr>
<tr class="memdesc:ab6ceb6c4b936bb1b7bc8120f1e34cc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate data in two text files to create a boomerang plot as in Roering et al [2007].  <a href="#ab6ceb6c4b936bb1b7bc8120f1e34cc2a">More...</a><br/></td></tr>
<tr class="separator:ab6ceb6c4b936bb1b7bc8120f1e34cc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6d3568dc1191e7b69b6606602ac515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acb6d3568dc1191e7b69b6606602ac515">DrainageDensity</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;StreamNetwork, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Basins, Array2D&lt; int &gt; FlowDir)</td></tr>
<tr class="memdesc:acb6d3568dc1191e7b69b6606602ac515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate drainage density of a set of input basins.  <a href="#acb6d3568dc1191e7b69b6606602ac515">More...</a><br/></td></tr>
<tr class="separator:acb6d3568dc1191e7b69b6606602ac515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a65dc8420e194476046570ee04e802"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a75a65dc8420e194476046570ee04e802">get_drainage_density_of_raster</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;StreamNetwork, Array2D&lt; int &gt; FlowDir)</td></tr>
<tr class="memdesc:a75a65dc8420e194476046570ee04e802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate drainage density of a DEM.  <a href="#a75a65dc8420e194476046570ee04e802">More...</a><br/></td></tr>
<tr class="separator:a75a65dc8420e194476046570ee04e802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3618df18dc9c4b0e4aa8f087100053a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae3618df18dc9c4b0e4aa8f087100053a">HillslopeLengthFromDrainageDensity</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;StreamNetwork, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Basins, Array2D&lt; int &gt; FlowDir)</td></tr>
<tr class="memdesc:ae3618df18dc9c4b0e4aa8f087100053a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple method to calculate drainage density for each basin and then convert these values into a hillslope length raster.  <a href="#ae3618df18dc9c4b0e4aa8f087100053a">More...</a><br/></td></tr>
<tr class="separator:ae3618df18dc9c4b0e4aa8f087100053a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc088f9b26e7c925781a01b69a974e3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#afc088f9b26e7c925781a01b69a974e3b">GetVectors</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Magnitude, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Direction, string output_file, int step)</td></tr>
<tr class="memdesc:afc088f9b26e7c925781a01b69a974e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to export thinned vector field data to a text file.  <a href="#afc088f9b26e7c925781a01b69a974e3b">More...</a><br/></td></tr>
<tr class="separator:afc088f9b26e7c925781a01b69a974e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070a492ed5f8c076fe1fa27653117654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a070a492ed5f8c076fe1fa27653117654">NonLocalMeansFilter</a> (int WindowRadius=2, int SimilarityRadius=2, int DegreeFiltering=2, float Sigma=1.25)</td></tr>
<tr class="memdesc:a070a492ed5f8c076fe1fa27653117654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform Non-local means filtering on a DEM following Baude et al [2005].  <a href="#a070a492ed5f8c076fe1fa27653117654">More...</a><br/></td></tr>
<tr class="separator:a070a492ed5f8c076fe1fa27653117654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f8489f6abf33725b90fd1e1b88aded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a15f8489f6abf33725b90fd1e1b88aded">PadRasterSymmetric</a> (Array2D&lt; float &gt; &amp;PaddedRasterData, int &amp;SimilarityRadius)</td></tr>
<tr class="memdesc:a15f8489f6abf33725b90fd1e1b88aded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer around an array (of size SimilarityRadius) and gives the new border mirror symmetric values of the original array reflected across the boundary.  <a href="#a15f8489f6abf33725b90fd1e1b88aded">More...</a><br/></td></tr>
<tr class="separator:a15f8489f6abf33725b90fd1e1b88aded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fa514549d4c6fbd9d662639cf433b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a69fa514549d4c6fbd9d662639cf433b7">MakeGaussianKernel</a> (Array2D&lt; float &gt; &amp;Kernel, float sigma, int SimilarityRadius)</td></tr>
<tr class="memdesc:a69fa514549d4c6fbd9d662639cf433b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate gaussian weighted kernel.  <a href="#a69fa514549d4c6fbd9d662639cf433b7">More...</a><br/></td></tr>
<tr class="separator:a69fa514549d4c6fbd9d662639cf433b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6136e17477083dcb28e0c60fdf14038"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aa6136e17477083dcb28e0c60fdf14038">GaussianFilter</a> (float sigma, int kr=0)</td></tr>
<tr class="memdesc:aa6136e17477083dcb28e0c60fdf14038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the raster using a square 2D Gaussian filter. The filter is applied using a moving kernel of gaussian weights with a radius of 3*sigma.  <a href="#aa6136e17477083dcb28e0c60fdf14038">More...</a><br/></td></tr>
<tr class="separator:aa6136e17477083dcb28e0c60fdf14038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e482d20d43327c6ee6e2f6190dbe736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2e482d20d43327c6ee6e2f6190dbe736">PeronaMalikFilter</a> (int timesteps, float percentile_for_lambda, float dt)</td></tr>
<tr class="memdesc:a2e482d20d43327c6ee6e2f6190dbe736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the raster using a Perona-Malik non-linear diffusion filter.  <a href="#a2e482d20d43327c6ee6e2f6190dbe736">More...</a><br/></td></tr>
<tr class="separator:a2e482d20d43327c6ee6e2f6190dbe736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ed6f1737d703a6e2db5fa385e59dfd"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a23ed6f1737d703a6e2db5fa385e59dfd">D_inf_FlowDir</a> ()</td></tr>
<tr class="memdesc:a23ed6f1737d703a6e2db5fa385e59dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">D-infinity flow direction algorithm after Tarboton (1997).  <a href="#a23ed6f1737d703a6e2db5fa385e59dfd">More...</a><br/></td></tr>
<tr class="separator:a23ed6f1737d703a6e2db5fa385e59dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b70073ef6f1a23ae832c98c2e087ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae8b70073ef6f1a23ae832c98c2e087ee">D_inf_FlowArea</a> (Array2D&lt; float &gt; FlowDir_array)</td></tr>
<tr class="memdesc:ae8b70073ef6f1a23ae832c98c2e087ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function for generating a D-infinity flow area raster after Tarboton (1997).  <a href="#ae8b70073ef6f1a23ae832c98c2e087ee">More...</a><br/></td></tr>
<tr class="separator:ae8b70073ef6f1a23ae832c98c2e087ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8177cf5be3dd00700a04f72722676cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab8177cf5be3dd00700a04f72722676cd">D_infAccum</a> (int i, int j, Array2D&lt; float &gt; CountGrid, Array2D&lt; float &gt; Flowarea_Raster, Array2D&lt; float &gt; FlowDir_array)</td></tr>
<tr class="memdesc:ab8177cf5be3dd00700a04f72722676cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive function to calculate accumulating area for a given pixel.  <a href="#ab8177cf5be3dd00700a04f72722676cd">More...</a><br/></td></tr>
<tr class="separator:ab8177cf5be3dd00700a04f72722676cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331723d71e095e496a4467578e26dafb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a331723d71e095e496a4467578e26dafb">D_inf</a> ()</td></tr>
<tr class="memdesc:a331723d71e095e496a4467578e26dafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper Function to create a D-infinity flow area raster with one function call.  <a href="#a331723d71e095e496a4467578e26dafb">More...</a><br/></td></tr>
<tr class="separator:a331723d71e095e496a4467578e26dafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddb73dd9d50df2c09422da36bfad0f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#adddb73dd9d50df2c09422da36bfad0f9">D_inf_units</a> ()</td></tr>
<tr class="memdesc:adddb73dd9d50df2c09422da36bfad0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper Function to create a D-infinity flow area raster, in spatial units, with one function call.  <a href="#adddb73dd9d50df2c09422da36bfad0f9">More...</a><br/></td></tr>
<tr class="separator:adddb73dd9d50df2c09422da36bfad0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe51c2dd1980080101ce669301d426f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2fe51c2dd1980080101ce669301d426f">D_inf_ConvertFlowToArea</a> ()</td></tr>
<tr class="memdesc:a2fe51c2dd1980080101ce669301d426f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper Function to convert a D-infinity flow raster into spatial units.  <a href="#a2fe51c2dd1980080101ce669301d426f">More...</a><br/></td></tr>
<tr class="separator:a2fe51c2dd1980080101ce669301d426f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef35a4944909540182a86f86fc7a20a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aef35a4944909540182a86f86fc7a20a5">write_dinf_flowdir_to_LSDRaster</a> (Array2D&lt; float &gt; dinflow)</td></tr>
<tr class="memdesc:aef35a4944909540182a86f86fc7a20a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to write the D-infinity flow directions to an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>.  <a href="#aef35a4944909540182a86f86fc7a20a5">More...</a><br/></td></tr>
<tr class="separator:aef35a4944909540182a86f86fc7a20a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d61141306c7b413b7f2528836ceeb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac3d61141306c7b413b7f2528836ceeb1">D_inf_watershed</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> <a class="el" href="class_l_s_d_raster.html#a23ed6f1737d703a6e2db5fa385e59dfd">D_inf_FlowDir</a>, int PourRow, int PourCol)</td></tr>
<tr class="memdesc:ac3d61141306c7b413b7f2528836ceeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to generate upslope contributing area extent from the D-infinity flow directions to an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>.  <a href="#ac3d61141306c7b413b7f2528836ceeb1">More...</a><br/></td></tr>
<tr class="separator:ac3d61141306c7b413b7f2528836ceeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3948a815d7a5634834a42a9ae7e5cd58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a3948a815d7a5634834a42a9ae7e5cd58">calculate_topographic_index</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;AccumulationArea, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Slope)</td></tr>
<tr class="memdesc:a3948a815d7a5634834a42a9ae7e5cd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the topographic index, a moisture distribution indicator.  <a href="#a3948a815d7a5634834a42a9ae7e5cd58">More...</a><br/></td></tr>
<tr class="separator:a3948a815d7a5634834a42a9ae7e5cd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25df4b9a8c3ddc1c7db18fb44bc2b6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac25df4b9a8c3ddc1c7db18fb44bc2b6e">PointShapefileToRaster</a> (string FileName)</td></tr>
<tr class="memdesc:ac25df4b9a8c3ddc1c7db18fb44bc2b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to turn a point shapefile into an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>.  <a href="#ac25df4b9a8c3ddc1c7db18fb44bc2b6e">More...</a><br/></td></tr>
<tr class="separator:ac25df4b9a8c3ddc1c7db18fb44bc2b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682b6387335aef59febeda5c49598a04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a682b6387335aef59febeda5c49598a04">PolylineShapefileToRaster</a> (string FileName)</td></tr>
<tr class="memdesc:a682b6387335aef59febeda5c49598a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to turn a polyline shapefile into an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>.  <a href="#a682b6387335aef59febeda5c49598a04">More...</a><br/></td></tr>
<tr class="separator:a682b6387335aef59febeda5c49598a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdc54eca6f5b0807d424fd981a85971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aafdc54eca6f5b0807d424fd981a85971">Resample</a> (float OutputResolution)</td></tr>
<tr class="memdesc:aafdc54eca6f5b0807d424fd981a85971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to resample an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to a lower resolution.  <a href="#aafdc54eca6f5b0807d424fd981a85971">More...</a><br/></td></tr>
<tr class="separator:aafdc54eca6f5b0807d424fd981a85971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0766768246987cca6e55f0849107778b"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a0766768246987cca6e55f0849107778b">create_mask</a> (float window_radius, int neighbourhood_switch)</td></tr>
<tr class="memdesc:a0766768246987cca6e55f0849107778b"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a circular mask for neighbourhood statistics  <a href="#a0766768246987cca6e55f0849107778b">More...</a><br/></td></tr>
<tr class="separator:a0766768246987cca6e55f0849107778b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3f409837c842162c26ad80036baa24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#add3f409837c842162c26ad80036baa24">neighbourhood_statistics_spatial_average</a> (float window_radius, int neighbourhood_switch)</td></tr>
<tr class="memdesc:add3f409837c842162c26ad80036baa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets mean value for specified circular neighbourhood  <a href="#add3f409837c842162c26ad80036baa24">More...</a><br/></td></tr>
<tr class="separator:add3f409837c842162c26ad80036baa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb71a579a1f8e5bf5847b1e61b374ba4"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acb71a579a1f8e5bf5847b1e61b374ba4">neighbourhood_statistics_spatial_average_and_SD</a> (float window_radius, int neighbourhood_switch)</td></tr>
<tr class="memdesc:acb71a579a1f8e5bf5847b1e61b374ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets mean &amp; standard deviation value specified circular neighbourhood  <a href="#acb71a579a1f8e5bf5847b1e61b374ba4">More...</a><br/></td></tr>
<tr class="separator:acb71a579a1f8e5bf5847b1e61b374ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3d1d5ceab7f16949a14c19c7abbc18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aca3d1d5ceab7f16949a14c19c7abbc18">neighbourhood_statistics_local_relief</a> (float window_radius, int neighbourhood_switch)</td></tr>
<tr class="memdesc:aca3d1d5ceab7f16949a14c19c7abbc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets relief within value specified circular neighbourhood  <a href="#aca3d1d5ceab7f16949a14c19c7abbc18">More...</a><br/></td></tr>
<tr class="separator:aca3d1d5ceab7f16949a14c19c7abbc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058821368f5f48758cf102062f691ace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a058821368f5f48758cf102062f691ace">neighbourhood_statistics_fraction_condition</a> (float window_radius, int neighbourhood_switch, int condition_switch, float test_value)</td></tr>
<tr class="memdesc:a058821368f5f48758cf102062f691ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests neighbourhood for the fraction of values for which the specified condition is met.  <a href="#a058821368f5f48758cf102062f691ace">More...</a><br/></td></tr>
<tr class="separator:a058821368f5f48758cf102062f691ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a190d2415b9087054b44a1b577c3ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a42a190d2415b9087054b44a1b577c3ed">border_with_nodata</a> (int border_width, int irregular_switch=0)</td></tr>
<tr class="memdesc:a42a190d2415b9087054b44a1b577c3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to change border pixels to nodata.  <a href="#a42a190d2415b9087054b44a1b577c3ed">More...</a><br/></td></tr>
<tr class="separator:a42a190d2415b9087054b44a1b577c3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48280de81ceb10c1b509676e632a2cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#af48280de81ceb10c1b509676e632a2cb">find_cells_bordered_by_nodata</a> ()</td></tr>
<tr class="memdesc:af48280de81ceb10c1b509676e632a2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a mask that has the value of 1 for cells that are either on the edge or bordered by nodata (from their 9 neighbors)  <a href="#af48280de81ceb10c1b509676e632a2cb">More...</a><br/></td></tr>
<tr class="separator:af48280de81ceb10c1b509676e632a2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72361701912660a064734779ef60954b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a72361701912660a064734779ef60954b">check_isolated_nodata</a> ()</td></tr>
<tr class="memdesc:a72361701912660a064734779ef60954b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This looks for isolated instances of no data.  <a href="#a72361701912660a064734779ef60954b">More...</a><br/></td></tr>
<tr class="separator:a72361701912660a064734779ef60954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32042e55758bdf70dd50f631727fc787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a32042e55758bdf70dd50f631727fc787">rudimentary_nodata_fill</a> ()</td></tr>
<tr class="memdesc:a32042e55758bdf70dd50f631727fc787"><td class="mdescLeft">&#160;</td><td class="mdescRight">a very rudimentay filling routine that just fills nodata nodes with the average elevation of its neighbors  <a href="#a32042e55758bdf70dd50f631727fc787">More...</a><br/></td></tr>
<tr class="separator:a32042e55758bdf70dd50f631727fc787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e94622f9b8a1558bdba2bbb50829764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a4e94622f9b8a1558bdba2bbb50829764">alternating_direction_nodata_fill</a> (int window_width)</td></tr>
<tr class="memdesc:a4e94622f9b8a1558bdba2bbb50829764"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that fills nodata holes. It cannot recognise nodata around the edges so the spiral trimmer should be used first  The routine sweeps the raster looking for nodata and filling this nodata with an average value from surrounding nodes. The sweeping changes directions, four sweep directions in all (+ rows, - rows, + cols, -cols) and it alternates between these directions until the raster is filled.  <a href="#a4e94622f9b8a1558bdba2bbb50829764">More...</a><br/></td></tr>
<tr class="separator:a4e94622f9b8a1558bdba2bbb50829764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4900b2a06bf880a98ed09c12d394c392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a4900b2a06bf880a98ed09c12d394c392">create_binary_isdata_raster</a> ()</td></tr>
<tr class="memdesc:a4900b2a06bf880a98ed09c12d394c392"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns an index raster with 1 for data and 0 for nodata.  <a href="#a4900b2a06bf880a98ed09c12d394c392">More...</a><br/></td></tr>
<tr class="separator:a4900b2a06bf880a98ed09c12d394c392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4083c73f25904c819f4a6dc5e84f03e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a4083c73f25904c819f4a6dc5e84f03e4">alternating_direction_nodata_fill_with_trimmer</a> (int window_width)</td></tr>
<tr class="memdesc:a4083c73f25904c819f4a6dc5e84f03e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that fills nodata holes. It first prepares the data with the sprial trimmer so nodata around the edges is removed.  The routine sweeps the raster looking for nodata and filling this nodata with an average value from surrounding nodes. The sweeping changes directions, four sweep directions in all (+ rows, - rows, + cols, -cols) and it alternates between these directions until the raster is filled. The routine is particularly useful for data with holes that is to be prepared for spectral analysis.  <a href="#a4083c73f25904c819f4a6dc5e84f03e4">More...</a><br/></td></tr>
<tr class="separator:a4083c73f25904c819f4a6dc5e84f03e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2709b4b8c999a6a5b504a0383381fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf2709b4b8c999a6a5b504a0383381fa"></a>
<a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acf2709b4b8c999a6a5b504a0383381fa">nodata_fill_irregular_raster</a> (int window_radius)</td></tr>
<tr class="memdesc:acf2709b4b8c999a6a5b504a0383381fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to fill in no data holes in an irregular raster. Pixel must have all neighbours not equal to no data value within the specified window radius. Data is filled based on mean of pixels within the window radius. <br/></td></tr>
<tr class="separator:acf2709b4b8c999a6a5b504a0383381fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44ce1cb61d914e03738c608e543208f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab44ce1cb61d914e03738c608e543208f">alternating_direction_nodata_fill_irregular_raster</a> (int window_width)</td></tr>
<tr class="memdesc:ab44ce1cb61d914e03738c608e543208f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that fills nodata holes. Modified by FJC to only fill holes surrounded in all directions by pixels with valid elevation values.  <a href="#ab44ce1cb61d914e03738c608e543208f">More...</a><br/></td></tr>
<tr class="separator:ab44ce1cb61d914e03738c608e543208f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcb6e797d48233ac7fa06ff64c41409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acdcb6e797d48233ac7fa06ff64c41409">Create_Mask</a> (string Condition, float TestValue)</td></tr>
<tr class="memdesc:acdcb6e797d48233ac7fa06ff64c41409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a masked <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> raster based on a conditional statement.  <a href="#acdcb6e797d48233ac7fa06ff64c41409">More...</a><br/></td></tr>
<tr class="separator:acdcb6e797d48233ac7fa06ff64c41409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869906150040117268fdad50b81402b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a869906150040117268fdad50b81402b9">ExtractByMask</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Mask)</td></tr>
<tr class="memdesc:a869906150040117268fdad50b81402b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to extract an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> based on a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> mask.  <a href="#a869906150040117268fdad50b81402b9">More...</a><br/></td></tr>
<tr class="separator:a869906150040117268fdad50b81402b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821d1f21bc4b3eb32b61e92a56f95982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a821d1f21bc4b3eb32b61e92a56f95982">MaskRaster</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Mask)</td></tr>
<tr class="memdesc:a821d1f21bc4b3eb32b61e92a56f95982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> based on a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> mask.  <a href="#a821d1f21bc4b3eb32b61e92a56f95982">More...</a><br/></td></tr>
<tr class="separator:a821d1f21bc4b3eb32b61e92a56f95982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4859921d32b0ff29fad31f89ec8b941"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#af4859921d32b0ff29fad31f89ec8b941">IsolateChannelsLashermesCurvature</a> (float sigma, string q_q_filename)</td></tr>
<tr class="memdesc:af4859921d32b0ff29fad31f89ec8b941"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to locate channel pixels outlined by Lashermes.  <a href="#af4859921d32b0ff29fad31f89ec8b941">More...</a><br/></td></tr>
<tr class="separator:af4859921d32b0ff29fad31f89ec8b941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bf4a36e76540ccfb255c7137aeccd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07bf4a36e76540ccfb255c7137aeccd4"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IsolateChannelsLashermesAspect</b> (float sigma, string q_q_filename)</td></tr>
<tr class="separator:a07bf4a36e76540ccfb255c7137aeccd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c92f8d2b2daeba77f167c7bec8728f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c92f8d2b2daeba77f167c7bec8728f6"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IsolateChannelsLashermesFull</b> (float sigma, string q_q_filename_prefix)</td></tr>
<tr class="separator:a4c92f8d2b2daeba77f167c7bec8728f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3158314bdc432fdc1a52acbb356a0e23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3158314bdc432fdc1a52acbb356a0e23"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IsolateChannelsLashermesCurvatureArea</b> (float sigma, float area_threshold, string q_q_filename)</td></tr>
<tr class="separator:a3158314bdc432fdc1a52acbb356a0e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5d20b56b3ec4ae4b34846257477a5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a5f5d20b56b3ec4ae4b34846257477a5f">IsolateChannelsGeonet</a> (float timesteps, float area_threshold, float window_radius, string q_q_filename)</td></tr>
<tr class="memdesc:a5f5d20b56b3ec4ae4b34846257477a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to locate channel pixels outlined by Passalacqua et al. (2010).  <a href="#a5f5d20b56b3ec4ae4b34846257477a5f">More...</a><br/></td></tr>
<tr class="separator:a5f5d20b56b3ec4ae4b34846257477a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aabb85de4b848f357b3f92d7a26b1c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a6aabb85de4b848f357b3f92d7a26b1c0">IsolateChannelsQuantileQuantile</a> (string q_q_filename)</td></tr>
<tr class="memdesc:a6aabb85de4b848f357b3f92d7a26b1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">uses quantile-quantile analysis to pick departure from gaussian behaviour, then uses this as a threshold to create a binary dataset.  <a href="#a6aabb85de4b848f357b3f92d7a26b1c0">More...</a><br/></td></tr>
<tr class="separator:a6aabb85de4b848f357b3f92d7a26b1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f569f226055c02da8ddbafbf80fb3b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f569f226055c02da8ddbafbf80fb3b9"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IsolateChannelsQuantileQuantileAdaptive</b> (int half_width)</td></tr>
<tr class="separator:a3f569f226055c02da8ddbafbf80fb3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d1f8c8b202df072becb69100d93839"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a79d1f8c8b202df072becb69100d93839">CalculateAdaptiveCurvatureThresholdSD</a> (int half_width)</td></tr>
<tr class="memdesc:a79d1f8c8b202df072becb69100d93839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the curvature threshold used for DrEICH channel extraction which varies across the landscape.  <a href="#a79d1f8c8b202df072becb69100d93839">More...</a><br/></td></tr>
<tr class="separator:a79d1f8c8b202df072becb69100d93839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d2ee698cc2b672ea70dcff2564b93e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac1d2ee698cc2b672ea70dcff2564b93e">CreateHilltopPatches</a> (int minimum_patch_size)</td></tr>
<tr class="memdesc:ac1d2ee698cc2b672ea70dcff2564b93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to convert an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> hilltop file into a series of contigiuous hilltop patches.  <a href="#ac1d2ee698cc2b672ea70dcff2564b93e">More...</a><br/></td></tr>
<tr class="separator:ac1d2ee698cc2b672ea70dcff2564b93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33e4e010d721dcd98d4605e45a299d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab33e4e010d721dcd98d4605e45a299d3"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CreateHilltopPatchesNEW</b> (int minimum_patch_size)</td></tr>
<tr class="separator:ab33e4e010d721dcd98d4605e45a299d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbd534a153549a070747668ee82b5e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abdbd534a153549a070747668ee82b5e3">FlattenToFile</a> (string FileName)</td></tr>
<tr class="memdesc:abdbd534a153549a070747668ee82b5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple method to flatten an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to a text file, with a sigle value on each line.  <a href="#abdbd534a153549a070747668ee82b5e3">More...</a><br/></td></tr>
<tr class="separator:abdbd534a153549a070747668ee82b5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1891ab358d51150fd78960d37ddd19ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a1891ab358d51150fd78960d37ddd19ee">FlattenToCSV</a> (string FileName)</td></tr>
<tr class="memdesc:a1891ab358d51150fd78960d37ddd19ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to flatten an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> and place the non NDV values in a csv file.  <a href="#a1891ab358d51150fd78960d37ddd19ee">More...</a><br/></td></tr>
<tr class="separator:a1891ab358d51150fd78960d37ddd19ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04779a5d0361d814ca82c0e65678cba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a04779a5d0361d814ca82c0e65678cba7">FlattenToWGS84CSV</a> (string FileName)</td></tr>
<tr class="memdesc:a04779a5d0361d814ca82c0e65678cba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to flatten an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> and place the non NDV values in a csv file.  <a href="#a04779a5d0361d814ca82c0e65678cba7">More...</a><br/></td></tr>
<tr class="separator:a04779a5d0361d814ca82c0e65678cba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f89819eff281f83e613c5d3f9952b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a3f89819eff281f83e613c5d3f9952b3c">RemoveBelow</a> (float Value)</td></tr>
<tr class="memdesc:a3f89819eff281f83e613c5d3f9952b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple method to remove any values below a user supplied value from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>.  <a href="#a3f89819eff281f83e613c5d3f9952b3c">More...</a><br/></td></tr>
<tr class="separator:a3f89819eff281f83e613c5d3f9952b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac89c6707b5e24a1e0ba8261352533f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aac89c6707b5e24a1e0ba8261352533f7">RemoveAbove</a> (float Value)</td></tr>
<tr class="memdesc:aac89c6707b5e24a1e0ba8261352533f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple method to remove any values above a user supplied value from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>.  <a href="#aac89c6707b5e24a1e0ba8261352533f7">More...</a><br/></td></tr>
<tr class="separator:aac89c6707b5e24a1e0ba8261352533f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa304348f61e9ca3726d50f3d437258e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aa304348f61e9ca3726d50f3d437258e8">apply_mask</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;mask)</td></tr>
<tr class="memdesc:aa304348f61e9ca3726d50f3d437258e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a mask to a raster dataset, converts pixels to nodata where mas=k=1  <a href="#aa304348f61e9ca3726d50f3d437258e8">More...</a><br/></td></tr>
<tr class="separator:aa304348f61e9ca3726d50f3d437258e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc4d506a8dd46bd2f23fc1a3ce354fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abcc4d506a8dd46bd2f23fc1a3ce354fe">ConvertToBinary</a> (int Value, int ndv)</td></tr>
<tr class="memdesc:abcc4d506a8dd46bd2f23fc1a3ce354fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to convert all values in an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to a single value.  <a href="#abcc4d506a8dd46bd2f23fc1a3ce354fe">More...</a><br/></td></tr>
<tr class="separator:abcc4d506a8dd46bd2f23fc1a3ce354fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f80e0c1d976238555a4518a092c21a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a47f80e0c1d976238555a4518a092c21a">MergeRasters</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;RasterToAdd)</td></tr>
<tr class="memdesc:a47f80e0c1d976238555a4518a092c21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to merge data from two LSDRasters WITH SAME EXTENT together. /// The data from the raster specified as an argument will be added (will overwrite the original raster if there is a conflict).  <a href="#a47f80e0c1d976238555a4518a092c21a">More...</a><br/></td></tr>
<tr class="separator:a47f80e0c1d976238555a4518a092c21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9674b03324b823871c59ffe549669082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a9674b03324b823871c59ffe549669082">OverwriteRaster</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;RasterToAdd)</td></tr>
<tr class="memdesc:a9674b03324b823871c59ffe549669082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to merge data from two LSDRasters WITH SAME EXTENT together. /// The data from the raster specified as an argument will be added (will overwrite the original raster if there is a conflict). Overloaded function to rewrite original raster rather than creating a new one.  <a href="#a9674b03324b823871c59ffe549669082">More...</a><br/></td></tr>
<tr class="separator:a9674b03324b823871c59ffe549669082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4104b232e5686b68070ce4f7d29c21f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a4104b232e5686b68070ce4f7d29c21f1">get_potential_floodplain_patches</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Relief, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Slope, float relief_threshold, float slope_threshold)</td></tr>
<tr class="memdesc:a4104b232e5686b68070ce4f7d29c21f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get potential floodplain patches using a slope and relief threshold.  <a href="#a4104b232e5686b68070ce4f7d29c21f1">More...</a><br/></td></tr>
<tr class="separator:a4104b232e5686b68070ce4f7d29c21f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372400c4d0d1b4a5365b8973ce1301c4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a372400c4d0d1b4a5365b8973ce1301c4">get_threshold_for_floodplain</a> (float bin_width, float peak_threshold, int peak_distance)</td></tr>
<tr class="memdesc:a372400c4d0d1b4a5365b8973ce1301c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get threshold from a raster using a histogram of Probability-Density values. The function identifies the peaks in the PDF, and sets the threshold to the peak with the lowest value. This can be used to set the floodplain threshold.  <a href="#a372400c4d0d1b4a5365b8973ce1301c4">More...</a><br/></td></tr>
<tr class="separator:a372400c4d0d1b4a5365b8973ce1301c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983ed9b8d8f60fb2890dba50d48408df"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a983ed9b8d8f60fb2890dba50d48408df">get_threshold_for_floodplain_QQ</a> (string q_q_filename, float threshold_condition, int lower_percentile, int upper_percentile)</td></tr>
<tr class="memdesc:a983ed9b8d8f60fb2890dba50d48408df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get threshold from a raster using qq plots.  <a href="#a983ed9b8d8f60fb2890dba50d48408df">More...</a><br/></td></tr>
<tr class="separator:a983ed9b8d8f60fb2890dba50d48408df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bf04f5047c82d16cc0bd0c1a8e04ee"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a87bf04f5047c82d16cc0bd0c1a8e04ee">ChannelLengthByOrder</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;StreamNetwork, Array2D&lt; int &gt; FlowDir)</td></tr>
<tr class="memdesc:a87bf04f5047c82d16cc0bd0c1a8e04ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lengths in spatial units of each part of the channel network, divided by strahler order.  <a href="#a87bf04f5047c82d16cc0bd0c1a8e04ee">More...</a><br/></td></tr>
<tr class="separator:a87bf04f5047c82d16cc0bd0c1a8e04ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34295ea8299a2bef045984f833c33976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a34295ea8299a2bef045984f833c33976">PoupulateRasterGaussian</a> (float minimum, float mean)</td></tr>
<tr class="memdesc:a34295ea8299a2bef045984f833c33976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a raster with random noise drawn from a gaussian distribution of given mean and minimum values.  <a href="#a34295ea8299a2bef045984f833c33976">More...</a><br/></td></tr>
<tr class="separator:a34295ea8299a2bef045984f833c33976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821e7693904a2ea45fef8e6414988d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a821e7693904a2ea45fef8e6414988d07">PoupulateRasterSingleValue</a> (float value)</td></tr>
<tr class="memdesc:a821e7693904a2ea45fef8e6414988d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a raster with a single value.  <a href="#a821e7693904a2ea45fef8e6414988d07">More...</a><br/></td></tr>
<tr class="separator:a821e7693904a2ea45fef8e6414988d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4f18c6ed62e541057f3a604a84fb35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#adf4f18c6ed62e541057f3a604a84fb35">HilltopsToCSV</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;CHT, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;CHT_gradient, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;gradient, int UTMZone, bool isNorth, int eId, string filename)</td></tr>
<tr class="memdesc:adf4f18c6ed62e541057f3a604a84fb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write CHT and hilltop gradient data to a *.csv file, coded by UTM coordinates as well as lat/long.  <a href="#adf4f18c6ed62e541057f3a604a84fb35">More...</a><br/></td></tr>
<tr class="separator:adf4f18c6ed62e541057f3a604a84fb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78165b8a11dccdeb493fbfe892aa17d"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae78165b8a11dccdeb493fbfe892aa17d">Sample_Along_Ridge</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Raster1, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Raster2, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Raster3, int a, int b, int threshold)</td></tr>
<tr class="memdesc:ae78165b8a11dccdeb493fbfe892aa17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample the values of 3 input rasters that intersect with the point a,b within the area defined by threshold.  <a href="#ae78165b8a11dccdeb493fbfe892aa17d">More...</a><br/></td></tr>
<tr class="separator:ae78165b8a11dccdeb493fbfe892aa17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb88fa7304a7a05928250352230ef123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aeb88fa7304a7a05928250352230ef123">convert_from_feet_to_metres</a> ()</td></tr>
<tr class="memdesc:aeb88fa7304a7a05928250352230ef123"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to convert feet to metres using US international feet, where 1 foot = 0.3048006096012192 metres.  <a href="#aeb88fa7304a7a05928250352230ef123">More...</a><br/></td></tr>
<tr class="separator:aeb88fa7304a7a05928250352230ef123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801154ac96833085a14a0a16814781f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a801154ac96833085a14a0a16814781f8">convert_from_centimetres_to_metres</a> ()</td></tr>
<tr class="memdesc:a801154ac96833085a14a0a16814781f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to convert elevations from centimetres to metres  <a href="#a801154ac96833085a14a0a16814781f8">More...</a><br/></td></tr>
<tr class="separator:a801154ac96833085a14a0a16814781f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac88ec4e856cb32a69f58b7da5bfc24c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac88ec4e856cb32a69f58b7da5bfc24c0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac88ec4e856cb32a69f58b7da5bfc24c0">NRows</a></td></tr>
<tr class="memdesc:ac88ec4e856cb32a69f58b7da5bfc24c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows. <br/></td></tr>
<tr class="separator:ac88ec4e856cb32a69f58b7da5bfc24c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5835c070514b4bfc39b730e117a3abb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5835c070514b4bfc39b730e117a3abb7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a5835c070514b4bfc39b730e117a3abb7">NCols</a></td></tr>
<tr class="memdesc:a5835c070514b4bfc39b730e117a3abb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns. <br/></td></tr>
<tr class="separator:a5835c070514b4bfc39b730e117a3abb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7ca2d66394d42913c09c27478b9bef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d7ca2d66394d42913c09c27478b9bef"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a0d7ca2d66394d42913c09c27478b9bef">XMinimum</a></td></tr>
<tr class="memdesc:a0d7ca2d66394d42913c09c27478b9bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum X coordinate. <br/></td></tr>
<tr class="separator:a0d7ca2d66394d42913c09c27478b9bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273693464ba52e8280efe84700dcd680"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a273693464ba52e8280efe84700dcd680"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a273693464ba52e8280efe84700dcd680">YMinimum</a></td></tr>
<tr class="memdesc:a273693464ba52e8280efe84700dcd680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum Y coordinate. <br/></td></tr>
<tr class="separator:a273693464ba52e8280efe84700dcd680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cc9f431dddb56ed538b398f0d3d8ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07cc9f431dddb56ed538b398f0d3d8ed"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a07cc9f431dddb56ed538b398f0d3d8ed">DataResolution</a></td></tr>
<tr class="memdesc:a07cc9f431dddb56ed538b398f0d3d8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data resolution. <br/></td></tr>
<tr class="separator:a07cc9f431dddb56ed538b398f0d3d8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dfb77f3740c6842cb3ff375635fd01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03dfb77f3740c6842cb3ff375635fd01"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a03dfb77f3740c6842cb3ff375635fd01">NoDataValue</a></td></tr>
<tr class="memdesc:a03dfb77f3740c6842cb3ff375635fd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">No data value. <br/></td></tr>
<tr class="separator:a03dfb77f3740c6842cb3ff375635fd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc7c8d78e57b02aa72d243b4cc755af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fc7c8d78e57b02aa72d243b4cc755af"></a>
map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2fc7c8d78e57b02aa72d243b4cc755af">GeoReferencingStrings</a></td></tr>
<tr class="memdesc:a2fc7c8d78e57b02aa72d243b4cc755af"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of strings for holding georeferencing information. <br/></td></tr>
<tr class="separator:a2fc7c8d78e57b02aa72d243b4cc755af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ac67e4da1ad0e36d097687411d4707"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1ac67e4da1ad0e36d097687411d4707"></a>
Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab1ac67e4da1ad0e36d097687411d4707">RasterData</a></td></tr>
<tr class="memdesc:ab1ac67e4da1ad0e36d097687411d4707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raster data. <br/></td></tr>
<tr class="separator:ab1ac67e4da1ad0e36d097687411d4707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd9c7284b4fe091960b78e47c079f72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdd9c7284b4fe091960b78e47c079f72"></a>
Array2D&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acdd9c7284b4fe091960b78e47c079f72">RasterData_dbl</a></td></tr>
<tr class="memdesc:acdd9c7284b4fe091960b78e47c079f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are used primarily by <a class="el" href="class_l_s_d_catchment_model.html" title="This object is used to model the hydrology, sediment transport and evolution of individual basins...">LSDCatchmentModel</a>. <br/></td></tr>
<tr class="separator:acdd9c7284b4fe091960b78e47c079f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2050da482727bd81d58d55ceb2ae16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c2050da482727bd81d58d55ceb2ae16"></a>
Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RasterData_int</b></td></tr>
<tr class="separator:a6c2050da482727bd81d58d55ceb2ae16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1e929df4b8c91996b5a60e216489c324"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e929df4b8c91996b5a60e216489c324"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a1e929df4b8c91996b5a60e216489c324">LSDFlowInfo</a></td></tr>
<tr class="memdesc:a1e929df4b8c91996b5a60e216489c324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object to perform flow routing. <br/></td></tr>
<tr class="separator:a1e929df4b8c91996b5a60e216489c324"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main analysis object to interface with other LSD objects. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0e1cb2277ff6670a4452a60156bae824"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDRaster::LSDRaster </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> from a file. Uses a filename and file extension. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A String, the file to be loaded. </td></tr>
    <tr><td class="paramname">extension</td><td>A String, the file extension to be loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed823ec252536362362c1eccd90be6b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDRaster::LSDRaster </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ymin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cellsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ndv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> from memory. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nrows</td><td>An integer of the number of rows. </td></tr>
    <tr><td class="paramname">ncols</td><td>An integer of the number of columns. </td></tr>
    <tr><td class="paramname">xmin</td><td>A float of the minimum X coordinate. </td></tr>
    <tr><td class="paramname">ymin</td><td>A float of the minimum Y coordinate. </td></tr>
    <tr><td class="paramname">cellsize</td><td>A float of the cellsize. </td></tr>
    <tr><td class="paramname">ndv</td><td>An integer of the no data value. </td></tr>
    <tr><td class="paramname">data</td><td>An Array2D of floats in the shape nrows*ncols, containing the data to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bce22c0ea43adab9572e8f7ab0a94ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDRaster::LSDRaster </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ymin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cellsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ndv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; double &gt;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> from memory, with the elvation data stored as double precision floats. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a></dd></dl>
<p>Created to maintain compatibility with <a class="el" href="class_l_s_d_catchment_model.html" title="This object is used to model the hydrology, sediment transport and evolution of individual basins...">LSDCatchmentModel</a> </p>
<dl class="section author"><dt>Author</dt><dd>DAV </dd></dl>

</div>
</div>
<a class="anchor" id="a33936fc57aac1a226186f7330abad2fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDRaster::LSDRaster </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ymin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cellsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ndv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, string &gt;&#160;</td>
          <td class="paramname"><em>temp_GRS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> from memory, includes georeferencing. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nrows</td><td>An integer of the number of rows. </td></tr>
    <tr><td class="paramname">ncols</td><td>An integer of the number of columns. </td></tr>
    <tr><td class="paramname">xmin</td><td>A float of the minimum X coordinate. </td></tr>
    <tr><td class="paramname">ymin</td><td>A float of the minimum Y coordinate. </td></tr>
    <tr><td class="paramname">cellsize</td><td>A float of the cellsize. </td></tr>
    <tr><td class="paramname">ndv</td><td>An integer of the no data value. </td></tr>
    <tr><td class="paramname">data</td><td>An Array2D of floats in the shape nrows*ncols, </td></tr>
    <tr><td class="paramname">temp_GRS</td><td>a map of strings containing georeferencing information. Used mainly with ENVI format files containing the data to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4e94622f9b8a1558bdba2bbb50829764"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::alternating_direction_nodata_fill </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>window_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine that fills nodata holes. It cannot recognise nodata around the edges so the spiral trimmer should be used first  The routine sweeps the raster looking for nodata and filling this nodata with an average value from surrounding nodes. The sweeping changes directions, four sweep directions in all (+ rows, - rows, + cols, -cols) and it alternates between these directions until the raster is filled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_size</td><td>the number of pixles around the centre pixel to take the spatial average </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>09/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ab44ce1cb61d914e03738c608e543208f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::alternating_direction_nodata_fill_irregular_raster </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>window_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine that fills nodata holes. Modified by FJC to only fill holes surrounded in all directions by pixels with valid elevation values. </p>
<p>The routine sweeps the raster looking for nodata and filling this nodata with an average value from surrounding nodes. The sweeping changes directions, four sweep directions in all (+ rows, - rows, + cols, -cols) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_size</td><td>the number of pixles around the centre pixel to take the spatial average </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>09/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a4083c73f25904c819f4a6dc5e84f03e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::alternating_direction_nodata_fill_with_trimmer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>window_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine that fills nodata holes. It first prepares the data with the sprial trimmer so nodata around the edges is removed.  The routine sweeps the raster looking for nodata and filling this nodata with an average value from surrounding nodes. The sweeping changes directions, four sweep directions in all (+ rows, - rows, + cols, -cols) and it alternates between these directions until the raster is filled. The routine is particularly useful for data with holes that is to be prepared for spectral analysis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_size</td><td>the number of pixles around the centre pixel to take the spatial average </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>09/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="aa304348f61e9ca3726d50f3d437258e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::apply_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply a mask to a raster dataset, converts pixels to nodata where mas=k=1 </p>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25/08/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a54d26db29e36eb4d025f03d01a10577c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::BasinArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>Basins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the area(in spatial units) of each basin to the basin's pixels. </p>
<p>Big optimisation following the Drainage density's design pattern. Works by flattening the raster into a 1D vector, sorting it and summing each run of Basin IDs. Gives a fast count of the number of pixels per basin, which is multiplied by the cellsize to get an area in spatial units. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Basins</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of drainage basins to measure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of basin areas. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/11/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="ab4d6f6dc51982fb2a57fb8cda09d53b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::BasinAverager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Basins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Module assigns an average <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> value to each basin. </p>
<p>Works by searching for every hilltop value that falls within a basin, summing these values and writing the final average to every cell identified as the basin in question.</p>
<p>Very inefficent at present. Module loops through every cell in <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> (2 * number of basins) + 1 times. Beware! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Basins</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of Drainage basins, generated using ChannelNetwork::ExtractBasinsOrder. <br/>
<br/>
 Bug fixed in assignment of basin IDs - SWDG 2/9/13. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of average basin value for each identified basin. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="aca0215007ed0ee4132dc409687be0a89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt; LSDRaster::BasinPuncher </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>basin_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>BasinArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Punch basins out of an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to create DEMs of a single catchment. </p>
<p>Writes files in the user supplied format (flt or asc) and returns a vector of LSDRasters so they can be loaded into other functions. Updated 24/9/13 to return a vector of LSDRasters - SWDG. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basin_ids</td><td>Vector of basins to punch out. </td></tr>
    <tr><td class="paramname">BasinArray</td><td>Basin outlines used to punch out the LSDRasters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of output filenames. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/8/13 </dd></dl>

</div>
</div>
<a class="anchor" id="ab6ceb6c4b936bb1b7bc8120f1e34cc2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; float, float &gt; LSDRaster::Boomerang </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>D_inf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>RasterFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>log_bin_width</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SplineResolution</em> = <code>200</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bin_threshold</em> = <code>0.05</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate data in two text files to create a boomerang plot as in Roering et al [2007]. </p>
<p>Should now do all it needs to do: if it gets any more complex I'll look at refactoring it into a few methods. The latest addition is to take a bin_threshold to allow different sizes of bins to be removed from the final analysis - SWDG 11/11/13. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Slope</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of slope. </td></tr>
    <tr><td class="paramname">D_inf</td><td>D-infinity Flowarea <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. </td></tr>
    <tr><td class="paramname">RasterFilename</td><td>Filename used to give unique name to output data. </td></tr>
    <tr><td class="paramname">log_bin_width</td><td>Width (in log space) of the bins, with respect to D_inf. </td></tr>
    <tr><td class="paramname">SplineResolution</td><td>Number of values between each point for the spline curve. </td></tr>
    <tr><td class="paramname">bin_threshold</td><td>Threshold fraction of values needed to keep a bin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of floats containing the two LH values in the order LH(bins), LH(splines). </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/8/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a42a190d2415b9087054b44a1b577c3ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::border_with_nodata </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>irregular_switch</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to change border pixels to nodata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>border_width </td></tr>
    <tr><td class="paramname">int</td><td>irregular_switch (0 (default) -&gt; only creates border pixels around raster edge; 1 -&gt; creates border around edges and nodata values e.g. for irregularly shaped datasets) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/05/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a7071ad2969e75a43477e90fe50e9e544"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::BufferRasterData </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffers a raster using a circular kernel of a user-defined radius (m) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_radius</td><td>radius in metres </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/02/17 </dd></dl>

</div>
</div>
<a class="anchor" id="ae206ccc0de12e1b0dfa6ae1370337898"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::calculate_and_print_polyfit_and_roughness_rasters </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>roughness_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>file_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>file_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the combines the polyfit functions and the roughness function in one package. </p>
<p>The function is data efficient since one does not need to recalculate the polyfit coefficeint matrices. Itakes the window radius of the polyfit and the window of the roughness calculation the file codes in the vector are:<br/>
0 slope <br/>
1 aspect <br/>
2 curvature <br/>
3 planform curvature<br/>
4 profile curvature <br/>
6 tangential curvature <br/>
7 classification <br/>
8 roughness s1 <br/>
9 roughness s2 <br/>
10 roughness s3 <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_radius</td><td>Radius of the mask. </td></tr>
    <tr><td class="paramname">roughness_radius</td><td>Radius of the roughness window. </td></tr>
    <tr><td class="paramname">file_prefix</td><td>Output filename string. </td></tr>
    <tr><td class="paramname">file_list</td><td>Vector of files to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19-12-2012 </dd></dl>

</div>
</div>
<a class="anchor" id="aca50a43384109d85912fb825f1250c44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::calculate_and_print_polyfit_rasters </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>file_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>file_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function takes the polyfit functions and requires a window radius and a vector telling the function which rasters to print to file. </p>
<p>The function is data efficient since one does not need to recalculate the polyfit coefficeint matrices. It also takes a string which is the prename of the data files the file codes in the vector are:<br/>
0 slope <br/>
1 aspect <br/>
2 curvature <br/>
3 planform curvature<br/>
4 profile curvature <br/>
6 tangential curvature <br/>
7 classification <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_radius</td><td>Radius of the mask. </td></tr>
    <tr><td class="paramname">file_prefix</td><td>Output filename string. </td></tr>
    <tr><td class="paramname">file_list</td><td>Vector of files to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19-12-2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ad5caf033ba21aeec45e774595292be2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_factor_of_safety_at_saturation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>C_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rho_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>soil_thick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tan_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>SlopeAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This calculates the factor of safety if the soil is completely saturated. </p>
<p>Factor of safety &lt;1 == unstable </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C_r</td><td>root cohesion in N/m^2 </td></tr>
    <tr><td class="paramname">rho_s</td><td>soil density in kg/m^3 </td></tr>
    <tr><td class="paramname">soil_thick</td><td>soil thickness in m </td></tr>
    <tr><td class="paramname">tan_phi</td><td>the friction angle of the soil </td></tr>
    <tr><td class="paramname">SlopeAngle</td><td>the angle of the slope (you need to use the function calculate_slope_angles) to get this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Factor_of_safety The factor of safety when the soil is saturated rate required for saturation. The units will be the same as hydraulic conductivity but the lenght unit must be metres (to match contributing area) </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/11/14 </dd></dl>

</div>
</div>
<a class="anchor" id="ae417692b85ad0880acdf60af4e61ea22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::calculate_orientation_matrix_eigenvalues </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>s3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find eigenvalues for orientation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_radius</td><td></td></tr>
    <tr><td class="paramname">l</td><td>coefficeint l. </td></tr>
    <tr><td class="paramname">m</td><td>coefficeint m. </td></tr>
    <tr><td class="paramname">n</td><td>coefficeint n. </td></tr>
    <tr><td class="paramname">s1</td><td>coefficeint s1. </td></tr>
    <tr><td class="paramname">s2</td><td>coefficeint s2. </td></tr>
    <tr><td class="paramname">s3</td><td>coefficeint s3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/09/2012 </dd></dl>

</div>
</div>
<a class="anchor" id="aadfa6f1e75d776f505d3067816876f06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::calculate_plane_coefficient_matrices </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>c_plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is a wrapper to get the three roughness eigenvalues s1, s2 and s3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_radius</td><td></td></tr>
    <tr><td class="paramname">a_plane</td><td></td></tr>
    <tr><td class="paramname">b_plane</td><td></td></tr>
    <tr><td class="paramname">c_plane</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15/7/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a9c7b1dfb873b632a49c8aa755eb399db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_polyfit_aspect </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the aspect based on a polynomial fit. </p>
<p>the window is determined by the calculate_polyfit_coefficient_matrices this function also calculates the a,b,c,d,e and f coefficient matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>coefficeint d. </td></tr>
    <tr><td class="paramname">e</td><td>coefficeint e. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of aspect. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM, SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a50913916b5a16f90470d5bf7b14741b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::calculate_polyfit_classification </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function identifies approximate position of stationary points within discrete surface using a threshold slope. </p>
<p>The nature of the stationary point is then determined to discriminate peaks, depressions and saddles. <br/>
0 = Non-stationary <br/>
1 = Peak <br/>
2 = Depression <br/>
3 = Saddle <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>coefficeint a. </td></tr>
    <tr><td class="paramname">b</td><td>coefficeint b. </td></tr>
    <tr><td class="paramname">c</td><td>coefficeint c. </td></tr>
    <tr><td class="paramname">d</td><td>coefficeint d. </td></tr>
    <tr><td class="paramname">e</td><td>coefficeint e. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of classified elevation data. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/09/2012 </dd></dl>

</div>
</div>
<a class="anchor" id="a04fe83faa31eabe0ef3b5e5ca8333254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::calculate_polyfit_coefficient_matrices </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates 6 coefficient matrices that allow the user to then calcualte slope, curvature, aspect, a classification for finding saddles and peaks and other metrics. </p>
<p>The coefficient matrices are overwritten during the running of this member function.</p>
<p>Have N simultaneous linear equations, and N unknowns. =&gt; b = Ax, where x is a 1xN array containing the coefficients we need for surface fitting. A is constructed using different combinations of x and y, thus we only need to compute this once, since the window size does not change. For 2nd order surface fitting, there are 6 coefficients, therefore A is a 6x6 matrix. Updated 15/07/2013 to use a circular mask for surface fitting - DTM. Updated 24/07/2013 to check window_radius size and correct values below data resolution - SWDG. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_radius</td><td>Radius of the mask in <b>spatial units</b>. </td></tr>
    <tr><td class="paramname">a</td><td>coefficeint a. </td></tr>
    <tr><td class="paramname">b</td><td>coefficeint b. </td></tr>
    <tr><td class="paramname">c</td><td>coefficeint c. </td></tr>
    <tr><td class="paramname">d</td><td>coefficeint d. </td></tr>
    <tr><td class="paramname">e</td><td>coefficeint e. </td></tr>
    <tr><td class="paramname">f</td><td>coefficeint f. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DTM, SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a7b313feafa3a2e9ab790389976f522ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_polyfit_curvature </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the curvature based on a polynomial fit. </p>
<p>the window is determined by the calculate_polyfit_coefficient_matrices this function also calculates the a,b,c,d,e and f coefficient matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>coefficeint a. </td></tr>
    <tr><td class="paramname">b</td><td>coefficeint b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of curvature. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM, SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a0beaa7242443b3421ae97d5402752454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::calculate_polyfit_directional_cosines </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Algorithm that assesses surface roughness based on a polynomial fit. </p>
<p>Runs a moving window across the DEM and assesses the variability of surface normals within that window. Specifically the components of the normals are combined into an orientation matrix, which is then solved to find the eigenvalues s1, s2, s3 (Woodcock, 1977). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>coefficeint d. </td></tr>
    <tr><td class="paramname">e</td><td>coefficeint e. </td></tr>
    <tr><td class="paramname">l</td><td>coefficeint l. </td></tr>
    <tr><td class="paramname">m</td><td>coefficeint m. </td></tr>
    <tr><td class="paramname">n</td><td>coefficeint n. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/09/2012 </dd></dl>

</div>
</div>
<a class="anchor" id="ad6aa4aee4586df345a2cfcfe2adf6f9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_polyfit_elevation </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the elevation based on a polynomial fit. </p>
<p>the window is determined by the calculate_polyfit_coefficient_matrices this function also calculates the a,b,c,d,e and f coefficient matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>coefficeint f. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of elevations. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24/03/13 </dd></dl>

</div>
</div>
<a class="anchor" id="aeaf3bb49b83db88798647b8ceee85c94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_polyfit_planform_curvature </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the planform curvature based on a polynomial fit. </p>
<p>the window is determined by the calculate_polyfit_coefficient_matrices this function also calculates the a,b,c,d,e and f coefficient matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>coefficeint a. </td></tr>
    <tr><td class="paramname">b</td><td>coefficeint b. </td></tr>
    <tr><td class="paramname">c</td><td>coefficeint c. </td></tr>
    <tr><td class="paramname">d</td><td>coefficeint d. </td></tr>
    <tr><td class="paramname">e</td><td>coefficeint e. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of planform curvature. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM, SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/12 </dd></dl>

</div>
</div>
<a class="anchor" id="aa4da58e27375a3609942872e1dd45341"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_polyfit_profile_curvature </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the profile curvature based on a polynomial fit. </p>
<p>the window is determined by the calculate_polyfit_coefficient_matrices this function also calculates the a,b,c,d,e and f coefficient matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>coefficeint a. </td></tr>
    <tr><td class="paramname">b</td><td>coefficeint b. </td></tr>
    <tr><td class="paramname">c</td><td>coefficeint c. </td></tr>
    <tr><td class="paramname">d</td><td>coefficeint d. </td></tr>
    <tr><td class="paramname">e</td><td>coefficeint e. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of profile curvature. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM, SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/12 </dd></dl>

</div>
</div>
<a class="anchor" id="aeb085209c3dc12eb6b59ed0dc58e4ba3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt; LSDRaster::calculate_polyfit_roughness_metrics </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>raster_selection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Surface polynomial fitting and extraction of roughness metrics. </p>
<p>A six term polynomial surface is fitted to all the points that lie within circular neighbourhood that is defined by the designated window radius. This surface is used to determine the orientation of the surface normal vector at each cell. The algorithm then searches through the grid again, using a second search window to look for the local variability in normal vector orientation. The user also inputs a binary raster, which tells the program which rasters it wants to create (label as "1" to produce them, "0" to ignore them. This has 3 elements, as listed below: 0 -&gt; s1 -&gt; describes clustering of normals around the major axis 1 -&gt; s2 -&gt; describes clustering of normals around semi major axis 2 -&gt; s3 -&gt; describes clustering around minor axis The program returns a vector of LSDRasters. For options marked "0" in binary input raster, the returned <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> houses a blank raster, as this metric has not been calculated. The desired <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> can be retrieved from the output vector by using the same cell reference shown in the list above i.e. it is the same as the reference in the input binary vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_radius1</td><td>-&gt; the radius of the circular window over which to fit the surface </td></tr>
    <tr><td class="paramname">window_radius2</td><td>-&gt; the radius of the circular window over which to look for local variability of surface normal orientation </td></tr>
    <tr><td class="paramname">raster_selection</td><td>-&gt; a binary raster, with 3 elements, which identifies which metrics you want to calculate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> objects. Those that you have not asked to be calculated are returned as a 1x1 Raster housing a NoDataValue</dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a9ae2eadcadcd924ebb7e4e4eeac3cd7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_polyfit_slope </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the slope based on a polynomial fit. </p>
<p>the window is determined by the calculate_polyfit_coefficient_matrices this function also calculates the a,b,c,d,e and f coefficient matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>coefficeint d. </td></tr>
    <tr><td class="paramname">e</td><td>coefficeint e. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of slope. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM, SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/12 </dd></dl>

</div>
</div>
<a class="anchor" id="aefb6f3aa7b196ade7283dc77ae52640a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt; LSDRaster::calculate_polyfit_surface_metrics </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>raster_selection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Surface polynomial fitting and extraction of topographic metrics. </p>
<p>A six term polynomial surface is fitted to all the points that lie within circular neighbourhood that is defined by the designated window radius. The user also inputs a binary raster, which tells the program which rasters it wants to create (label as "1" to produce them, "0" to ignore them. This has 8 elements, as listed below: 0 -&gt; Elevation (smoothed by surface fitting) 1 -&gt; Slope 2 -&gt; Aspect 3 -&gt; Curvature 4 -&gt; Planform Curvature 5 -&gt; Profile Curvature 6 -&gt; Tangential Curvature 7 -&gt; Stationary point classification (1=peak, 2=depression, 3=saddle) The program returns a vector of LSDRasters. For options marked "false" in boolean input raster, the returned <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> houses a blank raster, as this metric has not been calculated. The desired <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> can be retrieved from the output vector by using the cell reference shown in the list above i.e. it is the same as the reference in the input boolean vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_radius</td><td>-&gt; the radius of the circular window over which to fit the surface </td></tr>
    <tr><td class="paramname">raster_selection</td><td>-&gt; a binary raster, with 8 elements, which identifies which metrics you want to calculate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> objects. Those that you have not asked to be calculated are returned as a 1x1 Raster housing a NoDataValue</dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>28/03/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a277eed7fed092e06fc22d05bebb24aaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt; LSDRaster::calculate_polyfit_surface_metrics_directional_gradients </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>raster_selection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Surface polynomial fitting and extraction of topographic metrics. Same as above function but in this case one can opt for directional gradients. Added as another function to ensure legacy code is not broken.  A six term polynomial surface is fitted to all the points that lie within circular neighbourhood that is defined by the designated window radius. The user also inputs a binary raster, which tells the program which rasters it wants to create (label as "1" to produce them, "0" to ignore them. This has 8 elements, as listed below: 0 -&gt; Elevation (smoothed by surface fitting) 1 -&gt; Slope 2 -&gt; Aspect 3 -&gt; Curvature 4 -&gt; Planform Curvature 5 -&gt; Profile Curvature 6 -&gt; Tangential Curvature 7 -&gt; Stationary point classification (1=peak, 2=depression, 3=saddle) 8 -&gt; Directional gradients (dz/dx and dz,dy) The program returns a vector of LSDRasters. For options marked "false" in boolean input raster, the returned <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> houses a blank raster, as this metric has not been calculated. The desired <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> can be retrieved from the output vector by using the cell reference shown in the list above i.e. it is the same as the reference in the input boolean vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_radius</td><td>-&gt; the radius of the circular window over which to fit the surface </td></tr>
    <tr><td class="paramname">raster_selection</td><td>-&gt; a binary raster, with 8 elements, which identifies which metrics you want to calculate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> objects. Those that you have not asked to be calculated are returned as a 1x1 Raster housing a NoDataValue</dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/06/2018 </dd></dl>

</div>
</div>
<a class="anchor" id="aea5b09464e02fac88cf06563b4c16eb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_polyfit_tangential_curvature </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the tangential curvature based on a polynomial fit. </p>
<p>the window is determined by the calculate_polyfit_coefficient_matrices this function also calculates the a,b,c,d,e and f coefficient matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>coefficeint a. </td></tr>
    <tr><td class="paramname">b</td><td>coefficeint b. </td></tr>
    <tr><td class="paramname">c</td><td>coefficeint c. </td></tr>
    <tr><td class="paramname">d</td><td>coefficeint d. </td></tr>
    <tr><td class="paramname">e</td><td>coefficeint e. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of tangential curvature. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM, SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a17a6dd434f0c62f00f0657cf79c7a4ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_REI </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>CriticalSlope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the REI raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_plane</td><td></td></tr>
    <tr><td class="paramname">b_plane</td><td></td></tr>
    <tr><td class="paramname">CriticalSlope</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of rock exposure. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>

</div>
</div>
<a class="anchor" id="abf94a0a1d208e3916b6c9fbd90c8c2fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_REI </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>CriticalSlope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the REI raster (imporoved wrapper) Rock exposure index defined as areas with local slope exceeding some critical slope as defined by DiBiase et al. (2012) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>radius </td></tr>
    <tr><td class="paramname">CriticalSlope</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of rock exposure. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>

</div>
</div>
<a class="anchor" id="ae10deff45b25c7dfb065df33d057be3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_relief </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kernelWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kernelType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a relief raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>width in metres of the kernal you wnat to use for resolution </td></tr>
    <tr><td class="paramname">if</td><td>this ==1 then you use a circular kernal. Otherwise kernal is square </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The spatially distributed relief </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ (entered into trunk SMM) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>6/06/2014 Happy 3rd Birthday Skye!!! </dd></dl>

</div>
</div>
<a class="anchor" id="ad0ec635af20e1808fdd245d4f61d2fd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::calculate_roughness_rasters </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>roughness_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>file_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>file_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the combines the roughness functions in one package. </p>
<p>The function is data efficient since one does not need to recalculate the polyfit coefficeint matrices. I takes the window radius of the polyfit and the window of the roughness calculation the file codes in the vector are:<br/>
0 roughness s1 <br/>
1 roughness s2 <br/>
2 roughness s3 <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_radius</td><td>Radius of the mask. </td></tr>
    <tr><td class="paramname">roughness_radius</td><td>Radius of the roughness window. </td></tr>
    <tr><td class="paramname">file_prefix</td><td>Output filename string. </td></tr>
    <tr><td class="paramname">file_code</td><td>Vector of files to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15-07-2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a398ed8c6898a690f851f49bef41e18f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_slope_angles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates slope angle in radians. Needs the slope raster. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> containing the slope angle in radians. For use in trigonometric calculations </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/11/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a3948a815d7a5634834a42a9ae7e5cd58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_topographic_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>AccumulationArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Slope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the topographic index, a moisture distribution indicator. </p>
<p>Calculates the topographic index, defined as ln(A/S) (Kirkby, 1975), where A is the accumulation area and S is the slope. This is an indicator of the distribution of moisture within the topography. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a></td><td>of Accumulations Area, calculated ideally with D-inf </td></tr>
    <tr><td class="paramname"><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a></td><td>of Slope </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of Topographic Index </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a129887343a9122cb5b3fd65a3854e850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::calculate_water_supply_rate_for_saturation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>soil_thick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ContributingArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>SlopeAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the water supply rate required for saturation of the hillslope soil. </p>
<p>Water supply rate is the precipitation rate minus recharge and ET </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soil_thick</td><td>soil thickness in m </td></tr>
    <tr><td class="paramname">K</td><td>hydraulic conductivity in m/ (some time unit) </td></tr>
    <tr><td class="paramname">ConstributingArea</td><td>the contributing area raster, should be in m^2 </td></tr>
    <tr><td class="paramname">SlopeAngle</td><td>the angle of the slope (you need to use the function calculate_slope_angles) to get this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Water_supply_rate_for_saturation a raster holding the water supply rate required for saturation. The units will be the same as hydraulic conductivity but the lenght unit must be metres (to match contributing area) </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/11/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a79d1f8c8b202df072becb69100d93839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRaster::CalculateAdaptiveCurvatureThresholdSD </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>half_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the curvature threshold used for DrEICH channel extraction which varies across the landscape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">half_width</td><td>radius over which to calculate the curvature threshold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array2D&lt;float&gt; array with curvature threshold for each row and col </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/07/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a2bbcd3609a0d99e74900435020af4d88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::CastShadows </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Azimuth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ZenithAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to determine areas of a DEM that are in shadow from a given radiation source defined by an Azimuth and Zenith following Codilean (2006). </p>
<p>Performs a coordinate transformation, rotating the x,y,z coordinates about the Azimuth and Zenith such that the coordinates are aligned with the Azimuth and Zenith. Shaded cells are then found by tracking in the direction of the radiation source and looking for transformed z values greater than that at the cell of interest which would therefore cast a shadow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Azimuth</td><td>of the illumination source in degrees. </td></tr>
    <tr><td class="paramname">ZenithAngle</td><td>of the illumination source in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hillshaded <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>MDH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a87bf04f5047c82d16cc0bd0c1a8e04ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string LSDRaster::ChannelLengthByOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>StreamNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; int &gt;&#160;</td>
          <td class="paramname"><em>FlowDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the lengths in spatial units of each part of the channel network, divided by strahler order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StreamNetwork</td><td>Raster of the stream network coded by strahler order. </td></tr>
    <tr><td class="paramname">FlowDir</td><td>Array of flowdirections from FlowInfo (Not D-inf). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/1/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a972d9ed0805f6a9fe83e313c32ad656a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LSDRaster::check_if_point_is_in_raster </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>X_coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Y_coordinate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this check to see if a point is within the raster </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X_coordinate</td><td>the x location of the point </td></tr>
    <tr><td class="paramname">Y_coordinate</td><td>the y location of the point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is_in_raster a boolean telling if the point is in the raster </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/11/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a72361701912660a064734779ef60954b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::check_isolated_nodata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This looks for isolated instances of no data. </p>
<p>Does nothing else but print their location to the screen. </p>
<dl class="section author"><dt>Author</dt><dd>MDH, DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a41cb08ebbbaf25149d14552164671ce4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::clip_to_smaller_raster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>smaller_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a clipped raster that has the same dimensions as the smaller raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">smaller_raster</td><td>the raster to which the bigger raster should be clipped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/03/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a84ed4e5c0efe368c2a3c9708a71fd6f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::clip_to_smaller_raster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>smaller_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a clipped raster that has the same dimensions as the smaller raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">smaller_raster</td><td>the raster to which the bigger raster should be clipped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/03/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a879a99a63a916a31a2c8eb868733eccd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::CollectBasinMetrics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Basins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DrainageDensity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Cht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>HillslopeLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>MeanSlope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Relief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>MeanAspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>LH_drainage_density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>LH_Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>CriticalSlope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>RasterFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect all basin average metrics into a single file. </p>
<p>File is written with the format: <br/>
<br/>
"basin_id slope elevation aspect area drainage_density hilltop_curvature
hillslope_length mean_slope hilltop_relief hilltop_aspect E* R* LH_bins LH_splines LH_density" </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Basins</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of drainage basins to sample. </td></tr>
    <tr><td class="paramname">Slope</td><td></td></tr>
    <tr><td class="paramname">Elevation</td><td></td></tr>
    <tr><td class="paramname">Aspect</td><td></td></tr>
    <tr><td class="paramname">Area</td><td></td></tr>
    <tr><td class="paramname">DrainageDensity</td><td></td></tr>
    <tr><td class="paramname">Cht</td><td></td></tr>
    <tr><td class="paramname">HillslopeLength</td><td></td></tr>
    <tr><td class="paramname">MeanSlope</td><td></td></tr>
    <tr><td class="paramname">Relief</td><td></td></tr>
    <tr><td class="paramname">MeanAspect</td><td></td></tr>
    <tr><td class="paramname">LH_drainage_density</td><td>Hillslope length for each basin calculated as in Tucker et al 2001 - Added 6/11/13 SWDG. </td></tr>
    <tr><td class="paramname">LH_Data</td><td>Array of LH data generated from the Boomerang plotting function and compiled using the BasinMetrics Driver - Added 1/11/13 SWDG. </td></tr>
    <tr><td class="paramname">CriticalSlope</td><td>Threshold value for E* and R* values. </td></tr>
    <tr><td class="paramname">RasterFilename</td><td>Filename of the input raster data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/8/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a801154ac96833085a14a0a16814781f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::convert_from_centimetres_to_metres </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to convert elevations from centimetres to metres </p>
<dl class="section return"><dt>Returns</dt><dd>raster of elevations in metres </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/10/17 </dd></dl>

</div>
</div>
<a class="anchor" id="aeb88fa7304a7a05928250352230ef123"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::convert_from_feet_to_metres </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to convert feet to metres using US international feet, where 1 foot = 0.3048006096012192 metres. </p>
<dl class="section return"><dt>Returns</dt><dd>raster of elevations in metres </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/10/17 </dd></dl>

</div>
</div>
<a class="anchor" id="abcc4d506a8dd46bd2f23fc1a3ce354fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::ConvertToBinary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to convert all values in an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to a single value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value,an</td><td>integer value that will be assigned to every non NDV cell in the raster. </td></tr>
    <tr><td class="paramname">ndv</td><td>an integer no data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24/07/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ae2ab990fdcde1aa7d4c2cfcfa3124ad8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::CookieCutRaster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Cutter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cookie cut a raster using a smaller raster. </p>
<p>Requires that both rasters share a spatial extent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cutter</td><td>an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to be used as the template. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of the data cut to the other ratser's shape. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>06/07/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a4900b2a06bf880a98ed09c12d394c392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::create_binary_isdata_raster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns an index raster with 1 for data and 0 for nodata. </p>
<dl class="section return"><dt>Returns</dt><dd>index raster 1 == data, 0 == nodata </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/03/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a0766768246987cca6e55f0849107778b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; int &gt; LSDRaster::create_mask </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>neighbourhood_switch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a circular mask for neighbourhood statistics </p>
<p>The second argument (neighbourhood_switch) specifies the neighbourhood type: 0 Square neighbourhood 1 Circular window </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>radius of mask </td></tr>
    <tr><td class="paramname">int</td><td>neighbourhood_switch -&gt; see above </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a binary array with the mask </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="acdcb6e797d48233ac7fa06ff64c41409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::Create_Mask </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>Condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>TestValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to create a masked <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> raster based on a conditional statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>Condition ("&lt;", "&gt;", "==", "!=") </td></tr>
    <tr><td class="paramname">float</td><td>TestValue The value that the condition is tested against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the mask </dd></dl>
<dl class="section author"><dt>Author</dt><dd>MDH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/08/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a2063e4b0055740837635911886f27e62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::create_raster_nodata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a raster in of the same number of rows and cols with nodata. </p>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>07/04/17 </dd></dl>

</div>
</div>
<a class="anchor" id="ac1d2ee698cc2b672ea70dcff2564b93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::CreateHilltopPatches </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_patch_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to convert an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> hilltop file into a series of contigiuous hilltop patches. </p>
<p>Connects all contiguous patches of hilltop via a unique ID, allowing hilltop patches to be generated in a manner similar to the methodology employed by Hurst et al. (2012) and (2013) to spatially average data for E*R* calculations. Currently has no method to limit the maximum size of segments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimum_patch_size</td><td>Integer of the minimum number of pixels required for a patch to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of hilltop patches. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>5/6/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a331723d71e095e496a4467578e26dafb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::D_inf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper Function to create a D-infinity flow area raster with one function call. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of D-inf flow areas in pixels. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/07/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a2fe51c2dd1980080101ce669301d426f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::D_inf_ConvertFlowToArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper Function to convert a D-infinity flow raster into spatial units. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of D-inf flow areas in spatial units. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>MDH (after SWDG) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>5/9/14 </dd></dl>

</div>
</div>
<a class="anchor" id="ae8b70073ef6f1a23ae832c98c2e087ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::D_inf_FlowArea </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>FlowDir_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function for generating a D-infinity flow area raster after Tarboton (1997). </p>
<p>Calls the recurisve D_infAccum function to get flow area for each pixel. Returns flow area in pixels.</p>
<p>Code is ported and optimised from a Java implementation of the algorithm supplied under the GNU GPL licence through WhiteBox GAT: <a href="http://www.uoguelph.ca/~hydrogeo/Whitebox/">http://www.uoguelph.ca/~hydrogeo/Whitebox/</a> and provides identical results to the whitebox tool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowDir_array</td><td>Array of Flowdirections generated by <a class="el" href="class_l_s_d_raster.html#a23ed6f1737d703a6e2db5fa385e59dfd" title="D-infinity flow direction algorithm after Tarboton (1997). ">D_inf_FlowDir()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of D-inf flow areas in pixels. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/07/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a23ed6f1737d703a6e2db5fa385e59dfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRaster::D_inf_FlowDir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>D-infinity flow direction algorithm after Tarboton (1997). </p>
<p>Algorithm takes a filled DEM and for each cell calculates the steepest descent based on 8 triangular facets. Flow direction is assigned as an angle from 0-360 degrees with -1 used to flag unresolved areas such as pits.</p>
<p>Code is ported and optimised from a Java implementation of the algorithm supplied under the GNU GPL licence through WhiteBox GAT: <a href="http://www.uoguelph.ca/~hydrogeo/Whitebox/">http://www.uoguelph.ca/~hydrogeo/Whitebox/</a> and provides identical results to the whitebox tool. </p>
<dl class="section return"><dt>Returns</dt><dd>Array of Flow directions in degrees. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/07/13 </dd></dl>

</div>
</div>
<a class="anchor" id="adddb73dd9d50df2c09422da36bfad0f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::D_inf_units </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper Function to create a D-infinity flow area raster, in spatial units, with one function call. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of D-inf flow areas in spatial units. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/10/13 </dd></dl>

</div>
</div>
<a class="anchor" id="ac3d61141306c7b413b7f2528836ceeb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::D_inf_watershed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>D_inf_FlowDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>PourRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>PourCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to generate upslope contributing area extent from the D-infinity flow directions to an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dinflow</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of Flowdirections generated by <a class="el" href="class_l_s_d_raster.html#a23ed6f1737d703a6e2db5fa385e59dfd" title="D-infinity flow direction algorithm after Tarboton (1997). ">D_inf_FlowDir()</a>. </td></tr>
    <tr><td class="paramname">i</td><td>and j indices of pour point node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of catchment </dd></dl>
<dl class="section author"><dt>Author</dt><dd>MDH (after SWDG) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/08/14 </dd></dl>

</div>
</div>
<a class="anchor" id="ab8177cf5be3dd00700a04f72722676cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::D_infAccum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>CountGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>Flowarea_Raster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>FlowDir_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive function to calculate accumulating area for a given pixel. </p>
<p>Called by the driver for every cell which has no contributing cells - eg the highest points on the landscape. Avoids the need to flatten and sort the DEM as required in the original Tarboton (1997) implementation. For more detail on the recursive algorithm following channels see Mark (1998) "Network Models in Geomorphology".</p>
<p>Code is ported and optimised from a Java implementation of the algorithm supplied under the GNU GPL licence through WhiteBox GAT: <a href="http://www.uoguelph.ca/~hydrogeo/Whitebox/">http://www.uoguelph.ca/~hydrogeo/Whitebox/</a> and provides identical results to the whitebox tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Row index of the target cell. </td></tr>
    <tr><td class="paramname">j</td><td>Column index of the target cell. </td></tr>
    <tr><td class="paramname">CountGrid</td><td>Array showing the number of cells flowing into each cell. </td></tr>
    <tr><td class="paramname">Flowarea_Raster</td><td>Array of the flow areas which is populated using this function. </td></tr>
    <tr><td class="paramname">FlowDir_array</td><td>Array of Flowdirections generated by <a class="el" href="class_l_s_d_raster.html#a23ed6f1737d703a6e2db5fa385e59dfd" title="D-infinity flow direction algorithm after Tarboton (1997). ">D_inf_FlowDir()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/07/13 </dd></dl>

</div>
</div>
<a class="anchor" id="ac49cd0617a2eaccc60e03cededbd79ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::DiamondSquare </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>feature_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the driving function for the diamond square algorithm. </p>
<p>The driving function takes the current raster and then pads it in each direction to have rows and columns that are the nearest powers of 2. The xllocation and yllocation data values are preserved. The function returns a pseudo fractal landscape generated with the diamond square algorithm Believe it or not this algorithm is absed on code poseted by Notch, the creator of Minecraft, who then had it modified by Charles Randall <a href="https://www.bluh.org/code-the-diamond-square-algorithm/">https://www.bluh.org/code-the-diamond-square-algorithm/</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature</td><td>order is an interger n where the feature size consists of 2^n nodes. If the feature order is set bigger than the dimensions of the parent raster then this will default to the order of the parent raster. </td></tr>
    <tr><td class="paramname">Scale</td><td>is a floating point number that sets the maximum relief of the resultant raster. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a diamond square pseudo-fractal surface in and <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/02/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a86dca3c985ce96fa98df6b1f5e325f3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::DiamondSquare_SampleStep </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stepsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the sampling function for the diamond square algorithm: it runs both a diamond and a square sampling for each step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>stepsize, which is the size of the diamonds and the squares. </td></tr>
    <tr><td class="paramname">The</td><td>scale which sets the maxmum relief within a particular square or diamond and is scaled by the stepsize (that is smaller squares have smaller scales).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/02/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a3cf499bc742ba424266af5e0917440cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::difference_rasters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>compare_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the mean difference between two rasters. </p>
<p>checks raster dimensions but not georeferencing since it is used to compare asc format model results </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/05/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a00583bd08c65fa2f2b997b1ab7844c7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LSDRaster::does_raster_have_same_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Compare_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if two rasters have the same dimensions  Does NOT check georeferencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Compare_raster</td><td>the raster to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/05/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a272891c6cf512ff95f489f06ef7cc042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LSDRaster::does_raster_have_same_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Compare_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if two rasters have the same dimensions  Does NOT check georeferencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Compare_raster</td><td>the raster to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/05/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a31e5df5e08ad139f8b3abba7eae414b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LSDRaster::does_raster_have_same_dimensions_and_georeferencing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Compare_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if two rasters have the same georeferencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Compare_raster</td><td>the raster to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>02/03/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a2f34429a41eefb8397fb5a7257b7f737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LSDRaster::does_raster_have_same_dimensions_and_georeferencing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Compare_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if two rasters have the same georeferencing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Compare_raster</td><td>the raster to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>02/03/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="acb6d3568dc1191e7b69b6606602ac515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::DrainageDensity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>StreamNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Basins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; int &gt;&#160;</td>
          <td class="paramname"><em>FlowDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate drainage density of a set of input basins. </p>
<p>Calculated as flow length/basin area and written to every cell of the identified basin. Completely rewritten to optimise performance. Now only traverses the DEM 3 times regardless of the number of input basins, previously traversed the DEM (2*No of Basins + 2) times. <br/>
<br/>
Works by creating a pair of vectors of basin IDs and stream length for each pixel which are then sorted by basin ID and summed in order to calculate DD in a single pass over the DEM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StreamNetwork</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the stream network. </td></tr>
    <tr><td class="paramname">Basins</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the basins to be analysed. </td></tr>
    <tr><td class="paramname">FlowDir</td><td>Array2D of flowdirections generated by FlowInfo.get_FlowDirection(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of basins coded with drainage density. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19/11/13 </dd></dl>

</div>
</div>
<a class="anchor" id="ac5e384d147a6a22b929020f97b0f16f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::DSSampleDiamond </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the diamond sampling step of the diamond square algorithm: it takes the average of the four corners and adds a random number to set the centrepoint of a diamond. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>row of the centrepoint. </td></tr>
    <tr><td class="paramname">The</td><td>column of the centrepoint. </td></tr>
    <tr><td class="paramname">The</td><td>size of this diamond (in pixels, must be divisible by 2). </td></tr>
    <tr><td class="paramname">The</td><td>random value added to the average of teh four corners. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/02/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a2e0aff5f6e1cdb4a1801419e5e63e9d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::DSSampleSquare </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the square sampling step of the diamond square algorithm: it takes the average of the four corners and adds a random number to set the centrepoint of a square. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>row of the centrepoint. </td></tr>
    <tr><td class="paramname">The</td><td>column of the centrepoint. </td></tr>
    <tr><td class="paramname">The</td><td>size of this square (in pixels, must be divisible by 2). </td></tr>
    <tr><td class="paramname">The</td><td>random value added to the average of the four corners. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/02/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a8665f8057d8050cb61ccc1404c6f80c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::DSSetFeatureCorners </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>featuresize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This sets the corners of features as the first step in the diamond square algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>first parameter is the feature size. This needs to be a power of 2, but this is set by the parent DiamondSquare function (that is, this function should not be called independantly. </td></tr>
    <tr><td class="paramname">The</td><td>scale is effectivly the maximum relief of the surface to be produced by the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/02/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a869906150040117268fdad50b81402b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::ExtractByMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>Mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to extract an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> based on a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a></td><td>TheMask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>masked <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>MDH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/08/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="aef40878b1deabc0c81c79a9675eb1890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::fill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fills pits/sinks in a DEM by incrementing elevations for cells with no downslope neighbour. The process is repeated adnausium until no cells require incrementing. </p>
<p>Inputs required are a DEM file in ascii raster format as created by ARCMap and a file name to create a filled DEM grid.</p>
<p>This code was built ontop of code made available by Jon D. Pelletier as part of his book:</p>
<p>Pelletier,J.D.,'Quantitative Modelling of Landscapes' Cambridge University Press </p>
<hr/>
<p>v1.3 reduced fill increment to 1mm to avoid 'overfilling'</p>
<p>Martin Hurst, October 2011 </p>
<hr/>
<p>v1.2 modified to read *.flt files</p>
<p>Martin Hurst, November 2010 </p>
<hr/>
<p>v1.1 function incorporated to allow the tool to fill adjacent pixels immediately after filling a given pixel, should speed things up.</p>
<p>Martin Hurst, October 2010 </p>
<hr/>
<p>v1.0 is slow as it requires many iterations through the dem</p>
<p>Martin Hurst, June 2010 </p>
<dl class="section return"><dt>Returns</dt><dd>Filled <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>MDH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/06/10 </dd></dl>

</div>
</div>
<a class="anchor" id="ac8464ee1d76a8b6b4de78e828400e727"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::fill </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>MinSlope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function fills pits/sinks in a DEM by checking for pits from lowest to highest elevation, starting at the DEM boundary (raster edge or adjacent to NDVs). </p>
<p>Utilises a priority queue to progressively populate the stack and pop out the the lowest value before checking that the neighbouring cells that are yet to be visited must be higher in a hydrologically correct DEM. This method is substantially faster on datasets with pits consisting of multiple cells since each cell only needs to be visited once.</p>
<p>Method taken from Wang and Liu (2006), Int. J. of GIS. 20(2), 193-213 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MinSlope</td><td>The minimum slope between two Nodes once filled. If set to zero will create flats. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filled <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Martin Hurst </dd></dl>
<dl class="section date"><dt>Date</dt><dd>12/3/13 </dd></dl>

</div>
</div>
<a class="anchor" id="ab29cb6b8a0ceeeaa361b94197e0e0f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::fill_iterator </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>fill_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a recursive algorithm that is called by the fill function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fill_data</td><td></td></tr>
    <tr><td class="paramname">i</td><td></td></tr>
    <tr><td class="paramname">j</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>MDH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/06/10 </dd></dl>

</div>
</div>
<a class="anchor" id="abad40fa659801ff5624d2d449c242fdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::fill_with_interpolated_data </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>rows_of_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>cols_of_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>interpolated_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This fills a raster with precalculated interpolated data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows_of_nodes</td><td>the rows of the interpolated points </td></tr>
    <tr><td class="paramname">cols_of_nodes</td><td>the colss of the interpolated points </td></tr>
    <tr><td class="paramname">interpolated</td><td>data the actual data that has been interpolated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/02/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="af48280de81ceb10c1b509676e632a2cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::find_cells_bordered_by_nodata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a mask that has the value of 1 for cells that are either on the edge or bordered by nodata (from their 9 neighbors) </p>
<dl class="section return"><dt>Returns</dt><dd>and <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with the mask </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/10/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a89fe2d220b79452468d401aacafdcf77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDRaster::Find_UTM_central_meridian </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>UTM_zone</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method looks up the central meridian given a UTM zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UTM_zone</td><td>the UTM zone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>central_meridian an integer of the central meridian of this UTM zone </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>6/11/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a1891ab358d51150fd78960d37ddd19ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::FlattenToCSV </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>FileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to flatten an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> and place the non NDV values in a csv file. </p>
<p>Each value is placed on its own line, so that it can be read more quickly in python etc. It includes the x and y locations so it can be read by GIS software </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName_prefix</td><td>The prefix of the file to write, if no path is included it will write to the current directory. The csv extension is added automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/6/15 </dd></dl>

</div>
</div>
<a class="anchor" id="abdbd534a153549a070747668ee82b5e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::FlattenToFile </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>FileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple method to flatten an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to a text file, with a sigle value on each line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName</td><td>The name of the file to write, if no path is included it will write to the current directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>9/2/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a04779a5d0361d814ca82c0e65678cba7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::FlattenToWGS84CSV </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>FileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to flatten an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> and place the non NDV values in a csv file. </p>
<p>Each value is placed on its own line, so that it can be read more quickly in python etc. It includes the lat long coordinates in CSV </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName_prefix</td><td>The prefix of the file to write, if no path is included it will write to the current directory. The csv extension is added automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>12/11/16 </dd></dl>

</div>
</div>
<a class="anchor" id="ad8fa0ff6fdbb7700d35d594c24d39cc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::FMDChannelsFromChannelHeads </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>channel_heads_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>channel_heads_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>R_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a multi-pixel channel network, as opposed to a single thread channel, using method outlined in Pelletier, 2013, WRR; A robust, two-parameter method for the extraction of drainage networks from high-resolution digital elevation models (DEMs): Evaluation using synthetic and real-world DEMs. </p>
<p>First runs Freeman MD flow routing algorithm from previously identified source. Then removes all pixels from the channel network if the ratio of discharge to upstream channel heads is below a user-specified threshold </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector&lt;int&gt;</td><td>channel_heads_rows - a vector of source node row indices </td></tr>
    <tr><td class="paramname">vector&lt;int&gt;</td><td>channel_heads_cols - a vector of source node column indices </td></tr>
    <tr><td class="paramname">float</td><td>R_threshold - the threshold ratio of discharge:upstream channel heads; Pelletier (2013) reccomends a value of 0.1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/05/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a167eac046b8207dc711962847f737ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::FreemanMDFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a flow area raster using a multi direction algorithm. </p>
<p>Computes the proportion of all downslope flows for each cell in the input DEM, and weights them using the equation from Freeman et al 1991 and routes the flow accordingly.</p>
<p>Paper link: <a href="http://www.sciencedirect.com/science/article/pii/009830049190048I">http://www.sciencedirect.com/science/article/pii/009830049190048I</a></p>
<p>Cardinal Weighting = (elevation_drop/total_elevation_drop)^1.1 <br/>
Diagonal Weighting = ((elevation_drop/total_elevation_drop)*(1/root(2)))^1.1</p>
<p>Can <b>NOT</b> handle DEMs containing flats or pits - must be filled using the new <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> fill. Function built around original c++ code by Martin Hurst. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of flow area. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/4/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a496d804e34d7ec4c030d6eea2ae90cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::FreemanMDFlow_SingleSource </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Route flow from one source pixel using FreemanMDFlow. Adapted from SWDG's code above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>-&gt; the row index of the source pixel </td></tr>
    <tr><td class="paramname">j_source</td><td>-&gt; the column index of the source pixel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>07/11/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="aa6136e17477083dcb28e0c60fdf14038"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::GaussianFilter </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters the raster using a square 2D Gaussian filter. The filter is applied using a moving kernel of gaussian weights with a radius of 3*sigma. </p>
<p>Equivalent lenghtscale of smoothing (from Lashermes et al., 2007) original data -&gt; 4*sigma 1st derivative -&gt; 2*pi*sigma 2nd derivative -&gt; sqrt(2)*pi*sigma </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigma</td><td></td></tr>
    <tr><td class="paramname">kr</td><td>(an optional integer halfwidth for the smoothing window. If not supplied then the window is set to cover at least three*sigma) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a filtered raster </dd></dl>
<dl class="section author"><dt>Author</dt><dd>David Milodowski </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aaaa8d06ed84b1dab76bb414634699b07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TNT::Array2D&lt;double&gt; LSDRaster::get_ascii_raster </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>FILENAME</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a raster from an ascii file for use in <a class="el" href="class_l_s_d_catchment_model.html" title="This object is used to model the hydrology, sediment transport and evolution of individual basins...">LSDCatchmentModel</a>. </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>You can't return a TNT::Array properly in a function. See google for details. <dl class="section author"><dt>Author</dt><dd>DAV </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 2D Array of the raster file. </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0e9f3397df5b3cf89ec8b4d31b4aa522"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::get_data_element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the raster data at a specified location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>An integer, the X coordinate of the target cell. </td></tr>
    <tr><td class="paramname">column</td><td>An integer, the Y coordinate of the target cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The raster value at the position (row, column). </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a468965d3781bd8ea55365eaf77fc9e3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::get_DataResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Data resolution as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a75a65dc8420e194476046570ee04e802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::get_drainage_density_of_raster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>StreamNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; int &gt;&#160;</td>
          <td class="paramname"><em>FlowDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate drainage density of a DEM. </p>
<p>Calculated as flow length/raster area </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StreamNetwork</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the stream network. </td></tr>
    <tr><td class="paramname">FlowDir</td><td>Array2D of flowdirections generated by FlowInfo.get_FlowDirection(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float with drainage density of raster </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/03/15 </dd></dl>

</div>
</div>
<a class="anchor" id="acc6f687663706b020002604533a08379"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::get_easting_and_northing_vectors </td>
          <td>(</td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>Eastings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>Northings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns vectors of all the easting and northing points in the raster Used for interpolations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Eastings</td><td>a vector of easting coordinates. Will be replaced by method. </td></tr>
    <tr><td class="paramname">Northings</td><td>a vector of northing coordinates. Will be replaced by method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/03/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a938ce9854d96267267f06694ef84de3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string,string&gt; LSDRaster::get_GeoReferencingStrings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>map containing the georeferencing strings </dd></dl>

</div>
</div>
<a class="anchor" id="ad17fbce489da7ed4f49cab22f993cb0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::get_hilltop_curvature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Hilltops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the hilltop curvature raster. </p>
<p>Modified to take an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of hilltops - SWDG 29/8/13 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curvature</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of curvatures. </td></tr>
    <tr><td class="paramname">Hilltops</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of hilltops. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of hilltop curvatures. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>30/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="ad904ac3a113434319b9eec0857479343"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::get_lat_and_long_locations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>longitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a>&#160;</td>
          <td class="paramname"><em>Converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function to get the lat and long of a node in the raster  Assumes WGS84 ellipsiod </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the node </td></tr>
    <tr><td class="paramname">col</td><td>the col of the node </td></tr>
    <tr><td class="paramname">lat</td><td>the latitude of the node (in decimal degrees, replaced by function) Note: this is a double, because a float does not have sufficient precision relative to a UTM location (which is in metres) </td></tr>
    <tr><td class="paramname">long</td><td>the longitude of the node (in decimal degrees, replaced by function) Note: this is a double, because a float does not have sufficient precision relative to a UTM location (which is in metres) </td></tr>
    <tr><td class="paramname">Converter</td><td>a converter object (from LSDShapeTools) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ac9ce4ec03dd1d0616a9577a338f69da8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDRaster::get_NCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of columns as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c7f3b7c0908779a7e1060dfe9f4cd4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDRaster::get_NoDataValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>No Data Value as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a08e25cc15564f15dccb8b66b8d4bd7d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDRaster::get_NRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of rows as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c7b0e0fc28fae36bbfb37ad8efcb2ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::get_percentage_bedrock_ridgetops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>roughness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>hilltop_curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the percentage of bedrock ridges. </p>
<p>Uses the hilltop curvature raster and the roughness raster. If the roughness value is greater than the threshold (set to 0.015) then the pixel is designated bedrock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roughness</td><td>roughness input raster </td></tr>
    <tr><td class="paramname">hilltop_curvature</td><td>hilltop curvature input raster </td></tr>
    <tr><td class="paramname">threshold</td><td>threshold value to be designated bedrock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float with percentage bedrock pixels </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a4104b232e5686b68070ce4f7d29c21f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::get_potential_floodplain_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Relief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>relief_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>slope_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get potential floodplain patches using a slope and relief threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Relief</td><td>raster with relief values </td></tr>
    <tr><td class="paramname">Slope</td><td>raster with slope values </td></tr>
    <tr><td class="paramname">relief_threshold</td><td>threshold value for relief (floodplain must be lower than this) </td></tr>
    <tr><td class="paramname">slope_threshold</td><td>threshold value for slope (floodplain must be lower than this) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/10/15 </dd></dl>

</div>
</div>
<a class="anchor" id="abd72008a20563ba21caf7c0d8ba41be2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt;float&gt; LSDRaster::get_RasterData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Raster values as a 2D Array. </dd></dl>

</div>
</div>
<a class="anchor" id="aa01e17bc56551571e8c2f127e3718174"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt;double&gt; LSDRaster::get_RasterData_dbl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the raw raster data, double format. </p>
<dl class="section author"><dt>Author</dt><dd>DAV </dd></dl>

</div>
</div>
<a class="anchor" id="a332a70547de45e7662eb27c0b6ef2f29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt;int&gt; LSDRaster::get_RasterData_int </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the raw raster data, integer format. </p>
<dl class="section author"><dt>Author</dt><dd>DAV </dd></dl>

</div>
</div>
<a class="anchor" id="a4dfb4efd91861f3977426004ccbe5443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDRaster::get_RasterData_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the raster data as a vector. </p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;float&gt; with raster data </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>06/11/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a06f6f87c568b3b187861cba4822b027e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDRaster::get_RasterData_vector_No_NDVs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the raster data as a vector, ignoring NDVs. </p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;float&gt; with raster data </dd></dl>
<dl class="section author"><dt>Author</dt><dd>MDH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>06/02/17 </dd></dl>

</div>
</div>
<a class="anchor" id="ad690e009f9f019da688d553789f6ae8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::get_row_and_col_of_a_point </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>X_coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Y_coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the row and column of a point in the raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X_coordinate</td><td>the x location of the point </td></tr>
    <tr><td class="paramname">Y_coordinate</td><td>the y location of the point </td></tr>
    <tr><td class="paramname">row</td><td>the row of the point, replaced upon running the routine </td></tr>
    <tr><td class="paramname">col</td><td>the col of the point, replaced upon running the routine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/01/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a372400c4d0d1b4a5365b8973ce1301c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::get_threshold_for_floodplain </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bin_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>peak_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>peak_distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get threshold from a raster using a histogram of Probability-Density values. The function identifies the peaks in the PDF, and sets the threshold to the peak with the lowest value. This can be used to set the floodplain threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bin_width</td><td>Bin width for histogram </td></tr>
    <tr><td class="paramname">peak_threshold</td><td>Threshold probability-density value above which peaks will be selected </td></tr>
    <tr><td class="paramname">peak_distance</td><td>Threshold distance between identified peaks (will remove smaller peaks close to the largest ones) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/11/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a983ed9b8d8f60fb2890dba50d48408df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::get_threshold_for_floodplain_QQ </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>q_q_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lower_percentile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upper_percentile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get threshold from a raster using qq plots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_q_filename</td><td>Filename for the txt file with the data to visualise the qq plot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/11/15 </dd></dl>

</div>
</div>
<a class="anchor" id="ac3a888311e20677e866da63c9bc508d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::get_UTM_information </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>UTM_zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>is_North</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function gets the UTM_zone and a boolean that is true if the map is in the northern hemisphere </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UTM_zone</td><td>the UTM zone. Replaced in function. </td></tr>
    <tr><td class="paramname">is_North</td><td>a boolean that is true if the DEM is in the northern hemisphere. replaced in function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a91f2a2a2545c77b481c04b8d7adffd44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::get_value_of_point </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>UTME</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>UTMN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets the value at a point in UTM coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UTME</td><td>the easting coordinate </td></tr>
    <tr><td class="paramname">UTMN</td><td>the northing coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at that point </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>14/03/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="ab9ca0ab8a3c7fe16ef16b25a6bbc9805"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::get_x_and_y_locations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y_loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this gets the x and y location of a node at row and column </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the node </td></tr>
    <tr><td class="paramname">col</td><td>the column of the node </td></tr>
    <tr><td class="paramname">x_loc</td><td>the x location (Northing) of the node </td></tr>
    <tr><td class="paramname">y_loc</td><td>the y location (Easting) of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="abc6d6796b91782832d3afab303effa9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::get_x_and_y_locations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>x_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>y_loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this gets the x and y location of a node at row and column </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the node </td></tr>
    <tr><td class="paramname">col</td><td>the column of the node </td></tr>
    <tr><td class="paramname">x_loc</td><td>the x location (Northing) of the node </td></tr>
    <tr><td class="paramname">y_loc</td><td>the y location (Easting) of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a15e759b3e01ea8860a4ccb63cb7c975b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::get_XMinimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Minimum X coordinate as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ace29fbf034c7af2dc70eb5c58db57bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDRaster::get_XY_MinMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a vector with the X adn Y minimum and max values. </p>
<dl class="section return"><dt>Returns</dt><dd>XYMinMax a vector with four elements XYMinMax[0] = XMinimum XYMinMax[1] = YMinimum XYMinMax[2] = XMaximum XYMinMax[3] = XMaximum </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>3/7/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ac2bcd4d45f9e84eaf037bd4d3e6e653d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::get_YMinimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Minimum Y coordinate as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a32129c11234059809449a3619d2bd84f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::GetBasinVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>Basins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BasinOfInterest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a basin, given by a basin ID, into a chain of xy coordinates for fast plotting of vector basin outlines. </p>
<p>Produces a generalised polygon and will not cope well with complex geometries. <br/>
<br/>
Needs to be updated to write data into an esri ascii format so the files can be loaded into arc. Currently writes to a text file called chain.txt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Basins</td><td>IndexRaster of basins </td></tr>
    <tr><td class="paramname">BasinOfInterest</td><td>integer of the basin ID to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/11/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="afc088f9b26e7c925781a01b69a974e3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::GetVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>output_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to export thinned vector field data to a text file. </p>
<p>The file is written with the format "i j Magnitude Direction". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Magnitude</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of the vector's magnitude. </td></tr>
    <tr><td class="paramname">Direction</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of the vector's direction. </td></tr>
    <tr><td class="paramname">output_file</td><td>Filename for the output text file. </td></tr>
    <tr><td class="paramname">step</td><td>Integer value used to thin the data, 1 preserves all the data, 2 keeps every second point and so on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/1/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a69b1fd5b037bac76a4f26c821f1d854e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::hillshade </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a hillshade raster. </p>
<p>It uses the the algorithm outlined in Burrough and McDonnell Principles of GIS (1990) and in the ArcMap web help <a href="http://edndoc.esri.com/arcobjects/9.2/net/shared/geoprocessing/">http://edndoc.esri.com/arcobjects/9.2/net/shared/geoprocessing/</a> spatial_analyst_tools/how_hillshade_works.htm</p>
<p>Default values are altitude = 45, azimuth = 315, z_factor = 1 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altitude</td><td>(float) of the illumination source in degrees. </td></tr>
    <tr><td class="paramname">azimuth</td><td>(float) of the illumination source in degrees </td></tr>
    <tr><td class="paramname">z_factor</td><td>(float) Scaling factor between vertical and horizontal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hillshaded <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>February 2013 </dd></dl>

</div>
</div>
<a class="anchor" id="ae3618df18dc9c4b0e4aa8f087100053a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::HillslopeLengthFromDrainageDensity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>StreamNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Basins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; int &gt;&#160;</td>
          <td class="paramname"><em>FlowDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple method to calculate drainage density for each basin and then convert these values into a hillslope length raster. </p>
<p>The LH value is calculated using LH = 1/2*DD [Tucker et al 2001]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StreamNetwork</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the stream network. </td></tr>
    <tr><td class="paramname">Basins</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the basins to be analysed. </td></tr>
    <tr><td class="paramname">FlowDir</td><td>Array2D of flowdirections generated by FlowInfo.get_FlowDirection(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raster of basin average hillslope lengths. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>7/11/13 </dd></dl>

</div>
</div>
<a class="anchor" id="adf4f18c6ed62e541057f3a604a84fb35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::HilltopsToCSV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>CHT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>CHT_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>UTMZone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isNorth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write CHT and hilltop gradient data to a *.csv file, coded by UTM coordinates as well as lat/long. </p>
<p>Pass in a CHT raster, CHT raster that has been filtered by gradient, a slope raster, a filename and some spatial reference information used to generate Lat Long values.</p>
<p>The code outputs a csv to the filename specified with the header structure:</p>
<p>"_ID,Easting,Northing,Lat,Long,CHT,gradient_flag,gradient"</p>
<p>Where the gradient_flag is a binary switch where 0 == above threshold and 1 == below threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CHT</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of the hilltop curvature. </td></tr>
    <tr><td class="paramname">CHT_gradient</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of the hilltop curvature, filtered by a gradient threshold. </td></tr>
    <tr><td class="paramname">gradient</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of the topographic gradient. </td></tr>
    <tr><td class="paramname">UTMZone</td><td>The UTM zone the data falls in. </td></tr>
    <tr><td class="paramname">isNorth</td><td>Boolean set to true if the data are in the northern hemisphere and false if not. </td></tr>
    <tr><td class="paramname">eId</td><td>The ellipsoid ID, see <a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a> for details, WGS84 is 22. </td></tr>
    <tr><td class="paramname">filename</td><td>A string containing a path and filename to write the data to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2/11/16 </dd></dl>

</div>
</div>
<a class="anchor" id="aea551343b827e83267b01eac832aafda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::impose_georeferencing_UTM </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>NorS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method imposes georefereing strings assuming the coordinate system is UTM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zone</td><td>the UTM zone </td></tr>
    <tr><td class="paramname">NorS</td><td>a string containing characters that start either N (for north) or S for south. The letter is not case sensitive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>6/11/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a24c2b31fb34a041c4bf240650103f645"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDRaster::interpolate_points_bilinear </td>
          <td>(</td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>UTMEvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>UTMNvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This interpolates a vector of points onto the raster. Uses bilinear interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UTMEvec</td><td>Easting coordinates of points to be interpolatiod. </td></tr>
    <tr><td class="paramname">UTMNvec</td><td>Northing coordinates of points to be interpolatiod. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector of interpolated data. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/03/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a5f5d20b56b3ec4ae4b34846257477a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::IsolateChannelsGeonet </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timesteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>area_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>q_q_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to locate channel pixels outlined by Passalacqua et al. (2010). </p>
<p>Isolate channelised portions of the landscape using the method proposed by Passalacqua et al. (2010) A geometric framework for channel network extraction from lidar: Nonlinear diffusion and geodesic paths, J. Geophys. Res., 115(F1), F01002, doi:10.1029/2009JF001254.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>of timesteps for non-linear filtering steps - suggest 20 in complex terrain </td></tr>
    <tr><td class="paramname">a</td><td>catchment area threshold for pruning </td></tr>
    <tr><td class="paramname">a</td><td>window radius for surface fitting from which curvature calculation is performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> A binary raster where the pixel value is 1 where the input raster exceeded the defined threshold </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/04/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af4859921d32b0ff29fad31f89ec8b941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::IsolateChannelsLashermesCurvature </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>q_q_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method to locate channel pixels outlined by Lashermes. </p>
<p>picks departure from gaussian behaviour, then uses this as a threshold to create a binary dataset. Lashermes, B., E. Foufoula-Georgiou, and W. E. Dietrich (2007), Channel network extraction from high resolution topography using wavelets, Geophys. Res. Lett., 34, L23S04, doi:10.1029/2007GL031140. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>q_q_file A text file containing data to produce a q_q_plot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> A binary raster where the pixel value is 1 where the input raster exceeded the defined threshold </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>11/02/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a6aabb85de4b848f357b3f92d7a26b1c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::IsolateChannelsQuantileQuantile </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>q_q_filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>uses quantile-quantile analysis to pick departure from gaussian behaviour, then uses this as a threshold to create a binary dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>q_q_file A text file containing data to produce a q_q_plot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> A binary raster where the pixel value is 1 where the input raster exceeded the defined threshold </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM /// </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> A binary raster where the pixel value is 1 where the input raster exceeded the defined threshold </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/02/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ae5a22acd87d2a12a9fef0ced5c34cc8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::LSDRasterTemplate </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>InputData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object using a 'template' raster and an Array2D of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputData</td><td>2DArray of floats to be written to <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> containing the data passed in. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/8/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a9629de0411ee55d57b9f3b7020265d0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::M2DFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a flow area raster using a multi 2-direction algorithm. </p>
<p>Computes the proportion of all downslope flows for each cell in the input DEM. Finds the cell of the steepest descent and then checks the two neighbouring cells slopes. If either is also downslope proportion flow between the steepest cell and the steepest neighbour. If neither neighbour is downslope 100% of flow follows the steepest path.</p>
<p>Can <b>NOT</b> handle DEMs containing flats or pits - must be filled using the new <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> fill. Function built around original c++ code by Martin Hurst. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of flow area. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>02/08/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a69fa514549d4c6fbd9d662639cf433b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::MakeGaussianKernel </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SimilarityRadius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate gaussian weighted kernel. </p>
<p>kernel array must be predeclared of size SimilarityRadius and consist of zeros: Array2D&lt;float&gt; Kernel(SimilarityRadius,SimilarityRadius,0.0);</p>
<p>Kernel generated using: G(x,y) = (1/2*pi*sigma^2) exp ((-x^2+y^2)/(2*sigma^2)) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td></td></tr>
    <tr><td class="paramname">sigma</td><td></td></tr>
    <tr><td class="paramname">SimilarityRadius</td><td>similarity window radius. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Martin Hurst </dd></dl>
<dl class="section date"><dt>Date</dt><dd>February 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="a929bdcffb9dc23cf174724bf4b57a2e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::MapAlgebra_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>M_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This add two rasters, elementwise  Simple elementwise addition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_raster</td><td>The raster by which to add the current raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raster holding the elementwise sum of the two rasters </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/10/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a040d9da2e9fadc56445df513aab735ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::MapAlgebra_divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>M_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This divides two rasters, elementwise  Simple elementwise division. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_raster</td><td>The raster by which to divide the current raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raster holding the elementwise quotient of the two rasters </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/10/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a13cac2e67a21fbcc84ff76e617d516a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::MapAlgebra_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>M_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This multiplies two rasters, elementwise  Simple elementwise multiplictation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_raster</td><td>The raster by which to multiply the current raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raster holding the elementwise product of the two rasters </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/10/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a2aa5745b2cf30b3183076aab49bf7016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::MapAlgebra_subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>M_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This subtracts two rasters, elementwise  Simple elementwise subtraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M_raster</td><td>The raster by which to subtract the current raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raster holding the elementwise difference of the two rasters </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/10/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a66ea0cf684b50c7857ae2eff6942f181"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::mask_to_indexraster_using_threshold </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>belowthresholdisnodata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creats an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> mask (with true == 1 and otherwise nodata) from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. Can mask either above or below a threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>The threshold value </td></tr>
    <tr><td class="paramname">belowthresholdisnodata</td><td>a boolean that if true means anything below the threshold turns to nodata </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mask </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>9/9/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="ae26453b71595e28f065cd383e585f05a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::mask_to_nodata_below_threshold </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function changes any elevation &lt;= threshold to NoDataValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>The thresold, silly </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/10/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a1786c3a7aecae312c603b8c4468202b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::mask_to_nodata_using_threshold </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>belowthresholdisnodata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function changes any data point either above or below threshold to NoDataValue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>The threshold value </td></tr>
    <tr><td class="paramname">belowthresholdisnodata</td><td>a boolean that if true means anything below the threshold turns to nodata </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the masked raster </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>28/9/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="aa2f9ec033f242844ee71dbbfd6ce77f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::mask_to_nodata_using_threshold_using_other_raster </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>belowthresholdisnodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>MaskingRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function changes any data point either above or below threshold to NoDataValue The threshold is determined by a second raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>The threshold value </td></tr>
    <tr><td class="paramname">belowthresholdisnodata</td><td>a boolean that if true means anything below the threshold turns to nodata </td></tr>
    <tr><td class="paramname">MaskingRaster</td><td>an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> that is used to define the mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the masked raster </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>28/9/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="af9a75facf0f59d77d39d9e908e4d3ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::mask_to_nodata_with_mask_raster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Mask_raster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function masks a raster to nodata based on a mask value and a mask raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mask_raster</td><td>the <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> that contains the mask </td></tr>
    <tr><td class="paramname">mask_value</td><td>the value on the mask that triggers a nodata </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> that has the masked portions as nodata </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>4/11/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a821d1f21bc4b3eb32b61e92a56f95982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::MaskRaster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>Mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> based on a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a></td><td>TheMask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>MDH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/07/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="acc84f4343f835502a05bf1933fa8a368"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::max_elevation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates max elevation of a raster. </p>
<dl class="section return"><dt>Returns</dt><dd>The spatially distributed relief </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ (entered into trunk SMM) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/02/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="afe2f4870e7575dcc983845eaab2c976d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::MDFlow </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt;&#160;</td>
          <td class="paramname"><em>BoundaryConditions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a flow area raster using a multi direction algorithm. </p>
<p>Computes the proportion of all downslope flows for each cell in the input DEM and routes the flow accordingly. Consequently the dem is sorted and indexed using LSDStatsTools. Can handle DEMs containing flats, but pits must be filled using the new <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> fill.</p>
<p>Currently only works with periodic boundaries. Function built around original c++ code by Martin Hurst. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BoundaryConditions</td><td>Vector as in <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of flow area. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/4/13 - 24/4/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a94d1dd8fb4dbecd7aa84641c06effe7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::mean_elevation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates mean elevation of a raster. </p>
<dl class="section return"><dt>Returns</dt><dd>The spatially distributed relief </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ (entered into trunk SMM) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/02/2014 modified 09/06/2014 by SMM </dd></dl>

</div>
</div>
<a class="anchor" id="aaa43db51b8b8f11f36a16e43d8228b9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::mean_relief </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kernelsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates mean relief of a raster, it defaults to a circular kernal. </p>
<dl class="section return"><dt>Returns</dt><dd>The spatially distributed relief </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ (entered into trunk SMM) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/02/2014 modified 09/06/2014 by SMM </dd></dl>

</div>
</div>
<a class="anchor" id="a47f80e0c1d976238555a4518a092c21a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::MergeRasters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>RasterToAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to merge data from two LSDRasters WITH SAME EXTENT together. /// The data from the raster specified as an argument will be added (will overwrite the original raster if there is a conflict). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RasterToAdd</td><td>second raster to add to original raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>30/09/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a058821368f5f48758cf102062f691ace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::neighbourhood_statistics_fraction_condition </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>neighbourhood_switch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>condition_switch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>test_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tests neighbourhood for the fraction of values for which the specified condition is met. </p>
<p>The second argument (neighbourhood_switch) specifies the neighbourhood type: 0 Square neighbourhood 1 Circular window</p>
<p>the third argument (condition_switch) specifies the condition using an integer as follows: 0 == 1 != 2 &gt; 3 &gt;= 4 &lt; 5 &lt;= </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>window_radius -&gt; radius of neighbourhood </td></tr>
    <tr><td class="paramname">int</td><td>neighbourhood_switch -&gt; see above </td></tr>
    <tr><td class="paramname">int</td><td>condition_switch -&gt; see above </td></tr>
    <tr><td class="paramname">float</td><td>test_value -&gt; the value to test against in the conditional statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> with the fraction of cells in neightbourhood for which condition statement is true </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="aca3d1d5ceab7f16949a14c19c7abbc18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::neighbourhood_statistics_local_relief </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>neighbourhood_switch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets relief within value specified circular neighbourhood </p>
<p>The second argument (neighbourhood_switch) specifies the neighbourhood type: 0 Square neighbourhood 1 Circular window </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>window_radius -&gt; radius of neighbourhood </td></tr>
    <tr><td class="paramname">int</td><td>neighbourhood_switch -&gt; see above </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LSDRasters contianing the relief within a neighbourhood </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/11/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="add3f409837c842162c26ad80036baa24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::neighbourhood_statistics_spatial_average </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>neighbourhood_switch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets mean value for specified circular neighbourhood </p>
<p>The second argument (neighbourhood_switch) specifies the neighbourhood type: 0 Square neighbourhood 1 Circular window </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>window_radius -&gt; radius of neighbourhood </td></tr>
    <tr><td class="paramname">int</td><td>neighbourhood_switch -&gt; see above </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> with the mean value of cells in neightbourhood </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="acb71a579a1f8e5bf5847b1e61b374ba4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt; LSDRaster::neighbourhood_statistics_spatial_average_and_SD </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>window_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>neighbourhood_switch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets mean &amp; standard deviation value specified circular neighbourhood </p>
<p>The second argument (neighbourhood_switch) specifies the neighbourhood type: 0 Square neighbourhood 1 Circular window </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>window_radius -&gt; radius of neighbourhood </td></tr>
    <tr><td class="paramname">int</td><td>neighbourhood_switch -&gt; see above </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;LSDRaster&gt; with 2 LSDRasters, the first with the mean value of cells in neighbourhood, the second with the standard deviation </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24/09/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a070a492ed5f8c076fe1fa27653117654"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::NonLocalMeansFilter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>WindowRadius</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SimilarityRadius</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>DegreeFiltering</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Sigma</em> = <code>1.25</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform Non-local means filtering on a DEM following Baude et al [2005]. </p>
<p>Smoothes non-gaussian noise. Martin Hurst, February, 2012 Modified by David Milodowski, May 2012- generates grid of recording filtered noise</p>
<p>WindowRadius has to be &lt;= SimilarityRadius ?</p>
<p>Adapted from a matlab script by: Author: Jose Vicente Manjon Herrera &amp; Antoni Buades Date: 09-03-2006</p>
<p>Implementation of the Non local filter proposed for A. Buades, B. Coll and J.M. Morel in "A non-local algorithm for image denoising"</p>
<p>**Added soft threshold optimal correction - David Milodowski, 05/2012 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">WindowRadius</td><td>search window radius (defualt=2). </td></tr>
    <tr><td class="paramname">SimilarityRadius</td><td>similarity window radius (defualt=2). </td></tr>
    <tr><td class="paramname">DegreeFiltering</td><td>degree of filtering (defualt=2). </td></tr>
    <tr><td class="paramname">Sigma</td><td>(default=1.25). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filtered <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>MDH, DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>February 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="a9674b03324b823871c59ffe549669082"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::OverwriteRaster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>RasterToAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to merge data from two LSDRasters WITH SAME EXTENT together. /// The data from the raster specified as an argument will be added (will overwrite the original raster if there is a conflict). Overloaded function to rewrite original raster rather than creating a new one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RasterToAdd</td><td>second raster to add to original raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>07/04/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a15f8489f6abf33725b90fd1e1b88aded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::PadRasterSymmetric </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>PaddedRasterData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>SimilarityRadius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a buffer around an array (of size SimilarityRadius) and gives the new border mirror symmetric values of the original array reflected across the boundary. </p>
<p>SimilarityRadius should be the size of the window if filtering. New array has size nrows + 2*SimilarityRadius by ncols + 2*SimilarityRadius. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PaddedRasterData</td><td>Padded <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. </td></tr>
    <tr><td class="paramname">SimilarityRadius</td><td>similarity window radius. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Martin Hurst </dd></dl>
<dl class="section date"><dt>Date</dt><dd>February 2012 </dd></dl>

</div>
</div>
<a class="anchor" id="a2e482d20d43327c6ee6e2f6190dbe736"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::PeronaMalikFilter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timesteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>percentile_for_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters the raster using a Perona-Malik non-linear diffusion filter. </p>
<p>This follows the algorithm descibed in Passalacqua et al. (2010), A geometric framework for channel network extraction from lidar: Nonlinear diffusion and geodesic paths, J. Geophys. Res., 115(F1), F01002, doi:10.1029/2009JF001254. See also Catte et al. (1992), Image Selective Smoothing and Edge Detection by Nonlinear Diffusion, SIAM J. Numer. Anal., 29(1), 182-193, doi:10.1137/0729012. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timesteps</td><td>the number of diffusion timesteps. Suggest ~50 for 1m LiDAR </td></tr>
    <tr><td class="paramname">lambda</td><td>percentile (selects the gradient percentile that is used to define lambda. Suggest 90th percentile) </td></tr>
    <tr><td class="paramname">dt</td><td>The timestep for each round of diffusion. Suggest that this is 0.1 to avoid stability issues (same as Passalacqua et al. 2010) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a filtered raster </dd></dl>
<dl class="section author"><dt>Author</dt><dd>David Milodowski </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ac25df4b9a8c3ddc1c7db18fb44bc2b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::PointShapefileToRaster </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>FileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to turn a point shapefile into an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>. </p>
<p>Can be used to turn a shapefile of channel heads into a sources raster. Does not do any bounds checking or shapefile type checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName</td><td>The path and filename of the shapefile to be loaded, must include the file extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> converted from a point shapefile. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/3/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a682b6387335aef59febeda5c49598a04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDRaster::PolylineShapefileToRaster </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>FileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to turn a polyline shapefile into an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>. </p>
<p>Can be used to turn a shapefile of a river network into a raster. Does not do any bounds checking or shapefile type checking.</p>
<p>Works by calculating points along each line spaced by less than the data resolution. This has the effect of flaggin every raster cell along a polyline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName</td><td>The path and filename of the shapefile to be loaded, must include the file extension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> converted from a polyline shapefile. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/3/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a34295ea8299a2bef045984f833c33976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::PoupulateRasterGaussian </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate a raster with random noise drawn from a gaussian distribution of given mean and minimum values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimum</td><td>Minimum value of the distribution to draw values from. </td></tr>
    <tr><td class="paramname">mean</td><td>Mean value of the distribution to draw values from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>9/6/16</dd></dl>
<p>Populate a raster with random noise drawn from a gaussian distribution of given mean and minimum values. SWDG 9/6/16 </p>

</div>
</div>
<a class="anchor" id="a821e7693904a2ea45fef8e6414988d07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::PoupulateRasterSingleValue </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate a raster with a single value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to populate all non nodata cells with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>9/6/16</dd></dl>
<p>Populate a raster with a given value. SWDG 9/6/16 </p>

</div>
</div>
<a class="anchor" id="a5e484a0efe3df226c1ecf69d11eb114b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::QuinnMDFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a flow area raster using a multi direction algorithm. </p>
<p>Computes the proportion of all downslope flows for each cell in the input DEM, and weights them using the equation from Quinn et al 1991 and routes the flow accordingly.</p>
<p>Paper link: <a href="http://onlinelibrary.wiley.com/doi/10.1002/hyp.3360050106/abstract">http://onlinelibrary.wiley.com/doi/10.1002/hyp.3360050106/abstract</a></p>
<p>Cardinal Weighting = (elevation_drop/total_elevation_drop)*DataResolution/2 <br/>
Diagonal Weighting = ((elevation_drop/total_elevation_drop)*(1/root(2)))* DataResolution*0.354</p>
<p>Can <b>NOT</b> handle DEMs containing flats or pits - must be filled using the new <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> fill. Function built around original c++ code by Martin Hurst. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of flow area. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/4/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a33d568d1e13391c0296652f1ab217b5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::raster_multiplier </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>multiplier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This multiplies the raster data by a multiplier  Note that values are replaced. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>06/05/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="aeb0173327e0a52943052f8a3486c382e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::raster_statistics_by_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>IndexRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>mean_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>sd_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>serr_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Npts_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a raster and a corresponding index raster, and calculates the mean, sd and standard error by index. Returns four vectors: mean, st.dev., st.err and Number of points for each category. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>index raster </td></tr>
    <tr><td class="paramname">output</td><td>vector with mean values </td></tr>
    <tr><td class="paramname">output</td><td>vector with standard deviation values </td></tr>
    <tr><td class="paramname">output</td><td>vector with standard error values </td></tr>
    <tr><td class="paramname">output</td><td>vector with number of points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>28/11/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a00c74ca7454b451b85a680eb581fbf7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::RasterTrimmer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the minimum bounding rectangle for an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> Object and crop out all the surrounding NoDataValues to reduce the size and load times of output rasters. </p>
<p>Ideal for use with chi analysis tools which output basin and chi m value rasters which can be predominantly no data. As an example, a 253 Mb file can be reduced to ~5 Mb with no loss or resampling of data.<br/>
 Modded 6/11/14 to cope with bil files and to catch cases where some or all of the edges cannot be trimmed - SWDG</p>
<dl class="section return"><dt>Returns</dt><dd>A trimmed <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/08/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a33720ffe99abb3ed10264c679b9a608c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::RasterTrimmerPadded </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padded_pixels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the minimum bounding rectangle for an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> Object and crop out all the surrounding NoDataValues to reduce the size and load times of output rasters. Similar to RasterTrimmer but has a pixel buffer. Useful for CRN data since sometimes the channel in the DEM does not correspond exactly with the data point. </p>
<p>Ideal for use with chi analysis tools which output basin and chi m value rasters which can be predominantly no data. As an example, a 253 Mb file can be reduced to ~5 Mb with no loss or resampling of data.<br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">padded_pixels</td><td>the number of pixels to pad the DEM with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A trimmed <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/03/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a47b61cc0f912f93dc6e5483ce03ef468"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::RasterTrimmerSpiral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a raster and trims nodata from around the edges to result in a rectangular <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A trimmed <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>5/11/14 </dd></dl>

</div>
</div>
<a class="anchor" id="abc85ecbaf0891c9f31ed6b886feb2860"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::read_ascii_raster_integers </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>FILENAME</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a raster of integers and populates <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> integer array member data. </p>
<dl class="section author"><dt>Author</dt><dd>DAV </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Really, one ought to modify <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> so that it is a class template, and then wouldn't need different TNT Array data members for when we have floats, double, ints etc. Might be tricky though, although if done carefully it should not break peoples code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac95d817228d0efa166a601c406aa7862"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::read_raster </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a raster into memory from a file. </p>
<p>The supported formats are .asc and .flt which are both exported and imported by arcmap.</p>
<p>The filename is the string of characters before the '.' in the extension and the extension is the characters after the '.'.</p>
<p>If the full filename is my_dem.01.asc then: filename = "my_dem.01" and extension = "asc".</p>
<p>For float files both a data file and a header are read the header file must have the same filename, before extention, of the raster data, and the extension must be .hdr.</p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a7ccac8e8ee1daaf3a6751e67b4874319"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::remove_positive_hilltop_curvature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>hilltop_curvature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes positive hilltop curvature values. </p>
<p>Modifies the hilltop curvature raster to remove pixels with positive curvature caused by noise </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hilltop_curvature</td><td>hilltop curvature input raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of hilltop curvature with positive values removed </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24/03/14 </dd></dl>

</div>
</div>
<a class="anchor" id="ae5b5fecd2a59a3fedf8019f78d8adede"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::remove_positive_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes positive values from a raster. </p>
<p>Modifies araster to remove pixels with positive values </p>
<dl class="section author"><dt>Author</dt><dd>MDH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25/07/17 </dd></dl>

</div>
</div>
<a class="anchor" id="abe32afe622883ef703bbac4d997ad7a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::remove_seas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function changes any elevation &lt;= 0 to NoDataValue. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>03/10/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="aac89c6707b5e24a1e0ba8261352533f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::RemoveAbove </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple method to remove any values above a user supplied value from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>float of the threshold above which values will be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25/11/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a3f89819eff281f83e613c5d3f9952b3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::RemoveBelow </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple method to remove any values below a user supplied value from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>float of the threshold below which values will be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/6/15 </dd></dl>

</div>
</div>
<a class="anchor" id="aafdc54eca6f5b0807d424fd981a85971"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::Resample </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>OutputResolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to resample an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to a lower resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OutputResolution</td><td>the resolution in spatial units to be resampled to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> resampled to the OutputResolution. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/3/14 </dd></dl>

</div>
</div>
<a class="anchor" id="ae00b501f9761192ca7a5f4f417bdecfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::rewrite_with_random_values </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rewrite all the data array values with random numbers (with a uniform distribution). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>is the range of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/02/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a21318933bf408b932c053465d0f0aa7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::RidgeBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BufferRadius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass a buffer over a ridge <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object to increase sampling area. </p>
<p>Buffers equally in all directions, so use with care to avoid sampling areas away from the axis of the original ridge line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BufferRadius</td><td>optional integer buffer radius between 1 and 6. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Default buffer radius is 2 and will revert to that value if a radius outside the vaid range (1 to 6) is passed. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object containing buffered ridges. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="afca4a22a3e5ea44a2eb2d0224ec40766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::RidgeSample </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ridges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Module to sample <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> values running along a ridgetop network. </p>
<p>Ridge network is generated from <a class="el" href="class_l_s_d_junction_network.html#a29b1f20e6efcdcc9c2b59e307822a71d" title="Ridge network extraction - extracts ridge network, defined as boundaries between two basins of the sa...">LSDJunctionNetwork::ExtractRidges</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ridges</td><td>2D Array of ridge lines. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sampled <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a83502ee2ffab4935277aec652ab4a789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::RidgeSmoother </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>WindowRadius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass a smoothing window over a ridge <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object to calculate an average value running along the ridgetop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">WindowRadius</td><td>optional integer smoothing radius between 1 and 6. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Default smoothing radius is 2 and will revert to that value if a radius outside the vaid range (1 to 6) is passed. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Averaged <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a32042e55758bdf70dd50f631727fc787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::rudimentary_nodata_fill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a very rudimentay filling routine that just fills nodata nodes with the average elevation of its neighbors </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/11/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ae78165b8a11dccdeb493fbfe892aa17d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; float &gt; &gt; LSDRaster::Sample_Along_Ridge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Raster1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Raster2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Raster3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample the values of 3 input rasters that intersect with the point a,b within the area defined by threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Raster1</td><td>First <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to sample. </td></tr>
    <tr><td class="paramname">Raster2</td><td>Second <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to sample. </td></tr>
    <tr><td class="paramname">Raster3</td><td>Third <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to sample. </td></tr>
    <tr><td class="paramname">a</td><td>Integer row index of point to sample. </td></tr>
    <tr><td class="paramname">b</td><td>Integer col index of point to sample. </td></tr>
    <tr><td class="paramname">threshold</td><td>The number of cells of hilltop to sample. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors of floats, containing the sampled values for each raster. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23/1/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a521142e6e1f812b104aa80e7be86af1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::set_data_element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the raster data at a specified location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>An integer, the X coordinate of the target cell. </td></tr>
    <tr><td class="paramname">column</td><td>An integer, the Y coordinate of the target cell. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the updated raster element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19/05/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a258644dc36c4ed6e04011ff2419074a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::SetWrapSample </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This sets a value in the data array withthe added feature that it wraps beyond NRows and NCols. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>row of data to be reset. </td></tr>
    <tr><td class="paramname">The</td><td>column of the data to be reset. </td></tr>
    <tr><td class="paramname">The</td><td>value of the data to be reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/02/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="adbc990b240756b3683628d0881f28bbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRaster::Shadow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a hillshade derivative raster using the algorithm outlined in Codilean (2006). </p>
<p>It identifies areas in shadow as 1 and all other values as 0. Is interfaced through LSDRaster::TopoShield and should not be called directly, to generate a hillshade use <a class="el" href="class_l_s_d_raster.html#a69b1fd5b037bac76a4f26c821f1d854e" title="This function generates a hillshade raster. ">LSDRaster::hillshade</a> instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>The zenith angle of the illumination source in degrees. </td></tr>
    <tr><td class="paramname">phi</td><td>The azimuth angle of the illumination source in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2D Array of floats. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>11/4/13 </dd></dl>

</div>
</div>
<a class="anchor" id="aaef61f081a68a6677698daa2bd55033d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRaster::Shadows </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Azimuth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ZenithAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to determine areas of a DEM that are in shadow from a given radiation source defined by an Azimuth and Zenith following Codilean (2006). </p>
<p>Performs a coordinate transformation, rotating the x,y,z coordinates about the Azimuth and Zenith such that the coordinates are aligned with the Azimuth and Zenith. Shaded cells are then found by tracking in the direction of the radiation source and looking for transformed z values greater than that at the cell of interest which would therefore cast a shadow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Azimuth</td><td>of the illumination source in degrees. </td></tr>
    <tr><td class="paramname">ZenithAngle</td><td>of the illumination source in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hillshaded 2D Array of ints </dd></dl>
<dl class="section author"><dt>Author</dt><dd>MDH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Feb 2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a28c7f7dcdd605a47e0413d1fd08927bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::SingleBasinAverager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Basin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Module calculates an average value to each for a given raster from within a basin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Basins</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of a Drainage basin </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Float of the averaged value </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24/3/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a6cb2a79bbdc11675ebb1c93c705bf01a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::strip_raster_padding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips the edge rows/columns of a <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> on each side of the array. </p>
<p>This removes 1 pixel/grid cell from each side of an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> Note that it modifies the original raster and reassigns the RasterData_dbl data member to the new 'trimmed' raster. It then reduces the NCols and NRows values by 2, but does not modify the ll-corner values. It was primarily written for a special case in <a class="el" href="class_l_s_d_catchment_model.html" title="This object is used to model the hydrology, sediment transport and evolution of individual basins...">LSDCatchmentModel</a> but will work with any <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. </p>
<dl class="section author"><dt>Author</dt><dd>DAV </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a1fa2dc8f6e3e1c62e9e3fb74225c8aa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::TopographicShielding </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>theta_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phi_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a topographic shielding raster using the algorithm outlined in Codilean (2006). </p>
<p>Creating a raster of values between 0 and 1 of shadowed cells which can be used as a scaling factor in Cosmo analysis.</p>
<p>Goes further than the original algorithm allowing a theoretical theta, phi pair of 1,1 to be supplied and although this will increase the computation time significantly, it is much faster than the original Avenue and VBScript implementations (This is probably no longer true now that we incorporate drop shadows (MDH, Feb 2015)).</p>
<p>Takes 2 ints, representing the theta, phi paring required. Codilean (2006) used 5,5 as the standard values, but in reality values of 10,15 are often preferred to save processing time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta_step</td><td>Spacing of sampled theta values. </td></tr>
    <tr><td class="paramname">phi_step</td><td>Spacing of sampled phi values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>phi_step must be a factor of 360. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>11/4/13 </dd></dl>

</div>
</div>
<a class="anchor" id="ad561bc23880faa84f0bb8b1b04e365fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, string &gt; LSDRaster::Update_GeoReferencingStrings </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>NewXmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>NewYmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method which takes a new xmin and ymax value and modifys the GeoReferencingStrings map_info line to contain these new values. </p>
<p>Intended for use in the rastertrimmer methods and is called from within these methods. Modifying georeferencing information by hand is messy and should be avoided if at all possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewXmin</td><td>floating point value of the new minimum x value in the raster. </td></tr>
    <tr><td class="paramname">NewYmax</td><td>floating point value of the new maximum y value in the raster. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An updated GeoReferencingStrings object.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>6/11/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a31031dfeb7aa365fa0219268f2c94ac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::Update_GeoReferencingStrings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method which updates the map info element of the georeferencing strings based on information within the datamembers of the raster. </p>
<p>Intended for use when changing raster dimesions</p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>6/11/14 </dd></dl>

</div>
</div>
<a class="anchor" id="abd69705ea2bdb06af1703a111d8da599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRaster::WrapSample </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a value from the array data element but wraps around the array dimensions so that row &gt; NRows (for example) returns a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>row of the data point you want.  Column of desired data point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the data array at the desired row and column. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/02/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="aef35a4944909540182a86f86fc7a20a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRaster::write_dinf_flowdir_to_LSDRaster </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>dinflow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to write the D-infinity flow directions to an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dinflow</td><td>Array of Flowdirections generated by <a class="el" href="class_l_s_d_raster.html#a23ed6f1737d703a6e2db5fa385e59dfd" title="D-infinity flow direction algorithm after Tarboton (1997). ">D_inf_FlowDir()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of D-inf flow directions in degrees. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/07/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a04ed4d63b576662474713a7a6dd30fff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::write_double_bil_raster </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>string_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes out a double array to a ENVI bil file (untested!) </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>Unlikely to work as Georeferencing not set. DAV to fix. </dd></dl>

</div>
</div>
<a class="anchor" id="a72dca7a4de099dc3b3defa5d1f8c5050"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::write_double_raster </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This calls raster write functions, writing from Arrays of type &lt;double&gt; to raster format. </p>
<p>Sorry for duplicating a load of code, but I couldn't think of a good way to overload the function without passing the raster data array or breaking someone elses code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>a string of the filename <em>without</em> the extension. </td></tr>
    <tr><td class="paramname">extension</td><td>a string of the extension <em>without</em> the leading dot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DAV </dd></dl>
<dl class="section date"><dt>Date</dt><dd>07-12-2015 </dd></dl>

</div>
</div>
<a class="anchor" id="af8fce06a9e645907f3b44788dc9926f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::write_raster </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a raster from memory to a file. </p>
<p>The supported formats are .asc and .flt which are both exported and imported by arcmap.</p>
<p>The filename is the string of characters before the '.' in the extension and the extension is the characters after the '.'.</p>
<p>If the full filename is my_dem.01.asc then: filename = "my_dem.01" and extension = "asc".</p>
<p>For float files both a data file and a header are written the header file must have the same filename, before extention, of the raster data, and the extension must be .hdr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>a string of the filename <em>without</em> the extension. </td></tr>
    <tr><td class="paramname">extension</td><td>a string of the extension <em>without</em> the leading dot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a97bc58532a0ed8acccea68da9a787760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRaster::write_RasterData_to_text_file </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the raster data as text file. </p>
<dl class="section return"><dt>Returns</dt><dd>text file with raster data </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>30/09/16 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_l_s_d_raster_8hpp_source.html">LSDRaster.hpp</a></li>
<li>src/LSDRaster.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
