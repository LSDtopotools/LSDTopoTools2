<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LSDTopoTools2: LSDChiNetwork Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LSDTopoTools2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_l_s_d_chi_network-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LSDChiNetwork Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This object is used to examine a network of channels in chi space.  
 <a href="class_l_s_d_chi_network.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_l_s_d_chi_network_8hpp_source.html">LSDChiNetwork.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ee781f39d789a71a5eb2e87f48d5103"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a6ee781f39d789a71a5eb2e87f48d5103">LSDChiNetwork</a> (string channel_network_fname)</td></tr>
<tr class="memdesc:a6ee781f39d789a71a5eb2e87f48d5103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crate routine to make a <a class="el" href="class_l_s_d_chi_network.html" title="This object is used to examine a network of channels in chi space. ">LSDChiNetwork</a> object.  <a href="#a6ee781f39d789a71a5eb2e87f48d5103">More...</a><br/></td></tr>
<tr class="separator:a6ee781f39d789a71a5eb2e87f48d5103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ca4be1209cc1d51d201b26b24a36bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40ca4be1209cc1d51d201b26b24a36bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LSDChiNetwork</b> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, int SourceNode, int OutletNode, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Elevation, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;FlowDistance, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DrainageArea)</td></tr>
<tr class="separator:a40ca4be1209cc1d51d201b26b24a36bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344cabd97538dfb4fe19c558c7e18d9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a344cabd97538dfb4fe19c558c7e18d9a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LSDChiNetwork</b> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, int SourceNode, int OutletNode, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Elevation, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;FlowDistance, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DrainageArea, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Chi)</td></tr>
<tr class="separator:a344cabd97538dfb4fe19c558c7e18d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9019225dd258856c5747a8980a5146"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a5a9019225dd258856c5747a8980a5146">get_n_channels</a> ()</td></tr>
<tr class="separator:a5a9019225dd258856c5747a8980a5146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9ac610a3f1dd4b66226e6666853bcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#afb9ac610a3f1dd4b66226e6666853bcb">get_NRows</a> () const </td></tr>
<tr class="separator:afb9ac610a3f1dd4b66226e6666853bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53a17a937ebf4af809115adf10dd2b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#aa53a17a937ebf4af809115adf10dd2b0">get_NCols</a> () const </td></tr>
<tr class="separator:aa53a17a937ebf4af809115adf10dd2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a496a8f840819afe403cb7a41d89d08"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a9a496a8f840819afe403cb7a41d89d08">get_XMinimum</a> () const </td></tr>
<tr class="separator:a9a496a8f840819afe403cb7a41d89d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51377fd181e67a8b28ad61774b43927"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#ae51377fd181e67a8b28ad61774b43927">get_YMinimum</a> () const </td></tr>
<tr class="separator:ae51377fd181e67a8b28ad61774b43927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ccd054331be70dca228b11dfb6136d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a67ccd054331be70dca228b11dfb6136d">get_DataResolution</a> () const </td></tr>
<tr class="separator:a67ccd054331be70dca228b11dfb6136d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67b433ac8eaa806badce312805ba9b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#ad67b433ac8eaa806badce312805ba9b0">get_NoDataValue</a> () const </td></tr>
<tr class="separator:ad67b433ac8eaa806badce312805ba9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e61b8661b819316ea7cf1149b2ce0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#ad0e61b8661b819316ea7cf1149b2ce0c">print_channel_details_to_screen</a> (int channel_number)</td></tr>
<tr class="memdesc:ad0e61b8661b819316ea7cf1149b2ce0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print channel details to screen for bug checking.  <a href="#ad0e61b8661b819316ea7cf1149b2ce0c">More...</a><br/></td></tr>
<tr class="separator:ad0e61b8661b819316ea7cf1149b2ce0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801b143b9a1c5e7af16c4432ad4465ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a801b143b9a1c5e7af16c4432ad4465ca">print_channel_details_to_file</a> (string fname, float A_0, float m_over_n)</td></tr>
<tr class="memdesc:a801b143b9a1c5e7af16c4432ad4465ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print channel details to file for bug checking.  <a href="#a801b143b9a1c5e7af16c4432ad4465ca">More...</a><br/></td></tr>
<tr class="separator:a801b143b9a1c5e7af16c4432ad4465ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8f28e19f2ce623f95b2926d3c5e3bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a5f8f28e19f2ce623f95b2926d3c5e3bd">print_channel_details_to_file_full_fitted</a> (string fname)</td></tr>
<tr class="memdesc:a5f8f28e19f2ce623f95b2926d3c5e3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the details of all channels to a file.  <a href="#a5f8f28e19f2ce623f95b2926d3c5e3bd">More...</a><br/></td></tr>
<tr class="separator:a5f8f28e19f2ce623f95b2926d3c5e3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f5ad9579df2c6caf94748bfdd1c52e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a60f5ad9579df2c6caf94748bfdd1c52e">print_channel_details_to_file_full_fitted_for_ArcMap</a> (string fname)</td></tr>
<tr class="memdesc:a60f5ad9579df2c6caf94748bfdd1c52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the details of all channels to a csv file that can be ingested by ArcMap.  <a href="#a60f5ad9579df2c6caf94748bfdd1c52e">More...</a><br/></td></tr>
<tr class="separator:a60f5ad9579df2c6caf94748bfdd1c52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc034f50d2379870289ce318bd836f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a0bc034f50d2379870289ce318bd836f1">print_channel_details_to_file_full_fitted</a> (string fname, int target_nodes, int minimum_segment_length)</td></tr>
<tr class="memdesc:a0bc034f50d2379870289ce318bd836f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the details of all channels to a file.  <a href="#a0bc034f50d2379870289ce318bd836f1">More...</a><br/></td></tr>
<tr class="separator:a0bc034f50d2379870289ce318bd836f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2699db1455aa6a07790214640ab99e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a7f2699db1455aa6a07790214640ab99e">extend_tributaries_to_outlet</a> ()</td></tr>
<tr class="memdesc:a7f2699db1455aa6a07790214640ab99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This extends the tributary channels all the way to the outlet.  <a href="#a7f2699db1455aa6a07790214640ab99e">More...</a><br/></td></tr>
<tr class="separator:a7f2699db1455aa6a07790214640ab99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc44bb761b78a89aa1f4712eaf4f378c"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#adc44bb761b78a89aa1f4712eaf4f378c">data_to_array</a> (int data_member)</td></tr>
<tr class="memdesc:adc44bb761b78a89aa1f4712eaf4f378c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine for returning calculated data to an array.  <a href="#adc44bb761b78a89aa1f4712eaf4f378c">More...</a><br/></td></tr>
<tr class="separator:adc44bb761b78a89aa1f4712eaf4f378c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2696da4388a3ec771d9dd351fc1752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a8f2696da4388a3ec771d9dd351fc1752">slope_area_extraction_vertical_intervals</a> (float interval, float area_thin_fraction, string fname)</td></tr>
<tr class="memdesc:a8f2696da4388a3ec771d9dd351fc1752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract slope over fixed vertical intervals.  <a href="#a8f2696da4388a3ec771d9dd351fc1752">More...</a><br/></td></tr>
<tr class="separator:a8f2696da4388a3ec771d9dd351fc1752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afd0d4b0e11753df837c15c293f548c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a9afd0d4b0e11753df837c15c293f548c">slope_area_extraction_horizontal_intervals</a> (float interval, float area_thin_fraction, string fname)</td></tr>
<tr class="memdesc:a9afd0d4b0e11753df837c15c293f548c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract slope over fixed horizontal intervals.  <a href="#a9afd0d4b0e11753df837c15c293f548c">More...</a><br/></td></tr>
<tr class="separator:a9afd0d4b0e11753df837c15c293f548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add215f08eeb56ba9fef26e39bf8755c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#add215f08eeb56ba9fef26e39bf8755c0">calculate_chi</a> (float A_0, float m_over_n)</td></tr>
<tr class="memdesc:add215f08eeb56ba9fef26e39bf8755c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the chi values for the channel network using the rectangle rule.  <a href="#add215f08eeb56ba9fef26e39bf8755c0">More...</a><br/></td></tr>
<tr class="separator:add215f08eeb56ba9fef26e39bf8755c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee5c89d6ceed8d57fd7235deda3168b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a0ee5c89d6ceed8d57fd7235deda3168b">calculate_optimal_chi_spacing</a> (int target_nodes)</td></tr>
<tr class="memdesc:a0ee5c89d6ceed8d57fd7235deda3168b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calucaltes the chi spacing of the main stem channel (the longest channel).  <a href="#a0ee5c89d6ceed8d57fd7235deda3168b">More...</a><br/></td></tr>
<tr class="separator:a0ee5c89d6ceed8d57fd7235deda3168b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c58cf0962448576f53bce38c8f94fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#ab9c58cf0962448576f53bce38c8f94fd">calculate_skip</a> (int target_nodes)</td></tr>
<tr class="memdesc:ab9c58cf0962448576f53bce38c8f94fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calucaltes the skip parameter of the main stem (the longest channel).  <a href="#ab9c58cf0962448576f53bce38c8f94fd">More...</a><br/></td></tr>
<tr class="separator:ab9c58cf0962448576f53bce38c8f94fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0f5f45fddacd610e411d00286c3d3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a1f0f5f45fddacd610e411d00286c3d3d">calculate_skip</a> (int target_nodes, vector&lt; float &gt; &amp;sorted_chis)</td></tr>
<tr class="memdesc:a1f0f5f45fddacd610e411d00286c3d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calucaltes the skip parameter based on a vector of chi values.  <a href="#a1f0f5f45fddacd610e411d00286c3d3d">More...</a><br/></td></tr>
<tr class="separator:a1f0f5f45fddacd610e411d00286c3d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2e247951b2171f559c4ab0c12e2fb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a0f2e247951b2171f559c4ab0c12e2fb1">calculate_skip</a> (int target_nodes, int channel_number)</td></tr>
<tr class="memdesc:a0f2e247951b2171f559c4ab0c12e2fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calucaltes the skip parameter of a give channel.  <a href="#a0f2e247951b2171f559c4ab0c12e2fb1">More...</a><br/></td></tr>
<tr class="separator:a0f2e247951b2171f559c4ab0c12e2fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f283a68143500231244d3c87f969570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a6f283a68143500231244d3c87f969570">find_most_likeley_segments</a> (int channel, int minimum_segment_length, float sigma, int N, vector&lt; float &gt; &amp;b_vec, vector&lt; float &gt; &amp;m_vec, vector&lt; float &gt; &amp;r2_vec, vector&lt; float &gt; &amp;DW_vec, vector&lt; float &gt; &amp;thinned_chi, vector&lt; float &gt; &amp;thinned_elev, vector&lt; float &gt; &amp;fitted_elev, vector&lt; int &gt; &amp;node_reference, vector&lt; int &gt; &amp;these_segment_lengths, float &amp;this_MLE, int &amp;this_n_segments, int &amp;n_data_nodes, float &amp;this_AIC, float &amp;this_AICc)</td></tr>
<tr class="memdesc:a6f283a68143500231244d3c87f969570"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the most likely channel segments for a particular channel.  <a href="#a6f283a68143500231244d3c87f969570">More...</a><br/></td></tr>
<tr class="separator:a6f283a68143500231244d3c87f969570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cf6bcc46dac34a3e98808c74d8b54a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#ab1cf6bcc46dac34a3e98808c74d8b54a">find_most_likeley_segments_dchi</a> (int channel, int minimum_segment_length, float sigma, float dchi, vector&lt; float &gt; &amp;b_vec, vector&lt; float &gt; &amp;m_vec, vector&lt; float &gt; &amp;r2_vec, vector&lt; float &gt; &amp;DW_vec, vector&lt; float &gt; &amp;thinned_chi, vector&lt; float &gt; &amp;thinned_elev, vector&lt; float &gt; &amp;fitted_elev, vector&lt; int &gt; &amp;node_reference, vector&lt; int &gt; &amp;these_segment_lengths, float &amp;this_MLE, int &amp;this_n_segments, int &amp;n_data_nodes, float &amp;this_AIC, float &amp;this_AICc)</td></tr>
<tr class="memdesc:ab1cf6bcc46dac34a3e98808c74d8b54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the most likely channel segments for a particular channel.  <a href="#ab1cf6bcc46dac34a3e98808c74d8b54a">More...</a><br/></td></tr>
<tr class="separator:ab1cf6bcc46dac34a3e98808c74d8b54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4dafa43ab33c310d4d2df3605672f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a6f4dafa43ab33c310d4d2df3605672f4">find_most_likeley_segments_monte_carlo</a> (int channel, int minimum_segment_length, float sigma, int mean_skip, int skip_range, vector&lt; float &gt; &amp;b_vec, vector&lt; float &gt; &amp;m_vec, vector&lt; float &gt; &amp;r2_vec, vector&lt; float &gt; &amp;DW_vec, vector&lt; float &gt; &amp;thinned_chi, vector&lt; float &gt; &amp;thinned_elev, vector&lt; float &gt; &amp;fitted_elev, vector&lt; int &gt; &amp;node_reference, vector&lt; int &gt; &amp;these_segment_lengths, float &amp;this_MLE, int &amp;this_n_segments, int &amp;n_data_nodes, float &amp;this_AIC, float &amp;this_AICc)</td></tr>
<tr class="memdesc:a6f4dafa43ab33c310d4d2df3605672f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the most likely segments but uses the monte carlo data thinning method.  <a href="#a6f4dafa43ab33c310d4d2df3605672f4">More...</a><br/></td></tr>
<tr class="separator:a6f4dafa43ab33c310d4d2df3605672f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031f52243e13595729a01ce073fb0784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a031f52243e13595729a01ce073fb0784">find_most_likeley_segments_monte_carlo_dchi</a> (int channel, int minimum_segment_length, float sigma, float mean_dchi, float variation_dchi, vector&lt; float &gt; &amp;b_vec, vector&lt; float &gt; &amp;m_vec, vector&lt; float &gt; &amp;r2_vec, vector&lt; float &gt; &amp;DW_vec, vector&lt; float &gt; &amp;thinned_chi, vector&lt; float &gt; &amp;thinned_elev, vector&lt; float &gt; &amp;fitted_elev, vector&lt; int &gt; &amp;node_reference, vector&lt; int &gt; &amp;these_segment_lengths, float &amp;this_MLE, int &amp;this_n_segments, int &amp;n_data_nodes, float &amp;this_AIC, float &amp;this_AICc)</td></tr>
<tr class="memdesc:a031f52243e13595729a01ce073fb0784"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the most likely segments but uses the monte carlo data thinning method.  <a href="#a031f52243e13595729a01ce073fb0784">More...</a><br/></td></tr>
<tr class="separator:a031f52243e13595729a01ce073fb0784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fe8779ad0575c4b11eae5e4178ca62"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a21fe8779ad0575c4b11eae5e4178ca62">search_for_best_fit_m_over_n_dchi</a> (float A_0, int n_movern, float d_movern, float start_movern, int minimum_segment_length, float sigma, int target_nodes_mainstem, string fname)</td></tr>
<tr class="memdesc:a21fe8779ad0575c4b11eae5e4178ca62"><td class="mdescLeft">&#160;</td><td class="mdescRight">The master routine for calculating the best fit m over n values for a channel network, based on a fixed value of dchi.  <a href="#a21fe8779ad0575c4b11eae5e4178ca62">More...</a><br/></td></tr>
<tr class="separator:a21fe8779ad0575c4b11eae5e4178ca62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d94d12fb29404329296edf6e7500f57"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a0d94d12fb29404329296edf6e7500f57">search_for_best_fit_m_over_n</a> (float A_0, int n_movern, float d_movern, float start_movern, int minimum_segment_length, float sigma, int target_nodes_mainstem, string fname)</td></tr>
<tr class="memdesc:a0d94d12fb29404329296edf6e7500f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The master routine for calculating the best fit m over n values for a channel network.  <a href="#a0d94d12fb29404329296edf6e7500f57">More...</a><br/></td></tr>
<tr class="separator:a0d94d12fb29404329296edf6e7500f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e0f04da77c3c3db517ef6d9822489e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#ac7e0f04da77c3c3db517ef6d9822489e">search_for_best_fit_m_over_n_seperate_ms_and_tribs</a> (float A_0, int n_movern, float d_movern, float start_movern, int minimum_segment_length, float sigma, int target_nodes_mainstem, string fname)</td></tr>
<tr class="memdesc:ac7e0f04da77c3c3db517ef6d9822489e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine for calculating the best fit m over n values for a channel network, but calculates the mainstem and the tributaries seperately.  <a href="#ac7e0f04da77c3c3db517ef6d9822489e">More...</a><br/></td></tr>
<tr class="separator:ac7e0f04da77c3c3db517ef6d9822489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b78169a4d937bec6a973d5393d9081"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a72b78169a4d937bec6a973d5393d9081">search_for_best_fit_m_over_n_colinearity_test</a> (float A_0, int n_movern, float d_movern, float start_movern, int minimum_segment_length, float sigma, int target_nodes, int n_iterations, vector&lt; float &gt; &amp;m_over_n_values, vector&lt; float &gt; &amp;AICc_mean, vector&lt; float &gt; &amp;AICc_sdtd)</td></tr>
<tr class="memdesc:a72b78169a4d937bec6a973d5393d9081"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function looks for the best fit values of m over n by simply testing for the least variation in the tributaries.  <a href="#a72b78169a4d937bec6a973d5393d9081">More...</a><br/></td></tr>
<tr class="separator:a72b78169a4d937bec6a973d5393d9081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e13e824b47c3071cd63fce9d922421"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#ad4e13e824b47c3071cd63fce9d922421">search_for_best_fit_m_over_n_colinearity_test_with_breaks</a> (float A_0, int n_movern, float d_movern, float start_movern, int minimum_segment_length, float sigma, int target_skip, int target_nodes, int n_iterations, vector&lt; float &gt; &amp;m_over_n_values, vector&lt; float &gt; &amp;AICc_mean, vector&lt; float &gt; &amp;AICc_sdtd, int Monte_Carlo_switch)</td></tr>
<tr class="memdesc:ad4e13e824b47c3071cd63fce9d922421"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculeates best fit m/n using the collinearity test <br/>
 these channels are ones with breaks.  <a href="#ad4e13e824b47c3071cd63fce9d922421">More...</a><br/></td></tr>
<tr class="separator:ad4e13e824b47c3071cd63fce9d922421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2668b960858780f9b2389d17e32d8dd4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a2668b960858780f9b2389d17e32d8dd4">search_for_best_fit_m_over_n_individual_channels_with_breaks</a> (float A_0, int n_movern, float d_movern, float start_movern, int minimum_segment_length, float sigma, int target_skip, int target_nodes, int n_iterations, vector&lt; float &gt; &amp;m_over_n_values, vector&lt; vector&lt; float &gt; &gt; &amp;AICc_vals)</td></tr>
<tr class="memdesc:a2668b960858780f9b2389d17e32d8dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculeates best fit m/n for each channel these channels are ones with breaks.  <a href="#a2668b960858780f9b2389d17e32d8dd4">More...</a><br/></td></tr>
<tr class="separator:a2668b960858780f9b2389d17e32d8dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8eb3128cfa4606411e11186eb0f903b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#aa8eb3128cfa4606411e11186eb0f903b">search_for_best_fit_m_over_n_individual_channels_with_breaks_monte_carlo</a> (float A_0, int n_movern, float d_movern, float start_movern, int minimum_segment_length, float sigma, int target_skip, int target_nodes, int n_iterations, vector&lt; float &gt; &amp;m_over_n_values, vector&lt; vector&lt; float &gt; &gt; &amp;AICc_means, vector&lt; vector&lt; float &gt; &gt; &amp;AICc_stddev)</td></tr>
<tr class="memdesc:aa8eb3128cfa4606411e11186eb0f903b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the best fit m over n values of all the individual tributaries.  <a href="#aa8eb3128cfa4606411e11186eb0f903b">More...</a><br/></td></tr>
<tr class="separator:aa8eb3128cfa4606411e11186eb0f903b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d2c257a32adc5c9712d57065ad0b77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a40d2c257a32adc5c9712d57065ad0b77">monte_carlo_sample_river_network_for_best_fit_dchi</a> (float A_0, float m_over_n, int n_iterations, float fraction_dchi_for_variation, int minimum_segment_length, float sigma, int target_nodes_mainstem)</td></tr>
<tr class="memdesc:a40d2c257a32adc5c9712d57065ad0b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine uses a monte carlo approach to repeatedly sampling all the data in the channel network.  <a href="#a40d2c257a32adc5c9712d57065ad0b77">More...</a><br/></td></tr>
<tr class="separator:a40d2c257a32adc5c9712d57065ad0b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989b1415d9a5b973801d217dd0178ffa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a989b1415d9a5b973801d217dd0178ffa">monte_carlo_sample_river_network_for_best_fit</a> (float A_0, float m_over_n, int n_iterations, int mean_skip, int skip_range, int minimum_segment_length, float sigma)</td></tr>
<tr class="memdesc:a989b1415d9a5b973801d217dd0178ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monte carlo segment fitter.  <a href="#a989b1415d9a5b973801d217dd0178ffa">More...</a><br/></td></tr>
<tr class="separator:a989b1415d9a5b973801d217dd0178ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79b512d5e077f7b2e57ac682d214df8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#ac79b512d5e077f7b2e57ac682d214df8">monte_carlo_sample_river_network_for_best_fit_after_breaks</a> (float A_0, float m_over_n, int n_iterations, int skip, int minimum_segment_length, float sigma)</td></tr>
<tr class="memdesc:ac79b512d5e077f7b2e57ac682d214df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function samples the river network using monte carlo samplig but after breaking the channels.  <a href="#ac79b512d5e077f7b2e57ac682d214df8">More...</a><br/></td></tr>
<tr class="separator:ac79b512d5e077f7b2e57ac682d214df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4554437e321936e81532a290cc0637da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a4554437e321936e81532a290cc0637da">monte_carlo_split_channel</a> (float A_0, float m_over_n, int n_iterations, int target_skip, int target_nodes, int minimum_segment_length, float sigma, int chan, vector&lt; int &gt; &amp;break_nodes)</td></tr>
<tr class="memdesc:a4554437e321936e81532a290cc0637da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monte carlo segment fitter.  <a href="#a4554437e321936e81532a290cc0637da">More...</a><br/></td></tr>
<tr class="separator:a4554437e321936e81532a290cc0637da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f87a88e70f2632d8c6ec71cfca5cb47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a6f87a88e70f2632d8c6ec71cfca5cb47">monte_carlo_split_channel_colinear</a> (float A_0, float m_over_n, int n_iterations, int target_skip, int target_nodes, int minimum_segment_length, float sigma, vector&lt; float &gt; reverse_Chi, vector&lt; float &gt; reverse_Elevation, vector&lt; int &gt; &amp;break_nodes)</td></tr>
<tr class="memdesc:a6f87a88e70f2632d8c6ec71cfca5cb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses a monte carlo sampling approach to try and split channels.  <a href="#a6f87a88e70f2632d8c6ec71cfca5cb47">More...</a><br/></td></tr>
<tr class="separator:a6f87a88e70f2632d8c6ec71cfca5cb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd6e2b1867b51e0b2f6c494c51c9ed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a1fd6e2b1867b51e0b2f6c494c51c9ed6">split_all_channels</a> (float A_0, float m_over_n, int n_iterations, int target_skip, int target_nodes, int minimum_segment_length, float sigma)</td></tr>
<tr class="memdesc:a1fd6e2b1867b51e0b2f6c494c51c9ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function splits all the channels in one go.  <a href="#a1fd6e2b1867b51e0b2f6c494c51c9ed6">More...</a><br/></td></tr>
<tr class="separator:a1fd6e2b1867b51e0b2f6c494c51c9ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777176947c577e0446bdec68e5cbd0b1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a777176947c577e0446bdec68e5cbd0b1">calculate_AICc_after_breaks</a> (float A_0, float m_over_n, int skip, int minimum_segment_length, float sigma, int chan, vector&lt; int &gt; break_nodes, int &amp;n_total_segments, int &amp;n_total_nodes, float &amp;cumulative_MLE)</td></tr>
<tr class="memdesc:a777176947c577e0446bdec68e5cbd0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the AICc after breaking the channel.  <a href="#a777176947c577e0446bdec68e5cbd0b1">More...</a><br/></td></tr>
<tr class="separator:a777176947c577e0446bdec68e5cbd0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97633d0e7d23534b9016726f75bed61"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#af97633d0e7d23534b9016726f75bed61">calculate_AICc_after_breaks_monte_carlo</a> (float A_0, float m_over_n, int target_skip, int minimum_segment_length, float sigma, int chan, vector&lt; int &gt; break_nodes, int &amp;n_total_segments, int &amp;n_total_nodes, float &amp;cumulative_MLE, int n_iterations)</td></tr>
<tr class="memdesc:af97633d0e7d23534b9016726f75bed61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the AICc after breaking the channel.  <a href="#af97633d0e7d23534b9016726f75bed61">More...</a><br/></td></tr>
<tr class="separator:af97633d0e7d23534b9016726f75bed61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10002d162dfccb8308ef3b98db49fd4e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a10002d162dfccb8308ef3b98db49fd4e">calculate_AICc_after_breaks_colinear</a> (float A_0, float m_over_n, int skip, int minimum_segment_length, float sigma, vector&lt; float &gt; reverse_chi, vector&lt; float &gt; reverse_elevation, vector&lt; int &gt; break_nodes, int &amp;n_total_segments, int &amp;n_total_nodes, float &amp;cumulative_MLE)</td></tr>
<tr class="memdesc:a10002d162dfccb8308ef3b98db49fd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the AICc after breaking the channelwith a colinear dataset.  <a href="#a10002d162dfccb8308ef3b98db49fd4e">More...</a><br/></td></tr>
<tr class="separator:a10002d162dfccb8308ef3b98db49fd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f23b320c396be34ec8595abb5a35ff"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a87f23b320c396be34ec8595abb5a35ff">calculate_AICc_after_breaks_colinear_monte_carlo</a> (float A_0, float m_over_n, int skip, int minimum_segment_length, float sigma, vector&lt; float &gt; reverse_Chi, vector&lt; float &gt; reverse_Elevation, vector&lt; int &gt; break_nodes, int &amp;n_total_segments, int &amp;n_total_nodes, float &amp;cumulative_MLE, int n_iterations)</td></tr>
<tr class="memdesc:a87f23b320c396be34ec8595abb5a35ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the AICc after breaking the channelwith a colinear dataset.  <a href="#a87f23b320c396be34ec8595abb5a35ff">More...</a><br/></td></tr>
<tr class="separator:a87f23b320c396be34ec8595abb5a35ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff09ba74c63be9687cb9b8a7ca02d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#aaff09ba74c63be9687cb9b8a7ca02d4b">is_channel_long_enough_test</a> (int minimum_segment_length, int N)</td></tr>
<tr class="memdesc:aaff09ba74c63be9687cb9b8a7ca02d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine tests to see if channels are long enough to get a decent fitting from the segment finding algorithms.  <a href="#aaff09ba74c63be9687cb9b8a7ca02d4b">More...</a><br/></td></tr>
<tr class="separator:aaff09ba74c63be9687cb9b8a7ca02d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb2c0fbaebb3f594e83090e6c988df3"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#aedb2c0fbaebb3f594e83090e6c988df3">calculate_channel_heads</a> (int min_seg_length_for_channel_heads)</td></tr>
<tr class="memdesc:aedb2c0fbaebb3f594e83090e6c988df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function fits 2 segments to the chi-elevation data from first order basins and calculates the most likely position of the channel head - added by FC 28/06/13  <a href="#aedb2c0fbaebb3f594e83090e6c988df3">More...</a><br/></td></tr>
<tr class="separator:aedb2c0fbaebb3f594e83090e6c988df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0de035b285368c062fa2b0d20f25dc"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#afa0de035b285368c062fa2b0d20f25dc">get_m_means</a> ()</td></tr>
<tr class="memdesc:afa0de035b285368c062fa2b0d20f25dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the m_means for the channel network.  <a href="#afa0de035b285368c062fa2b0d20f25dc">More...</a><br/></td></tr>
<tr class="separator:afa0de035b285368c062fa2b0d20f25dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219f1f0f23e195ef23a760988ed7ff28"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a219f1f0f23e195ef23a760988ed7ff28">get_m_standard_deviations</a> ()</td></tr>
<tr class="memdesc:a219f1f0f23e195ef23a760988ed7ff28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the m_means for the channel network.  <a href="#a219f1f0f23e195ef23a760988ed7ff28">More...</a><br/></td></tr>
<tr class="separator:a219f1f0f23e195ef23a760988ed7ff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119b58bea8ceedfe486fa995c28b24c6"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a119b58bea8ceedfe486fa995c28b24c6">get_b_means</a> ()</td></tr>
<tr class="memdesc:a119b58bea8ceedfe486fa995c28b24c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the b_means for the channel network.  <a href="#a119b58bea8ceedfe486fa995c28b24c6">More...</a><br/></td></tr>
<tr class="separator:a119b58bea8ceedfe486fa995c28b24c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d02e92526872e4045d0dc8a20f51a30"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a4d02e92526872e4045d0dc8a20f51a30">get_b_standard_deviations</a> ()</td></tr>
<tr class="memdesc:a4d02e92526872e4045d0dc8a20f51a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the b_standard deviations for the channel network.  <a href="#a4d02e92526872e4045d0dc8a20f51a30">More...</a><br/></td></tr>
<tr class="separator:a4d02e92526872e4045d0dc8a20f51a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554eefff2ea0a3f5ed207b76f38be3d5"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a554eefff2ea0a3f5ed207b76f38be3d5">get_node_indices</a> ()</td></tr>
<tr class="memdesc:a554eefff2ea0a3f5ed207b76f38be3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the node_indices for the channel network.  <a href="#a554eefff2ea0a3f5ed207b76f38be3d5">More...</a><br/></td></tr>
<tr class="separator:a554eefff2ea0a3f5ed207b76f38be3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc0251684d4608ed63f5ee49ab68867"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a4dc0251684d4608ed63f5ee49ab68867">get_chis</a> ()</td></tr>
<tr class="memdesc:a4dc0251684d4608ed63f5ee49ab68867"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the chi coordinates for the channel network.  <a href="#a4dc0251684d4608ed63f5ee49ab68867">More...</a><br/></td></tr>
<tr class="separator:a4dc0251684d4608ed63f5ee49ab68867"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a230f1627c298aad3ef93e4963262e981"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a230f1627c298aad3ef93e4963262e981"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a230f1627c298aad3ef93e4963262e981">NRows</a></td></tr>
<tr class="memdesc:a230f1627c298aad3ef93e4963262e981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows. <br/></td></tr>
<tr class="separator:a230f1627c298aad3ef93e4963262e981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8420c7a45f1a6937ed325c96f22e6248"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8420c7a45f1a6937ed325c96f22e6248"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a8420c7a45f1a6937ed325c96f22e6248">NCols</a></td></tr>
<tr class="memdesc:a8420c7a45f1a6937ed325c96f22e6248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns. <br/></td></tr>
<tr class="separator:a8420c7a45f1a6937ed325c96f22e6248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54ca6d647ffb81c852e21033868ecf7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab54ca6d647ffb81c852e21033868ecf7"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#ab54ca6d647ffb81c852e21033868ecf7">XMinimum</a></td></tr>
<tr class="memdesc:ab54ca6d647ffb81c852e21033868ecf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum X coordinate. <br/></td></tr>
<tr class="separator:ab54ca6d647ffb81c852e21033868ecf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ea1c3dd5800456da705ae5423ae8c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7ea1c3dd5800456da705ae5423ae8c0"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#ae7ea1c3dd5800456da705ae5423ae8c0">YMinimum</a></td></tr>
<tr class="memdesc:ae7ea1c3dd5800456da705ae5423ae8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum Y coordinate. <br/></td></tr>
<tr class="separator:ae7ea1c3dd5800456da705ae5423ae8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bd203f75deb700b310890bf7ebed91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74bd203f75deb700b310890bf7ebed91"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a74bd203f75deb700b310890bf7ebed91">DataResolution</a></td></tr>
<tr class="memdesc:a74bd203f75deb700b310890bf7ebed91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data resolution. <br/></td></tr>
<tr class="separator:a74bd203f75deb700b310890bf7ebed91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba3e98f1c1d8f255f59a7e29ce30407"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afba3e98f1c1d8f255f59a7e29ce30407"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#afba3e98f1c1d8f255f59a7e29ce30407">NoDataValue</a></td></tr>
<tr class="memdesc:afba3e98f1c1d8f255f59a7e29ce30407"><td class="mdescLeft">&#160;</td><td class="mdescRight">No data value. <br/></td></tr>
<tr class="separator:afba3e98f1c1d8f255f59a7e29ce30407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817a9244564986203e7adb68ef1258c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a817a9244564986203e7adb68ef1258c2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a817a9244564986203e7adb68ef1258c2">I_should_calculate_chi</a></td></tr>
<tr class="memdesc:a817a9244564986203e7adb68ef1258c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This boolean lets the routine know if it is to calculate chi. <br/></td></tr>
<tr class="separator:a817a9244564986203e7adb68ef1258c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef6dd935db6a63674ef786b33a03675"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ef6dd935db6a63674ef786b33a03675"></a>
vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a9ef6dd935db6a63674ef786b33a03675">node_indices</a></td></tr>
<tr class="memdesc:a9ef6dd935db6a63674ef786b33a03675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node indices: used in conjunction with other LSD topographic tool objects and not necessary for standalone program. <br/></td></tr>
<tr class="separator:a9ef6dd935db6a63674ef786b33a03675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56320b150585e610a03c98da68244cec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56320b150585e610a03c98da68244cec"></a>
vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a56320b150585e610a03c98da68244cec">row_indices</a></td></tr>
<tr class="memdesc:a56320b150585e610a03c98da68244cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row indices: used in conjunction with other LSD topographic tool objects and not necessary for standalone program. <br/></td></tr>
<tr class="separator:a56320b150585e610a03c98da68244cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4b5f1862be520cc042e63d9021182c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b4b5f1862be520cc042e63d9021182c"></a>
vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a7b4b5f1862be520cc042e63d9021182c">col_indices</a></td></tr>
<tr class="memdesc:a7b4b5f1862be520cc042e63d9021182c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column indices: used in conjunction with other LSD topographic tool objects and not necessary for standalone program. <br/></td></tr>
<tr class="separator:a7b4b5f1862be520cc042e63d9021182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453ca401510b5bf27207e0819cedc4ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a453ca401510b5bf27207e0819cedc4ae"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a453ca401510b5bf27207e0819cedc4ae">elevations</a></td></tr>
<tr class="memdesc:a453ca401510b5bf27207e0819cedc4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The elevations along the channels. <br/></td></tr>
<tr class="separator:a453ca401510b5bf27207e0819cedc4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a9b8824b27d4a9e54833965676c87d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82a9b8824b27d4a9e54833965676c87d"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a82a9b8824b27d4a9e54833965676c87d">flow_distances</a></td></tr>
<tr class="memdesc:a82a9b8824b27d4a9e54833965676c87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow distances along channels. Used to integrate to arrive at chi. <br/></td></tr>
<tr class="separator:a82a9b8824b27d4a9e54833965676c87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e878ecd73c9be439c2a1314e222929"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26e878ecd73c9be439c2a1314e222929"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a26e878ecd73c9be439c2a1314e222929">drainage_areas</a></td></tr>
<tr class="memdesc:a26e878ecd73c9be439c2a1314e222929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drainage areas. <br/></td></tr>
<tr class="separator:a26e878ecd73c9be439c2a1314e222929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d4e4134339d7a5f21cf6983ba0860b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45d4e4134339d7a5f21cf6983ba0860b"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a45d4e4134339d7a5f21cf6983ba0860b">chis</a></td></tr>
<tr class="memdesc:a45d4e4134339d7a5f21cf6983ba0860b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The chi values for the channels. This data will be overwritten as m_over_n changes. <br/></td></tr>
<tr class="separator:a45d4e4134339d7a5f21cf6983ba0860b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d0e3c4b2beae4c65491b86049d01c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50d0e3c4b2beae4c65491b86049d01c1"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a50d0e3c4b2beae4c65491b86049d01c1">node_on_receiver_channel</a></td></tr>
<tr class="memdesc:a50d0e3c4b2beae4c65491b86049d01c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the node on the reciever channel where the tributary enters the channel. Used to find the downstream chi value of a channel. <br/></td></tr>
<tr class="separator:a50d0e3c4b2beae4c65491b86049d01c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53b863878d2b361c1a48f71fab43ef8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa53b863878d2b361c1a48f71fab43ef8"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#aa53b863878d2b361c1a48f71fab43ef8">receiver_channel</a></td></tr>
<tr class="memdesc:aa53b863878d2b361c1a48f71fab43ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the channel that the tributary enters. <br/></td></tr>
<tr class="separator:aa53b863878d2b361c1a48f71fab43ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaba67fe1ba8ddbec9a59dca82307c2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaba67fe1ba8ddbec9a59dca82307c2b"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#aeaba67fe1ba8ddbec9a59dca82307c2b">m_over_n_for_fitted_data</a></td></tr>
<tr class="memdesc:aeaba67fe1ba8ddbec9a59dca82307c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This stores the m over n value use to generate the means and standard deviations of the network properties. <br/></td></tr>
<tr class="separator:aeaba67fe1ba8ddbec9a59dca82307c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e400323d96f9236d219f957ff85865f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e400323d96f9236d219f957ff85865f"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a0e400323d96f9236d219f957ff85865f">A_0_for_fitted_data</a></td></tr>
<tr class="memdesc:a0e400323d96f9236d219f957ff85865f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This stored the A_0 value. <br/></td></tr>
<tr class="separator:a0e400323d96f9236d219f957ff85865f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3642ce7b83b991886f3713aaf20f6150"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3642ce7b83b991886f3713aaf20f6150"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a3642ce7b83b991886f3713aaf20f6150">is_tributary_long_enough</a></td></tr>
<tr class="memdesc:a3642ce7b83b991886f3713aaf20f6150"><td class="mdescLeft">&#160;</td><td class="mdescRight">This vector is the same size as the number of channels and is 1 if the channel analysis n_nodes &gt; 3* minimum_segment_length. <br/></td></tr>
<tr class="separator:a3642ce7b83b991886f3713aaf20f6150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f7992d61e8939d4f4cadc1164dfe09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35f7992d61e8939d4f4cadc1164dfe09"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a35f7992d61e8939d4f4cadc1164dfe09">chi_m_means</a></td></tr>
<tr class="memdesc:a35f7992d61e8939d4f4cadc1164dfe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of chi_m means. <br/></td></tr>
<tr class="separator:a35f7992d61e8939d4f4cadc1164dfe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaffa23b0fd54d7518b593c181232eac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaffa23b0fd54d7518b593c181232eac"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#afaffa23b0fd54d7518b593c181232eac">chi_m_standard_deviations</a></td></tr>
<tr class="memdesc:afaffa23b0fd54d7518b593c181232eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of chi_m standard deviations. <br/></td></tr>
<tr class="separator:afaffa23b0fd54d7518b593c181232eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ed41b26e9fd8d4732794e74e17c615"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45ed41b26e9fd8d4732794e74e17c615"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a45ed41b26e9fd8d4732794e74e17c615">chi_m_standard_errors</a></td></tr>
<tr class="memdesc:a45ed41b26e9fd8d4732794e74e17c615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of chi_m standard errors. <br/></td></tr>
<tr class="separator:a45ed41b26e9fd8d4732794e74e17c615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb7e212e1ba0a46a23aa2ab8c40dd50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cb7e212e1ba0a46a23aa2ab8c40dd50"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a8cb7e212e1ba0a46a23aa2ab8c40dd50">chi_b_means</a></td></tr>
<tr class="memdesc:a8cb7e212e1ba0a46a23aa2ab8c40dd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of chi_b means. <br/></td></tr>
<tr class="separator:a8cb7e212e1ba0a46a23aa2ab8c40dd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e3793d4d717b3f81eb09390e326621"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19e3793d4d717b3f81eb09390e326621"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a19e3793d4d717b3f81eb09390e326621">chi_b_standard_deviations</a></td></tr>
<tr class="memdesc:a19e3793d4d717b3f81eb09390e326621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of chi_b standard deviations. <br/></td></tr>
<tr class="separator:a19e3793d4d717b3f81eb09390e326621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137632b5ac7204f552b84acd8e6a69f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a137632b5ac7204f552b84acd8e6a69f8"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a137632b5ac7204f552b84acd8e6a69f8">chi_b_standard_errors</a></td></tr>
<tr class="memdesc:a137632b5ac7204f552b84acd8e6a69f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of chi_b standard errors. <br/></td></tr>
<tr class="separator:a137632b5ac7204f552b84acd8e6a69f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e774348fb4b94dd6ff9764fd2e145a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09e774348fb4b94dd6ff9764fd2e145a"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a09e774348fb4b94dd6ff9764fd2e145a">all_fitted_elev_means</a></td></tr>
<tr class="memdesc:a09e774348fb4b94dd6ff9764fd2e145a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of fitted elevation means. <br/></td></tr>
<tr class="separator:a09e774348fb4b94dd6ff9764fd2e145a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fe758d4c0a826e2ab5118426ddec91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5fe758d4c0a826e2ab5118426ddec91"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#aa5fe758d4c0a826e2ab5118426ddec91">all_fitted_elev_standard_deviations</a></td></tr>
<tr class="memdesc:aa5fe758d4c0a826e2ab5118426ddec91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of fitted elevation standard deviations. <br/></td></tr>
<tr class="separator:aa5fe758d4c0a826e2ab5118426ddec91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeabb5454bd4159eaa4b7224da1e814c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afeabb5454bd4159eaa4b7224da1e814c"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#afeabb5454bd4159eaa4b7224da1e814c">all_fitted_elev_standard_errors</a></td></tr>
<tr class="memdesc:afeabb5454bd4159eaa4b7224da1e814c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of fitted elevation standard errors. <br/></td></tr>
<tr class="separator:afeabb5454bd4159eaa4b7224da1e814c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2571debe79174798e0543f7734494d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f2571debe79174798e0543f7734494d"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a7f2571debe79174798e0543f7734494d">chi_DW_means</a></td></tr>
<tr class="memdesc:a7f2571debe79174798e0543f7734494d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of Durbin-Watson means. <br/></td></tr>
<tr class="separator:a7f2571debe79174798e0543f7734494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfff9ae90e98dd091f05e55dd0cc2ec4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfff9ae90e98dd091f05e55dd0cc2ec4"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#adfff9ae90e98dd091f05e55dd0cc2ec4">chi_DW_standard_deviations</a></td></tr>
<tr class="memdesc:adfff9ae90e98dd091f05e55dd0cc2ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of Durbin-Watson standard deviations. <br/></td></tr>
<tr class="separator:adfff9ae90e98dd091f05e55dd0cc2ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59d7685676eaf71fcb57983f1c69a13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae59d7685676eaf71fcb57983f1c69a13"></a>
vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#ae59d7685676eaf71fcb57983f1c69a13">chi_DW_standard_errors</a></td></tr>
<tr class="memdesc:ae59d7685676eaf71fcb57983f1c69a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of Durbin-Watson standard errors. <br/></td></tr>
<tr class="separator:ae59d7685676eaf71fcb57983f1c69a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4597e8e28432e2c3ec3a1b25e14485"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a4597e8e28432e2c3ec3a1b25e14485"></a>
vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#a9a4597e8e28432e2c3ec3a1b25e14485">n_data_points_used_in_stats</a></td></tr>
<tr class="memdesc:a9a4597e8e28432e2c3ec3a1b25e14485"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parameters are generated using a monte carlo approach and not all nodes will have the same number of data points, so the number of data points is stored. <br/></td></tr>
<tr class="separator:a9a4597e8e28432e2c3ec3a1b25e14485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9e41d48aea4fe364e4855a6af50e7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca9e41d48aea4fe364e4855a6af50e7a"></a>
vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_chi_network.html#aca9e41d48aea4fe364e4855a6af50e7a">break_nodes_vecvec</a></td></tr>
<tr class="memdesc:aca9e41d48aea4fe364e4855a6af50e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This vector holds the vectors containing the node locations of breaks in the segments. <br/></td></tr>
<tr class="separator:aca9e41d48aea4fe364e4855a6af50e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This object is used to examine a network of channels in chi space. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6ee781f39d789a71a5eb2e87f48d5103"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDChiNetwork::LSDChiNetwork </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>channel_network_fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crate routine to make a <a class="el" href="class_l_s_d_chi_network.html" title="This object is used to examine a network of channels in chi space. ">LSDChiNetwork</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_network_fname</td><td>Filename. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a777176947c577e0446bdec68e5cbd0b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::calculate_AICc_after_breaks </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>break_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_total_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_total_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>cumulative_MLE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the AICc after breaking the channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">skip</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">chan</td><td></td></tr>
    <tr><td class="paramname">break_nodes</td><td></td></tr>
    <tr><td class="paramname">n_total_segments</td><td></td></tr>
    <tr><td class="paramname">n_total_nodes</td><td></td></tr>
    <tr><td class="paramname">cumulative_MLE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AICc value </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/06/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a10002d162dfccb8308ef3b98db49fd4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::calculate_AICc_after_breaks_colinear </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>reverse_chi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>reverse_elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>break_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_total_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_total_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>cumulative_MLE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the AICc after breaking the channelwith a colinear dataset. </p>
<p>The reverse_chi and reverse_elevation data has to be provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">skip</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">reverse_chi</td><td></td></tr>
    <tr><td class="paramname">reverse_elevation</td><td></td></tr>
    <tr><td class="paramname">break_nodes</td><td></td></tr>
    <tr><td class="paramname">n_total_segments</td><td></td></tr>
    <tr><td class="paramname">n_total_nodes</td><td></td></tr>
    <tr><td class="paramname">cumulative_MLE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AICc value </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/06/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a87f23b320c396be34ec8595abb5a35ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDChiNetwork::calculate_AICc_after_breaks_colinear_monte_carlo </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>reverse_Chi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>reverse_Elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>break_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_total_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_total_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>cumulative_MLE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the AICc after breaking the channelwith a colinear dataset. </p>
<p>The reverse_chi and reverse_elevation data has to be provided. It uses a monte carlo scheme and returns a vector with all of the AICc values calcluated from the analyses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">skip</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">reverse_Chi</td><td></td></tr>
    <tr><td class="paramname">reverse_Elevation</td><td></td></tr>
    <tr><td class="paramname">break_nodes</td><td></td></tr>
    <tr><td class="paramname">n_total_segments</td><td></td></tr>
    <tr><td class="paramname">n_total_nodes</td><td></td></tr>
    <tr><td class="paramname">cumulative_MLE</td><td></td></tr>
    <tr><td class="paramname">n_iterations</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AICc value </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/06/13 </dd></dl>

</div>
</div>
<a class="anchor" id="af97633d0e7d23534b9016726f75bed61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDChiNetwork::calculate_AICc_after_breaks_monte_carlo </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>break_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_total_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_total_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>cumulative_MLE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the AICc after breaking the channel. </p>
<p>It does this for n_iterations and returns a vector with all of the AICc values for each iteration reported. This can then be used to calculate the statistics of the AICc to tell if the minimum AICc is significantly different from the other AICc values for different values of m/n </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">target_skip</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">chan</td><td></td></tr>
    <tr><td class="paramname">break_nodes</td><td></td></tr>
    <tr><td class="paramname">n_total_segments</td><td></td></tr>
    <tr><td class="paramname">n_total_nodes</td><td></td></tr>
    <tr><td class="paramname">cumulative_MLE</td><td></td></tr>
    <tr><td class="paramname">n_iterations</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AICc value </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/06/13 </dd></dl>

</div>
</div>
<a class="anchor" id="aedb2c0fbaebb3f594e83090e6c988df3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDChiNetwork::calculate_channel_heads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_seg_length_for_channel_heads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function fits 2 segments to the chi-elevation data from first order basins and calculates the most likely position of the channel head - added by FC 28/06/13 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_seg_length_for_channel_heads</td><td>Minimum number of nodes used for segment fitting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with channel head locations </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Fiona Clubb </dd></dl>
<dl class="section date"><dt>Date</dt><dd>03/09/2013</dd></dl>
<p>=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= Calculate channel head locations using <a class="el" href="class_l_s_d_chi_network.html" title="This object is used to examine a network of channels in chi space. ">LSDChiNetwork</a>.</p>
<p>Fitting segments to the chi-elevation data of the main stem. We assume that the profile is made up of 2 segments in chi-space: a linear channel segment and a non-linear hillslope segment. We loop through the possible combinations of segment lengths, performing a linear regression to calculate the r^2 and DW of each segment length. We then calculate a test value: r^2 of the channel segment - ((DW of the hillslope segment - 2)/2). This value will vary between 0 and 1. The maximum test_value will give the best fit channel and hillslope segments. Need to get the best fit m_over_n value and calculate the chi profile of the main stem first. Will output the chi and elevation values of the predicted channel head location. Parameters: min_seg_length_for_channel_heads (length used for fitting segments to the chi- elevation profile, a value of 10 is suggested) Return value: Array with channel head locations FC 03/09/2013 </p>

</div>
</div>
<a class="anchor" id="add215f08eeb56ba9fef26e39bf8755c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::calculate_chi </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the chi values for the channel network using the rectangle rule. </p>
<p>Note: the entire network must be caluculated because the chi values of the tributaries depend on the chi values of the mainstem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td>A_0 value. </td></tr>
    <tr><td class="paramname">m_over_n</td><td>m over n ratio. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a0ee5c89d6ceed8d57fd7235deda3168b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::calculate_optimal_chi_spacing </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calucaltes the chi spacing of the main stem channel (the longest channel). </p>
<p>The maximum length of the dataset will be in the main stem so this will determine the target spacing of all the tributaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_nodes</td><td>Node index of the target node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optimal chi spacing. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="ab9c58cf0962448576f53bce38c8f94fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDChiNetwork::calculate_skip </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calucaltes the skip parameter of the main stem (the longest channel). </p>
<p>The maximum length of the dataset will be in the main stem so this will determine the target spacing of all the tributaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_nodes</td><td>Node index of the target node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Skip value. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/06/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a1f0f5f45fddacd610e411d00286c3d3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDChiNetwork::calculate_skip </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted_chis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calucaltes the skip parameter based on a vector of chi values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_nodes</td><td>Node index of the target node. </td></tr>
    <tr><td class="paramname">sorted_chis</td><td>Vector of chi values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Skip value. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/06/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a0f2e247951b2171f559c4ab0c12e2fb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDChiNetwork::calculate_skip </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calucaltes the skip parameter of a give channel. </p>
<p>The maximum length of the dataset will be in the main stem so this will determine the target spacing of all the tributaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_nodes</td><td>Node index of the target node. </td></tr>
    <tr><td class="paramname">channel_number</td><td>The channel to be analysed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Skip value. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="adc44bb761b78a89aa1f4712eaf4f378c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDChiNetwork::data_to_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>data_member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine for returning calculated data to an array. </p>
<p>It includes a switch that tells the function what data member to write to the array code for data members: <br/>
<br/>
1 elevations <br/>
2 chis <br/>
3 chi_m_means <br/>
4 chi_m_standard_deviations<br/>
5 chi_m_standard_errors<br/>
6 chi_b_means <br/>
7 chi_b_standard_deviations<br/>
8 chi_b_standard_errors <br/>
9 chi_DW_means <br/>
10 chi_DW_standard_deviations <br/>
11 chi_DW_standard_errors <br/>
12 all_fitted_DW_means <br/>
13 all_fitted_DW_standard_deviations <br/>
14 all_fitted_DW_standard_errors <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_member</td><td>Switch to select data to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of data. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a7f2699db1455aa6a07790214640ab99e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::extend_tributaries_to_outlet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This extends the tributary channels all the way to the outlet. </p>
<p>In its current version this only works if the tributaries all drain to the mainstem. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a6f283a68143500231244d3c87f969570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::find_most_likeley_segments </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>DW_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>thinned_chi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>thinned_elev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>fitted_elev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>these_segment_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>this_MLE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>this_n_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_data_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>this_AIC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>this_AICc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the most likely channel segments for a particular channel. </p>
<p>This function replaces the b, m, r2 and DW values of each segment into vectors it also returns the fitted elevation and the index into the original channel (since this is done with thinned data). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The index into the channel. </td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>is how many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>is the standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">N</td><td></td></tr>
    <tr><td class="paramname">b_vec</td><td></td></tr>
    <tr><td class="paramname">m_vec</td><td></td></tr>
    <tr><td class="paramname">r2_vec</td><td></td></tr>
    <tr><td class="paramname">DW_vec</td><td></td></tr>
    <tr><td class="paramname">thinned_chi</td><td></td></tr>
    <tr><td class="paramname">thinned_elev</td><td></td></tr>
    <tr><td class="paramname">fitted_elev</td><td></td></tr>
    <tr><td class="paramname">node_reference</td><td></td></tr>
    <tr><td class="paramname">these_segment_lengths</td><td></td></tr>
    <tr><td class="paramname">this_MLE</td><td></td></tr>
    <tr><td class="paramname">this_n_segments</td><td></td></tr>
    <tr><td class="paramname">n_data_nodes</td><td></td></tr>
    <tr><td class="paramname">this_AIC</td><td></td></tr>
    <tr><td class="paramname">this_AICc</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="ab1cf6bcc46dac34a3e98808c74d8b54a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::find_most_likeley_segments_dchi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dchi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>DW_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>thinned_chi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>thinned_elev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>fitted_elev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>these_segment_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>this_MLE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>this_n_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_data_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>this_AIC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>this_AICc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the most likely channel segments for a particular channel. </p>
<p>This function replaces the b, m, r2 and DW values of each segment into vectors it also returns the fitted elevation and the index into the original channel (since this is done with thinned data). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The index into the channel. </td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>is how many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>is the standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">dchi</td><td></td></tr>
    <tr><td class="paramname">b_vec</td><td></td></tr>
    <tr><td class="paramname">m_vec</td><td></td></tr>
    <tr><td class="paramname">r2_vec</td><td></td></tr>
    <tr><td class="paramname">DW_vec</td><td></td></tr>
    <tr><td class="paramname">thinned_chi</td><td></td></tr>
    <tr><td class="paramname">thinned_elev</td><td></td></tr>
    <tr><td class="paramname">fitted_elev</td><td></td></tr>
    <tr><td class="paramname">node_reference</td><td></td></tr>
    <tr><td class="paramname">these_segment_lengths</td><td></td></tr>
    <tr><td class="paramname">this_MLE</td><td></td></tr>
    <tr><td class="paramname">this_n_segments</td><td></td></tr>
    <tr><td class="paramname">n_data_nodes</td><td></td></tr>
    <tr><td class="paramname">this_AIC</td><td></td></tr>
    <tr><td class="paramname">this_AICc</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a6f4dafa43ab33c310d4d2df3605672f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::find_most_likeley_segments_monte_carlo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mean_skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>DW_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>thinned_chi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>thinned_elev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>fitted_elev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>these_segment_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>this_MLE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>this_n_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_data_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>this_AIC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>this_AICc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets the most likely segments but uses the monte carlo data thinning method. </p>
<p>The expectation is that this will be used repeatedly on channels to generate statistics of the best fit segments by individual nodes in the channel network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The index into the channel. </td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>is how many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>is the standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">mean_skip</td><td></td></tr>
    <tr><td class="paramname">skip_range</td><td></td></tr>
    <tr><td class="paramname">b_vec</td><td></td></tr>
    <tr><td class="paramname">m_vec</td><td></td></tr>
    <tr><td class="paramname">r2_vec</td><td></td></tr>
    <tr><td class="paramname">DW_vec</td><td></td></tr>
    <tr><td class="paramname">thinned_chi</td><td></td></tr>
    <tr><td class="paramname">thinned_elev</td><td></td></tr>
    <tr><td class="paramname">fitted_elev</td><td></td></tr>
    <tr><td class="paramname">node_reference</td><td></td></tr>
    <tr><td class="paramname">these_segment_lengths</td><td></td></tr>
    <tr><td class="paramname">this_MLE</td><td></td></tr>
    <tr><td class="paramname">this_n_segments</td><td></td></tr>
    <tr><td class="paramname">n_data_nodes</td><td></td></tr>
    <tr><td class="paramname">this_AIC</td><td></td></tr>
    <tr><td class="paramname">this_AICc</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a031f52243e13595729a01ce073fb0784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::find_most_likeley_segments_monte_carlo_dchi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mean_dchi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>variation_dchi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>DW_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>thinned_chi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>thinned_elev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>fitted_elev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>these_segment_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>this_MLE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>this_n_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>n_data_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>this_AIC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>this_AICc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets the most likely segments but uses the monte carlo data thinning method. </p>
<p>The mean_dchi is the mean value of dchi, and the variation is how much the chi chan vary, such that minimum_dchi = dchi-variation_dchi. The expectation is that this will be used repeatedly on channels to generate statistics of the best fit segments by individual nodes in the channel network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The index into the channel. </td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>is how many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>is the standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">mean_dchi</td><td></td></tr>
    <tr><td class="paramname">variation_dchi</td><td></td></tr>
    <tr><td class="paramname">b_vec</td><td></td></tr>
    <tr><td class="paramname">m_vec</td><td></td></tr>
    <tr><td class="paramname">r2_vec</td><td></td></tr>
    <tr><td class="paramname">DW_vec</td><td></td></tr>
    <tr><td class="paramname">thinned_chi</td><td></td></tr>
    <tr><td class="paramname">thinned_elev</td><td></td></tr>
    <tr><td class="paramname">fitted_elev</td><td></td></tr>
    <tr><td class="paramname">node_reference</td><td></td></tr>
    <tr><td class="paramname">these_segment_lengths</td><td></td></tr>
    <tr><td class="paramname">this_MLE</td><td></td></tr>
    <tr><td class="paramname">this_n_segments</td><td></td></tr>
    <tr><td class="paramname">n_data_nodes</td><td></td></tr>
    <tr><td class="paramname">this_AIC</td><td></td></tr>
    <tr><td class="paramname">this_AICc</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a119b58bea8ceedfe486fa995c28b24c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt;float&gt; &gt; LSDChiNetwork::get_b_means </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This gets the b_means for the channel network. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors with b means @ author SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24/05/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a4d02e92526872e4045d0dc8a20f51a30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt;float&gt; &gt; LSDChiNetwork::get_b_standard_deviations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This gets the b_standard deviations for the channel network. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors with b tandard deviations @ author SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24/05/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a4dc0251684d4608ed63f5ee49ab68867"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt;float&gt; &gt; LSDChiNetwork::get_chis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This gets the chi coordinates for the channel network. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors with m means @ author DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24/03/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a67ccd054331be70dca228b11dfb6136d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::get_DataResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Data resolution as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="afa0de035b285368c062fa2b0d20f25dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; float &gt; &gt; LSDChiNetwork::get_m_means </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets the m_means for the channel network. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors with m means @ author FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/08/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a219f1f0f23e195ef23a760988ed7ff28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt;float&gt; &gt; LSDChiNetwork::get_m_standard_deviations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This gets the m_means for the channel network. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors with m means @ author FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/08/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a5a9019225dd258856c5747a8980a5146"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDChiNetwork::get_n_channels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of channels. </dd></dl>

</div>
</div>
<a class="anchor" id="aa53a17a937ebf4af809115adf10dd2b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDChiNetwork::get_NCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of columns as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ad67b433ac8eaa806badce312805ba9b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDChiNetwork::get_NoDataValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>No Data Value as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a554eefff2ea0a3f5ed207b76f38be3d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt;int&gt; &gt; LSDChiNetwork::get_node_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This gets the node_indices for the channel network. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors with m means @ author DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24/03/15 </dd></dl>

</div>
</div>
<a class="anchor" id="afb9ac610a3f1dd4b66226e6666853bcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDChiNetwork::get_NRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of rows as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a496a8f840819afe403cb7a41d89d08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::get_XMinimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Minimum X coordinate as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ae51377fd181e67a8b28ad61774b43927"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::get_YMinimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Minimum Y coordinate as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="aaff09ba74c63be9687cb9b8a7ca02d4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::is_channel_long_enough_test </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine tests to see if channels are long enough to get a decent fitting from the segment finding algorithms. </p>
<p>Writes to the is_tributary_long_enough vector. If this equals 1, the channel is long enough. If it is zero the channel is not long enough. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">N</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a989b1415d9a5b973801d217dd0178ffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::monte_carlo_sample_river_network_for_best_fit </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mean_skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Monte carlo segment fitter. </p>
<p>This takes a fixed m_over_n value and then samples the indivudal nodes in the full channel profile to repeadetly get the best fit segments on thinned data. the m, b fitted elevation, r^2 and DW statistic are all stored for every iteration on every node. These can then be queried later for mean, standard deviation and standard error information <br/>
<br/>
 the fraction_dchi_for_variation is the fration of the optimal dchi that dchi can vary over. So for example if this = 0.4 then the variation of dchi will be 0.4*mean_dchi and the minimum dchi will be min_dchi = (1-0.4)*mean_dchi <br/>
<br/>
 Note: this is <em>extremely</em> computationally and data intensive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">n_iterations</td><td></td></tr>
    <tr><td class="paramname">mean_skip</td><td></td></tr>
    <tr><td class="paramname">skip_range</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="ac79b512d5e077f7b2e57ac682d214df8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::monte_carlo_sample_river_network_for_best_fit_after_breaks </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function samples the river network using monte carlo samplig but after breaking the channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">n_iterations</td><td></td></tr>
    <tr><td class="paramname">skip</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a40d2c257a32adc5c9712d57065ad0b77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::monte_carlo_sample_river_network_for_best_fit_dchi </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fraction_dchi_for_variation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes_mainstem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine uses a monte carlo approach to repeatedly sampling all the data in the channel network. </p>
<p>Uses a reduced number of data elements and then populates each channel node with a distribution of m, b and fitted elevation values. These then can be averaged and details of their variation calculated. <br/>
This is based on a fixed value of dchi </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">n_iterations</td><td></td></tr>
    <tr><td class="paramname">fraction_dchi_for_variation</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">target_nodes_mainstem</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a4554437e321936e81532a290cc0637da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::monte_carlo_split_channel </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>break_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Monte carlo segment fitter. </p>
<p>This takes a fixed m_over_n value and then samples the indivudal nodes in the full channel profile to repeadetly get the best fit segments on thinned data. the m, b fitted elevation, r^2 and DW statistic are all stored for every iteration on every node. These can then be queried later for mean, standard deviation and standard error information. <br/>
<br/>
 The break nodes vector tells the algorithm where the breaks in the channel occur this function is called repeatedly until the target skip equals the all of the this_skip values. <br/>
<br/>
This function continues to split the channel into segments until the target skip is achieved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">n_iterations</td><td></td></tr>
    <tr><td class="paramname">target_skip</td><td></td></tr>
    <tr><td class="paramname">target_nodes</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">chan</td><td></td></tr>
    <tr><td class="paramname">break_nodes</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a6f87a88e70f2632d8c6ec71cfca5cb47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::monte_carlo_split_channel_colinear </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>reverse_Chi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>reverse_Elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>break_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function uses a monte carlo sampling approach to try and split channels. </p>
<p>The channel is sampled at the target skipping interval. It does it with a colinear dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">n_iterations</td><td></td></tr>
    <tr><td class="paramname">target_skip</td><td></td></tr>
    <tr><td class="paramname">target_nodes</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">reverse_Chi</td><td></td></tr>
    <tr><td class="paramname">break_nodes</td><td></td></tr>
    <tr><td class="paramname">reverse_Elevation</td><td></td></tr>
    <tr><td class="paramname">break_nodes</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a801b143b9a1c5e7af16c4432ad4465ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::print_channel_details_to_file </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print channel details to file for bug checking. </p>
<p>Format of file: <br/>
<br/>
 channel_number &lt;&lt; " " &lt;&lt; receiver_channel[channel_number] &lt;&lt; " " &lt;&lt; node_on_receiver_channel[channel_number] &lt;&lt; " " &lt;&lt; node[i] &lt;&lt; " " &lt;&lt; row[i] &lt;&lt; " " &lt;&lt; col[i] &lt;&lt; " " &lt;&lt; flow_distance[i] &lt;&lt; " " &lt;&lt; chi[i] &lt;&lt; " " &lt;&lt; elevation[i] &lt;&lt; " " &lt;&lt; drainage_area[i] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>Output filename. </td></tr>
    <tr><td class="paramname">A_0</td><td>A_0 value. </td></tr>
    <tr><td class="paramname">m_over_n</td><td>m over n ratio. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a5f8f28e19f2ce623f95b2926d3c5e3bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::print_channel_details_to_file_full_fitted </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints the details of all channels to a file. </p>
<p>It includes data from monte carlo fitting. Format is: <br/>
<br/>
A_0 m_over_n channel_number node_on_receiver_channel node_index row col flow_distance chi elevation darainage_area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>Output filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a0bc034f50d2379870289ce318bd836f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::print_channel_details_to_file_full_fitted </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints the details of all channels to a file. </p>
<p>It includes data from monte carlo fitting. Format is: <br/>
<br/>
A_0 m_over_n channel_number node_on_receiver_channel node_index row col flow_distance chi elevation darainage_area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>Output filename. </td></tr>
    <tr><td class="paramname">target_nodes</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a60f5ad9579df2c6caf94748bfdd1c52e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::print_channel_details_to_file_full_fitted_for_ArcMap </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints the details of all channels to a csv file that can be ingested by ArcMap. </p>
<p>It includes data from monte carlo fitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>Output filename, which has _for_Arc automatically appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>28/02/14 </dd></dl>

</div>
</div>
<a class="anchor" id="ad0e61b8661b819316ea7cf1149b2ce0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::print_channel_details_to_screen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print channel details to screen for bug checking. </p>
<p>Format of file: <br/>
<br/>
 channel_number &lt;&lt; " " &lt;&lt; receiver_channel[channel_number] &lt;&lt; " " &lt;&lt; node_on_receiver_channel[channel_number] &lt;&lt; " " &lt;&lt; node[i] &lt;&lt; " " &lt;&lt; row[i] &lt;&lt; " " &lt;&lt; col[i] &lt;&lt; " " &lt;&lt; flow_distance[i] &lt;&lt; " " &lt;&lt; chi[i] &lt;&lt; " " &lt;&lt; elevation[i] &lt;&lt; " " &lt;&lt; drainage_area[i] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_number</td><td>Channel to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a0d94d12fb29404329296edf6e7500f57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::search_for_best_fit_m_over_n </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes_mainstem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The master routine for calculating the best fit m over n values for a channel network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">n_movern</td><td></td></tr>
    <tr><td class="paramname">d_movern</td><td></td></tr>
    <tr><td class="paramname">start_movern</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">target_nodes_mainstem</td><td></td></tr>
    <tr><td class="paramname">fname</td><td>Output filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Best fit m over n. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a72b78169a4d937bec6a973d5393d9081"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::search_for_best_fit_m_over_n_colinearity_test </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_over_n_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>AICc_mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>AICc_sdtd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function looks for the best fit values of m over n by simply testing for the least variation in the tributaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">n_movern</td><td></td></tr>
    <tr><td class="paramname">d_movern</td><td></td></tr>
    <tr><td class="paramname">start_movern</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">target_nodes</td><td></td></tr>
    <tr><td class="paramname">n_iterations</td><td></td></tr>
    <tr><td class="paramname">m_over_n_values</td><td></td></tr>
    <tr><td class="paramname">AICc_mean</td><td></td></tr>
    <tr><td class="paramname">AICc_sdtd</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Best fit m over n. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="ad4e13e824b47c3071cd63fce9d922421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::search_for_best_fit_m_over_n_colinearity_test_with_breaks </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_over_n_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>AICc_mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>AICc_sdtd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Monte_Carlo_switch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculeates best fit m/n using the collinearity test <br/>
 these channels are ones with breaks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td>float the reference area </td></tr>
    <tr><td class="paramname">n_movern</td><td>int the number of m over n ratios to iterate through </td></tr>
    <tr><td class="paramname">d_movern</td><td>float the change in m/n in each iterations </td></tr>
    <tr><td class="paramname">start_movern</td><td>float the starting value of m/n </td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">target_skip</td><td>int the mean skipping value </td></tr>
    <tr><td class="paramname">target_nodes</td><td>int the target number of nodes in a break </td></tr>
    <tr><td class="paramname">n_iterations</td><td>int the number of iterations </td></tr>
    <tr><td class="paramname">m_over_n_values</td><td>vector&lt;float&gt;&amp; this gets written, it contains the m/n values for the run </td></tr>
    <tr><td class="paramname">AICc_mean</td><td>vector&lt;float&gt; gets written, the mean values of the AICc for each m/n </td></tr>
    <tr><td class="paramname">AICc_sdtd</td><td>vector&lt;float&gt; gets written, the standard deviation values of the AICc for each m/n </td></tr>
    <tr><td class="paramname">Monte_Carlo_switch</td><td>int if 1, run the code using the iterative Monte Carlo scheme </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Best fit m over n. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/07/13 </dd></dl>
<p>for (int i = 0; i&lt; int(movn_values.size()); i++) </p>

</div>
</div>
<a class="anchor" id="a21fe8779ad0575c4b11eae5e4178ca62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::search_for_best_fit_m_over_n_dchi </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes_mainstem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The master routine for calculating the best fit m over n values for a channel network, based on a fixed value of dchi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">n_movern</td><td></td></tr>
    <tr><td class="paramname">d_movern</td><td></td></tr>
    <tr><td class="paramname">start_movern</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">target_nodes_mainstem</td><td></td></tr>
    <tr><td class="paramname">fname</td><td>Output filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Best fit m over n. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a2668b960858780f9b2389d17e32d8dd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::search_for_best_fit_m_over_n_individual_channels_with_breaks </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_over_n_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>AICc_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculeates best fit m/n for each channel these channels are ones with breaks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td>float the reference area</td></tr>
  </table>
  </dd>
</dl>
<p>this does not report variability of the AICc values and so should not be used, instead <br/>
 use the Monte Carlo version <br/>
 retained in case you want rapid calculation of best fit m/n </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_movern</td><td>int the number of m over n ratios to iterate through </td></tr>
    <tr><td class="paramname">d_movern</td><td>float the change in m/n in each iterations </td></tr>
    <tr><td class="paramname">start_movern</td><td>float the starting value of m/n </td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">target_skip</td><td>int the mean skipping value </td></tr>
    <tr><td class="paramname">target_nodes</td><td>int the target number of nodes in a break </td></tr>
    <tr><td class="paramname">n_iterations</td><td>int the number of iterations </td></tr>
    <tr><td class="paramname">m_over_n_values</td><td>vector&lt;float&gt;&amp; this gets written, it contains the m/n values for the run </td></tr>
    <tr><td class="paramname">AICc_vals</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Best fit m over n. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="aa8eb3128cfa4606411e11186eb0f903b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::search_for_best_fit_m_over_n_individual_channels_with_breaks_monte_carlo </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_over_n_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>AICc_means</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>AICc_stddev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets the best fit m over n values of all the individual tributaries. </p>
<p>It uses a monte carlo appraoach so all tributaries have both the mean and the variability of the AICc values reported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td>float the reference area </td></tr>
    <tr><td class="paramname">n_movern</td><td>int the number of m over n ratios to iterate through </td></tr>
    <tr><td class="paramname">d_movern</td><td>float the change in m/n in each iterations </td></tr>
    <tr><td class="paramname">start_movern</td><td>float the starting value of m/n </td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">target_skip</td><td>int the mean skipping value </td></tr>
    <tr><td class="paramname">target_nodes</td><td>int the target number of nodes in a break </td></tr>
    <tr><td class="paramname">n_iterations</td><td>int the number of iterations </td></tr>
    <tr><td class="paramname">m_over_n_values</td><td>vector&lt;float&gt;&amp; this gets written, it contains the m/n values for the run </td></tr>
    <tr><td class="paramname">AICc_means</td><td>vector&lt;float&gt; gets written, the mean values of the AICc for each m/n </td></tr>
    <tr><td class="paramname">AICc_stddev</td><td>vector&lt;float&gt; gets written, the standard deviation values of the AICc for each m/n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Best fit m over n. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/07/13 </dd></dl>

</div>
</div>
<a class="anchor" id="ac7e0f04da77c3c3db517ef6d9822489e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDChiNetwork::search_for_best_fit_m_over_n_seperate_ms_and_tribs </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start_movern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes_mainstem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine for calculating the best fit m over n values for a channel network, but calculates the mainstem and the tributaries seperately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">n_movern</td><td></td></tr>
    <tr><td class="paramname">d_movern</td><td></td></tr>
    <tr><td class="paramname">start_movern</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
    <tr><td class="paramname">target_nodes_mainstem</td><td></td></tr>
    <tr><td class="paramname">fname</td><td>Output filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Best fit m over n. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a9afd0d4b0e11753df837c15c293f548c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::slope_area_extraction_horizontal_intervals </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>area_thin_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract slope over fixed horizontal intervals. </p>
<p>This one is the horizontal intervals version: it measures slope over fixed flow distance as used by many authors including DiBiasie et al 2010 and Ouimet et al 2009 This function gets slope data and area data for use in making slope area plots. It generates several data elements, which are written to the file with name fname (passed to function). The file format is for each row: <br/>
<br/>
 chan &lt;&lt; " " &lt;&lt; start_row &lt;&lt; " " &lt;&lt; mp_row &lt;&lt; " " &lt;&lt; end_row &lt;&lt; " " &lt;&lt; start_col &lt;&lt; " " &lt;&lt; mp_col &lt;&lt; " " &lt;&lt; end_col &lt;&lt; " " &lt;&lt; start_interval_elevations &lt;&lt; " " &lt;&lt; mp_interval_elevations &lt;&lt; " " &lt;&lt; end_interval_elevations &lt;&lt; " " &lt;&lt; start_interval_flowdistance &lt;&lt; " " &lt;&lt; mp_interval_flowdistance &lt;&lt; " " &lt;&lt; end_interval_flowdistance &lt;&lt; " " &lt;&lt; start_area &lt;&lt; " " &lt;&lt; mp_area &lt;&lt; " " &lt;&lt; end_area &lt;&lt; " " &lt;&lt; slope &lt;&lt; " " &lt;&lt; log10(mp_area) &lt;&lt; " " &lt;&lt; log10(slope) <br/>
<br/>
 where start, mp and end denote the start of the interval over which slope is measured, the midpoint and the end.</p>
<p>The area thin fraction is used to thin the data so that segments with large changes in drainage area are not used in the regression (because these will affect the mean slope) the fraction is determined by (downslope_area-upslope_area)/midpoint_area. So if the fraction is 1 it means that the change is area is equal to the area at the midpoint a restictive value is 0.05, you will eliminate major tributaries with a 0.2, and 1 will catch almost all of the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td></td></tr>
    <tr><td class="paramname">area_thin_fraction</td><td></td></tr>
    <tr><td class="paramname">fname</td><td>Output filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a8f2696da4388a3ec771d9dd351fc1752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::slope_area_extraction_vertical_intervals </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>area_thin_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract slope over fixed vertical intervals. </p>
<p>This one is the vertical intervals version: it measures slope over fixed vertical intervals as reccomended by Wobus et al 2006. This function gets slope data and area data for use in making slope area plots. It generates several data elements, which are written to the file with name fname (passed to function). The file format is for each row:<br/>
<br/>
 chan &lt;&lt; " " &lt;&lt; start_row &lt;&lt; " " &lt;&lt; mp_row &lt;&lt; " " &lt;&lt; end_row &lt;&lt; " " &lt;&lt; start_col &lt;&lt; " " &lt;&lt; mp_col &lt;&lt; " " &lt;&lt; end_col &lt;&lt; " " &lt;&lt; start_interval_elevations &lt;&lt; " " &lt;&lt; mp_interval_elevations &lt;&lt; " " &lt;&lt; end_interval_elevations &lt;&lt; " " &lt;&lt; start_interval_flowdistance &lt;&lt; " " &lt;&lt; mp_interval_flowdistance &lt;&lt; " " &lt;&lt; end_interval_flowdistance &lt;&lt; " " &lt;&lt; start_area &lt;&lt; " " &lt;&lt; mp_area &lt;&lt; " " &lt;&lt; end_area &lt;&lt; " " &lt;&lt; slope &lt;&lt; " " &lt;&lt; log10(mp_area) &lt;&lt; " " &lt;&lt; log10(slope)<br/>
<br/>
 where start, mp and end denote the start of the interval over which slope is measured, the midpoint and the end.</p>
<p>The area thin fraction is used to thin the data so that segments with large changes in drainage area are not used in the regression (because these will affect the mean slope) the fraction is determined by (downslope_area-upslope_area)/midpoint_area. So if the fraction is 1 it means that the change is area is equal to the area at the midpoint a restictive value is 0.05, you will eliminate major tributaries with a 0.2, and 1 will catch almost all of the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td></td></tr>
    <tr><td class="paramname">area_thin_fraction</td><td></td></tr>
    <tr><td class="paramname">fname</td><td>Output filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a1fd6e2b1867b51e0b2f6c494c51c9ed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDChiNetwork::split_all_channels </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_segment_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function splits all the channels in one go. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">n_iterations</td><td></td></tr>
    <tr><td class="paramname">target_skip</td><td></td></tr>
    <tr><td class="paramname">target_nodes</td><td></td></tr>
    <tr><td class="paramname">minimum_segment_length</td><td>How many nodes the mimimum segment will have. </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation of error on elevation data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/06/13 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_l_s_d_chi_network_8hpp_source.html">LSDChiNetwork.hpp</a></li>
<li>src/LSDChiNetwork.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
