<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LSDTopoTools2: LSDJunctionNetwork Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LSDTopoTools2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_l_s_d_junction_network-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LSDJunctionNetwork Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Object to create a channel network from an <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object.  
 <a href="class_l_s_d_junction_network.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_l_s_d_junction_network_8hpp_source.html">LSDJunctionNetwork.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb42f26427d26fe1c51190125c343d65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#afb42f26427d26fe1c51190125c343d65">LSDJunctionNetwork</a> ()</td></tr>
<tr class="memdesc:afb42f26427d26fe1c51190125c343d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines a channel network, is empty.  <a href="#afb42f26427d26fe1c51190125c343d65">More...</a><br/></td></tr>
<tr class="separator:afb42f26427d26fe1c51190125c343d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1807746e8a8c665d7e6c7c0d26e7ab8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a1807746e8a8c665d7e6c7c0d26e7ab8a">LSDJunctionNetwork</a> (vector&lt; int &gt; Sources, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a1807746e8a8c665d7e6c7c0d26e7ab8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines a channel network based on a FlowInfo object and a list of source nodes.  <a href="#a1807746e8a8c665d7e6c7c0d26e7ab8a">More...</a><br/></td></tr>
<tr class="separator:a1807746e8a8c665d7e6c7c0d26e7ab8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a03b0d231f199a198c101900042940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_junction_network.html">LSDJunctionNetwork</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a34a03b0d231f199a198c101900042940">operator=</a> (const <a class="el" href="class_l_s_d_junction_network.html">LSDJunctionNetwork</a> &amp;LSDR)</td></tr>
<tr class="memdesc:a34a03b0d231f199a198c101900042940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a34a03b0d231f199a198c101900042940">More...</a><br/></td></tr>
<tr class="separator:a34a03b0d231f199a198c101900042940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b32a7bf1825980898039736d0f2931d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a5b32a7bf1825980898039736d0f2931d">get_UTM_information</a> (int &amp;UTM_zone, bool &amp;is_North)</td></tr>
<tr class="memdesc:a5b32a7bf1825980898039736d0f2931d"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function gets the UTM_zone and a boolean that is true if the map is in the northern hemisphere  <a href="#a5b32a7bf1825980898039736d0f2931d">More...</a><br/></td></tr>
<tr class="separator:a5b32a7bf1825980898039736d0f2931d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1be926dd745bad78f7b82da89201c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aea1be926dd745bad78f7b82da89201c6">get_x_and_y_locations</a> (int row, int col, double &amp;x_loc, double &amp;y_loc)</td></tr>
<tr class="memdesc:aea1be926dd745bad78f7b82da89201c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">this gets the x and y location of a node at row and column  <a href="#aea1be926dd745bad78f7b82da89201c6">More...</a><br/></td></tr>
<tr class="separator:aea1be926dd745bad78f7b82da89201c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b3099bdeb9f74ecba4bdceba99615d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#af8b3099bdeb9f74ecba4bdceba99615d">get_x_and_y_locations</a> (int row, int col, float &amp;x_loc, float &amp;y_loc)</td></tr>
<tr class="memdesc:af8b3099bdeb9f74ecba4bdceba99615d"><td class="mdescLeft">&#160;</td><td class="mdescRight">this gets the x and y location of a node at row and column  <a href="#af8b3099bdeb9f74ecba4bdceba99615d">More...</a><br/></td></tr>
<tr class="separator:af8b3099bdeb9f74ecba4bdceba99615d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547da43828e94bcf7e441485a541a570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a547da43828e94bcf7e441485a541a570">get_lat_and_long_locations</a> (int row, int col, double &amp;lat, double &amp;longitude, <a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a> Converter)</td></tr>
<tr class="memdesc:a547da43828e94bcf7e441485a541a570"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function to get the lat and long of a node in the raster  Assumes WGS84 ellipsiod  <a href="#a547da43828e94bcf7e441485a541a570">More...</a><br/></td></tr>
<tr class="separator:a547da43828e94bcf7e441485a541a570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ee5fbf4a6c5c79dc0bd599e29c1cb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a98ee5fbf4a6c5c79dc0bd599e29c1cb8">get_x_and_y_from_latlong</a> (vector&lt; float &gt; latitude, vector&lt; float &gt; longitude, vector&lt; float &gt; &amp;UTME, vector&lt; float &gt; &amp;UTMN)</td></tr>
<tr class="memdesc:a98ee5fbf4a6c5c79dc0bd599e29c1cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes latitude and longitude (in WGS 84) and converts to vectors of easting and northing in UTM.  <a href="#a98ee5fbf4a6c5c79dc0bd599e29c1cb8">More...</a><br/></td></tr>
<tr class="separator:a98ee5fbf4a6c5c79dc0bd599e29c1cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39d182f738f3e8aaf921c9472ba30dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ad39d182f738f3e8aaf921c9472ba30dc">add_to_stack</a> (int lm_index, int &amp;j_index, int bl_node)</td></tr>
<tr class="memdesc:ad39d182f738f3e8aaf921c9472ba30dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive add_to_stack routine to build the junction tree, from Braun and Willett (2012) equations 12 and 13.  <a href="#ad39d182f738f3e8aaf921c9472ba30dc">More...</a><br/></td></tr>
<tr class="separator:ad39d182f738f3e8aaf921c9472ba30dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedb1028393a20cba5a9e019628794c6"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aeedb1028393a20cba5a9e019628794c6">get_upslope_junctions</a> (int junction_number_outlet)</td></tr>
<tr class="memdesc:aeedb1028393a20cba5a9e019628794c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns all the upstream junction of a junction_number_outlet.  <a href="#aeedb1028393a20cba5a9e019628794c6">More...</a><br/></td></tr>
<tr class="separator:aeedb1028393a20cba5a9e019628794c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e8ccf64a0ac88d0cde7ffa3e8330fb"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a53e8ccf64a0ac88d0cde7ffa3e8330fb">get_all_source_junctions_of_an_outlet_junction</a> (int junction_number_outlet)</td></tr>
<tr class="memdesc:a53e8ccf64a0ac88d0cde7ffa3e8330fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This finds all the junctions that are source junctions upslope of a given junction.  <a href="#a53e8ccf64a0ac88d0cde7ffa3e8330fb">More...</a><br/></td></tr>
<tr class="separator:a53e8ccf64a0ac88d0cde7ffa3e8330fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e33e2d37d483f691784acd970c65c0d"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a3e33e2d37d483f691784acd970c65c0d">get_all_source_nodes_of_an_outlet_junction</a> (int junction_number_outlet)</td></tr>
<tr class="memdesc:a3e33e2d37d483f691784acd970c65c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This finds all the nodes that are source nodes upslope of a given junction.  <a href="#a3e33e2d37d483f691784acd970c65c0d">More...</a><br/></td></tr>
<tr class="separator:a3e33e2d37d483f691784acd970c65c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5990bfef78ee423bdcecb247c0ef36d"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ad5990bfef78ee423bdcecb247c0ef36d">get_donor_nodes</a> (int node)</td></tr>
<tr class="memdesc:ad5990bfef78ee423bdcecb247c0ef36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function gets a list of the junction indices of the donors to a particular junction  IMPORTANT: this has only retained the string "node" to keep equivalence with the FlowInfo object. It takes junctions and returns junctions!! Also note that base level nodes have themselves as a donor  <a href="#ad5990bfef78ee423bdcecb247c0ef36d">More...</a><br/></td></tr>
<tr class="separator:ad5990bfef78ee423bdcecb247c0ef36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28e1ba59ce7b0356960bacb9e5c252f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ab28e1ba59ce7b0356960bacb9e5c252f">map_junction_to_upslope_junction_list</a> (vector&lt; int &gt; upslope_junctions, int junction)</td></tr>
<tr class="memdesc:ab28e1ba59ce7b0356960bacb9e5c252f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function maps a junction onto the indexing of the upslope junction list.  <a href="#ab28e1ba59ce7b0356960bacb9e5c252f">More...</a><br/></td></tr>
<tr class="separator:ab28e1ba59ce7b0356960bacb9e5c252f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4071c346788998d9a9614bebb7de50b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a4071c346788998d9a9614bebb7de50b6">get_maximum_stream_order</a> ()</td></tr>
<tr class="memdesc:a4071c346788998d9a9614bebb7de50b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the maximum stream order in the DEM.  <a href="#a4071c346788998d9a9614bebb7de50b6">More...</a><br/></td></tr>
<tr class="separator:a4071c346788998d9a9614bebb7de50b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469924e6d87c33fdd4b79ff886abd236"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a469924e6d87c33fdd4b79ff886abd236">get_number_of_streams</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, int stream_order)</td></tr>
<tr class="memdesc:a469924e6d87c33fdd4b79ff886abd236"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the number of streams of a given stream order.  <a href="#a469924e6d87c33fdd4b79ff886abd236">More...</a><br/></td></tr>
<tr class="separator:a469924e6d87c33fdd4b79ff886abd236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af480d83ed5f332a9a50dd1ac18ea3a5d"><td class="memItemLeft" align="right" valign="top">map&lt; int, vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#af480d83ed5f332a9a50dd1ac18ea3a5d">calculate_junction_angles</a> (vector&lt; int &gt; JunctionList, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:af480d83ed5f332a9a50dd1ac18ea3a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This calculates the junction angles based on a number of junctions.  <a href="#af480d83ed5f332a9a50dd1ac18ea3a5d">More...</a><br/></td></tr>
<tr class="separator:af480d83ed5f332a9a50dd1ac18ea3a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288fa7b3c05ecd32b1e6d2946e99f1be"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a288fa7b3c05ecd32b1e6d2946e99f1be">calculate_junction_angle_statistics_upstream_of_junction</a> (int target_junction, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a288fa7b3c05ecd32b1e6d2946e99f1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the mean and standard error of every junction angle upslope of a given junction.  <a href="#a288fa7b3c05ecd32b1e6d2946e99f1be">More...</a><br/></td></tr>
<tr class="separator:a288fa7b3c05ecd32b1e6d2946e99f1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed209a7fa8985c997a724029aa82cce"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a1ed209a7fa8985c997a724029aa82cce">calculate_junction_angle_statistics_upstream_of_junction</a> (int target_junction, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, int threshold_SO)</td></tr>
<tr class="memdesc:a1ed209a7fa8985c997a724029aa82cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded function similar to above but removes any junctions not greater than threshold SO.  <a href="#a1ed209a7fa8985c997a724029aa82cce">More...</a><br/></td></tr>
<tr class="separator:a1ed209a7fa8985c997a724029aa82cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe72ea4fa4d35fab5c10c7f145d5940e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#abe72ea4fa4d35fab5c10c7f145d5940e">calculate_junction_angle_statistics_for_order</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, int BasinOrder, vector&lt; int &gt; &amp;junction_list, vector&lt; float &gt; &amp;junction_angle_averages, vector&lt; float &gt; &amp;junction_angle_stderr, vector&lt; int &gt; &amp;N_junctions)</td></tr>
<tr class="memdesc:abe72ea4fa4d35fab5c10c7f145d5940e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes the junction angle statistics for all basins of a given order.  <a href="#abe72ea4fa4d35fab5c10c7f145d5940e">More...</a><br/></td></tr>
<tr class="separator:abe72ea4fa4d35fab5c10c7f145d5940e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748fcb383c71b142401ca71a6eb8fa11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a748fcb383c71b142401ca71a6eb8fa11">print_junction_angles_from_basin_list</a> (vector&lt; int &gt; JunctionList, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, string csv_outname)</td></tr>
<tr class="memdesc:a748fcb383c71b142401ca71a6eb8fa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a vector of basin junctions and prints statistics of all the junctions upstream of each basin junction to a CSV. The statstics are separated by stream order.  <a href="#a748fcb383c71b142401ca71a6eb8fa11">More...</a><br/></td></tr>
<tr class="separator:a748fcb383c71b142401ca71a6eb8fa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79f12f408209d34ce125f4a40f792b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ab79f12f408209d34ce125f4a40f792b0">print_junction_angles_to_csv</a> (vector&lt; int &gt; JunctionList, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, string csv_name)</td></tr>
<tr class="memdesc:ab79f12f408209d34ce125f4a40f792b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This prints the junction angles to a csv file.  <a href="#ab79f12f408209d34ce125f4a40f792b0">More...</a><br/></td></tr>
<tr class="separator:ab79f12f408209d34ce125f4a40f792b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4da4a7eaf3ff7f3cadf122550fc35e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ab4da4a7eaf3ff7f3cadf122550fc35e7">get_Junction_of_Node</a> (int Node, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:ab4da4a7eaf3ff7f3cadf122550fc35e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the junction number of a given node.  <a href="#ab4da4a7eaf3ff7f3cadf122550fc35e7">More...</a><br/></td></tr>
<tr class="separator:ab4da4a7eaf3ff7f3cadf122550fc35e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff034fabc2f1d6c7dc908140e9667b66"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aff034fabc2f1d6c7dc908140e9667b66">get_Junctions_of_Sources</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:aff034fabc2f1d6c7dc908140e9667b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the junction number all the sources.  <a href="#aff034fabc2f1d6c7dc908140e9667b66">More...</a><br/></td></tr>
<tr class="separator:aff034fabc2f1d6c7dc908140e9667b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb9c6ebec401ac3899732d15de3fbe9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a5bb9c6ebec401ac3899732d15de3fbe9">get_penultimate_node_from_stream_link</a> (int upstream_junction, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a5bb9c6ebec401ac3899732d15de3fbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the penultimate node of the stream link below given junction  <a href="#a5bb9c6ebec401ac3899732d15de3fbe9">More...</a><br/></td></tr>
<tr class="separator:a5bb9c6ebec401ac3899732d15de3fbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d933d422cc70a0b2d726e809aa0bea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a9d933d422cc70a0b2d726e809aa0bea2">StreamOrderArray_to_LSDIndexRaster</a> ()</td></tr>
<tr class="memdesc:a9d933d422cc70a0b2d726e809aa0bea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sends the StreamOrderArray to a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>.  <a href="#a9d933d422cc70a0b2d726e809aa0bea2">More...</a><br/></td></tr>
<tr class="separator:a9d933d422cc70a0b2d726e809aa0bea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b799eb9c084d1b84ea2e24450216d94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a5b799eb9c084d1b84ea2e24450216d94">StreamOrderArray_to_WGS84CSV</a> (string FileName)</td></tr>
<tr class="memdesc:a5b799eb9c084d1b84ea2e24450216d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to flatten an te stream order array and place the non NDV values in a csv file.  Each value is placed on its own line, so that it can be read more quickly in python etc. It includes the lat long coordinates in CSV, in WGS84 coordinate system EPSG:4326.  <a href="#a5b799eb9c084d1b84ea2e24450216d94">More...</a><br/></td></tr>
<tr class="separator:a5b799eb9c084d1b84ea2e24450216d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b003b148a825727477e838461ce615e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a6b003b148a825727477e838461ce615e">PrintChannelNetworkToCSV</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;flowinfo, string fname_prefix)</td></tr>
<tr class="memdesc:a6b003b148a825727477e838461ce615e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This prints a stream network to a csv in WGS84  This function prints a network that is ordered by sources, channels have stream orders and junction numbers attached param FlowInfo the flow info object which translates node indices to actual points.  <a href="#a6b003b148a825727477e838461ce615e">More...</a><br/></td></tr>
<tr class="separator:a6b003b148a825727477e838461ce615e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace692517891020b57724d95851f73c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ace692517891020b57724d95851f73c20">JunctionArray_to_LSDIndexRaster</a> ()</td></tr>
<tr class="memdesc:ace692517891020b57724d95851f73c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sends the JunctionArray to a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>.  <a href="#ace692517891020b57724d95851f73c20">More...</a><br/></td></tr>
<tr class="separator:ace692517891020b57724d95851f73c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670e0ab97bcd2531ef6b53a103dd7006"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a670e0ab97bcd2531ef6b53a103dd7006">JunctionIndexArray_to_LSDIndexRaster</a> ()</td></tr>
<tr class="memdesc:a670e0ab97bcd2531ef6b53a103dd7006"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sends the JunctionIndexArray to a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>.  <a href="#a670e0ab97bcd2531ef6b53a103dd7006">More...</a><br/></td></tr>
<tr class="separator:a670e0ab97bcd2531ef6b53a103dd7006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9209dc43cfd5c3b75af3283cf31ca96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#af9209dc43cfd5c3b75af3283cf31ca96">StreamOrderArray_to_BinaryNetwork_LSDIndexRaster</a> ()</td></tr>
<tr class="memdesc:af9209dc43cfd5c3b75af3283cf31ca96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the StreamOrderArray into a binary rastser where 1 is channel and 0 is hillslope.  <a href="#af9209dc43cfd5c3b75af3283cf31ca96">More...</a><br/></td></tr>
<tr class="separator:af9209dc43cfd5c3b75af3283cf31ca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993913490fc153f93e4f84fe3e74e2d4"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a993913490fc153f93e4f84fe3e74e2d4">get_BaseLevel_DonorJunctions</a> ()</td></tr>
<tr class="memdesc:a993913490fc153f93e4f84fe3e74e2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the largest donor junction to the baselevel nodes so that you can automate basin selection. (e.g. for use with chi analysis)  <a href="#a993913490fc153f93e4f84fe3e74e2d4">More...</a><br/></td></tr>
<tr class="separator:a993913490fc153f93e4f84fe3e74e2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af304d34c18bf1bcb463785d39a2e2633"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#af304d34c18bf1bcb463785d39a2e2633">Prune_Junctions_Edge</a> (vector&lt; int &gt; &amp;BaseLevelJunctions_Initial, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:af304d34c18bf1bcb463785d39a2e2633"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a list of junctions and then prunes junctions based whether they drain from the edge. This attempts to remove junctions that are through-flowing and thus do not have the correct drainage area.  <a href="#af304d34c18bf1bcb463785d39a2e2633">More...</a><br/></td></tr>
<tr class="separator:af304d34c18bf1bcb463785d39a2e2633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1fb89053c0852dced2cc1c1fceb9a2"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#abb1fb89053c0852dced2cc1c1fceb9a2">Prune_Junctions_Edge_Ignore_Outlet_Reach</a> (vector&lt; int &gt; &amp;BaseLevelJunctions_Initial, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;TestRaster)</td></tr>
<tr class="memdesc:abb1fb89053c0852dced2cc1c1fceb9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a list of junctions and then prunes junctions based whether they drain from the edge. This attempts to remove junctions that are through-flowing and thus do not have the correct drainage area  Only gets the donor of the baselelve donor to ignore the nodes near the outlet, which often intersect nodata in cut DEMs.  <a href="#abb1fb89053c0852dced2cc1c1fceb9a2">More...</a><br/></td></tr>
<tr class="separator:abb1fb89053c0852dced2cc1c1fceb9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd2a44c7068ee4b9921cc3c7e09d145"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a5bd2a44c7068ee4b9921cc3c7e09d145">Prune_To_Largest_Complete_Basins</a> (vector&lt; int &gt; &amp;BaseLevelJunctions_Initial, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;TestRaster, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;FlowAcc)</td></tr>
<tr class="memdesc:a5bd2a44c7068ee4b9921cc3c7e09d145"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function looks through all baselevel nodes and then looks for the largest basin that is not influenced by the edge. It returns a vector of these junctions.  Note that it only returns one basin per baselevel node at most so might not do a great job of space filling.  <a href="#a5bd2a44c7068ee4b9921cc3c7e09d145">More...</a><br/></td></tr>
<tr class="separator:a5bd2a44c7068ee4b9921cc3c7e09d145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafe6c2cbf177c867092df0500208db8"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aaafe6c2cbf177c867092df0500208db8">Prune_Junctions_By_Contributing_Pixel_Window</a> (vector&lt; int &gt; &amp;Junctions_Initial, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;FlowAcc, int lower_limit, int upper_limit)</td></tr>
<tr class="memdesc:aaafe6c2cbf177c867092df0500208db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes basins that fall outside a contributing pixel Window.  <a href="#aaafe6c2cbf177c867092df0500208db8">More...</a><br/></td></tr>
<tr class="separator:aaafe6c2cbf177c867092df0500208db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d89b334bb9521c703adb4efa47e00e4"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a3d89b334bb9521c703adb4efa47e00e4">Prune_Junctions_By_Contributing_Pixel_Window_Remove_Nested_And_Nodata</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;TestRaster, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;FlowAcc, int lower_limit, int upper_limit)</td></tr>
<tr class="memdesc:a3d89b334bb9521c703adb4efa47e00e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes basins that fall outside a contributing pixel Window, those that are bounded by nodata, and those that are nested. A rather intensive pruning process that hopeuflly results in a number of basins that are a similar size  This doesn't just look for baselevel junctions: it goes through all junctions in the DEM. Warning: computationally expensive!  <a href="#a3d89b334bb9521c703adb4efa47e00e4">More...</a><br/></td></tr>
<tr class="separator:a3d89b334bb9521c703adb4efa47e00e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e0c4bd9c7c41f2494a44a14a1a6e26"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a47e0c4bd9c7c41f2494a44a14a1a6e26">Prune_Junctions_If_Nested</a> (vector&lt; int &gt; &amp;Junctions_Initial, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;FlowAcc)</td></tr>
<tr class="memdesc:a47e0c4bd9c7c41f2494a44a14a1a6e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes basins that are nested within any other basin in the list.  <a href="#a47e0c4bd9c7c41f2494a44a14a1a6e26">More...</a><br/></td></tr>
<tr class="separator:a47e0c4bd9c7c41f2494a44a14a1a6e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b8968fc63339dea5120fc538940696"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a32b8968fc63339dea5120fc538940696">Prune_Junctions_Area</a> (vector&lt; int &gt; &amp;BaseLevelJunctions_Initial, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;FlowAcc, int Threshold)</td></tr>
<tr class="memdesc:a32b8968fc63339dea5120fc538940696"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a list of junctions and then prunes junctions based on their number of contributing pixels.  <a href="#a32b8968fc63339dea5120fc538940696">More...</a><br/></td></tr>
<tr class="separator:a32b8968fc63339dea5120fc538940696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265b836771e5cc12fedd6f35d39be9a4"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a265b836771e5cc12fedd6f35d39be9a4">Prune_Junctions_Largest</a> (vector&lt; int &gt; &amp;BaseLevelJunctions_Initial, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;FlowAcc)</td></tr>
<tr class="memdesc:a265b836771e5cc12fedd6f35d39be9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a list of junctions retains ONLY the larges bains The junction is returned as an int vector so that it can be passed to other functions requiring junction lists.  <a href="#a265b836771e5cc12fedd6f35d39be9a4">More...</a><br/></td></tr>
<tr class="separator:a265b836771e5cc12fedd6f35d39be9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed9ae91e36b7848f7ca6c9f43dec394"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a5ed9ae91e36b7848f7ca6c9f43dec394">Prune_Junctions_Threshold_Elevation</a> (vector&lt; int &gt; &amp;BaseLevelJunctions_Initial, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Elev, float threshold_elevation, bool keep_junctions_below_threshold)</td></tr>
<tr class="memdesc:a5ed9ae91e36b7848f7ca6c9f43dec394"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a list of junctions retains ONLY the junctions that have an outlet elevation greater or less than the threshold elevation Selection of greater or lower is determined by bool keep_junctions_below_threshold.  <a href="#a5ed9ae91e36b7848f7ca6c9f43dec394">More...</a><br/></td></tr>
<tr class="separator:a5ed9ae91e36b7848f7ca6c9f43dec394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4e6b46c22f76ad0c3e48033bf06c36"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ada4e6b46c22f76ad0c3e48033bf06c36">Prune_Junctions_Elevation_Window</a> (vector&lt; int &gt; &amp;BaseLevelJunctions_Initial, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Elev, float lower_threshold, float upper_threshold)</td></tr>
<tr class="memdesc:ada4e6b46c22f76ad0c3e48033bf06c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a list of junctions retains ONLY the junctions that have an outlet elevation with an elevation window.  <a href="#ada4e6b46c22f76ad0c3e48033bf06c36">More...</a><br/></td></tr>
<tr class="separator:ada4e6b46c22f76ad0c3e48033bf06c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868e9d936a6d802f64ef75573c1d636a"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a868e9d936a6d802f64ef75573c1d636a">get_contributing_pixels_from_specified_junctions</a> (vector&lt; int &gt; &amp;JunctionList, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;FlowAcc)</td></tr>
<tr class="memdesc:a868e9d936a6d802f64ef75573c1d636a"><td class="mdescLeft">&#160;</td><td class="mdescRight">You give this a list of junction numbers and it returns the number of upslope pixels.  <a href="#a868e9d936a6d802f64ef75573c1d636a">More...</a><br/></td></tr>
<tr class="separator:a868e9d936a6d802f64ef75573c1d636a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05530213caf8239343ca216eb111325"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aa05530213caf8239343ca216eb111325">retrieve_junction_number_at_row_and_column</a> (int row, int col)</td></tr>
<tr class="memdesc:aa05530213caf8239343ca216eb111325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Junction number at a location.  <a href="#aa05530213caf8239343ca216eb111325">More...</a><br/></td></tr>
<tr class="separator:aa05530213caf8239343ca216eb111325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943520cce153fd6cb185a772af0d8418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a943520cce153fd6cb185a772af0d8418">print_longest_channel</a> (int outlet_junction, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FInfo, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;dist_code, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;dist_from_outlet)</td></tr>
<tr class="memdesc:a943520cce153fd6cb185a772af0d8418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for printing out the longest channel upstream of a point.  <a href="#a943520cce153fd6cb185a772af0d8418">More...</a><br/></td></tr>
<tr class="separator:a943520cce153fd6cb185a772af0d8418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e71b549418702e4ef17a4bf5e89cf4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a4e71b549418702e4ef17a4bf5e89cf4d">print_junction_info_vectors</a> (string filename)</td></tr>
<tr class="memdesc:a4e71b549418702e4ef17a4bf5e89cf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the information about the junctions to file.  <a href="#a4e71b549418702e4ef17a4bf5e89cf4d">More...</a><br/></td></tr>
<tr class="separator:a4e71b549418702e4ef17a4bf5e89cf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbc073a080a8c54f000c3904b9ab678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_channel.html">LSDIndexChannel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a3fbc073a080a8c54f000c3904b9ab678">generate_link_index_channel_from_junction</a> (int start_junction, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a3fbc073a080a8c54f000c3904b9ab678"><td class="mdescLeft">&#160;</td><td class="mdescRight">This generates an LSDChannelIndex object given a junction.  <a href="#a3fbc073a080a8c54f000c3904b9ab678">More...</a><br/></td></tr>
<tr class="separator:a3fbc073a080a8c54f000c3904b9ab678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425ffd07f5f5c1829070781f83c4d974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_channel.html">LSDIndexChannel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a425ffd07f5f5c1829070781f83c4d974">generate_longest_index_channel_from_junction</a> (int outlet_junction, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;dist_from_outlet)</td></tr>
<tr class="memdesc:a425ffd07f5f5c1829070781f83c4d974"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts the longest channel originating from a junction number outlet_junction.  <a href="#a425ffd07f5f5c1829070781f83c4d974">More...</a><br/></td></tr>
<tr class="separator:a425ffd07f5f5c1829070781f83c4d974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8e79c1a4c0e3802d516ac3c41ccdf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_channel.html">LSDIndexChannel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a3b8e79c1a4c0e3802d516ac3c41ccdf2">generate_longest_index_channel_in_basin</a> (int basin_junction, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;dist_from_outlet)</td></tr>
<tr class="memdesc:a3b8e79c1a4c0e3802d516ac3c41ccdf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This generates the longest channel in a basin.  <a href="#a3b8e79c1a4c0e3802d516ac3c41ccdf2">More...</a><br/></td></tr>
<tr class="separator:a3b8e79c1a4c0e3802d516ac3c41ccdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d87a7f352be432a313cd710f697e2f9"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a4d87a7f352be432a313cd710f697e2f9">get_basin_sources_from_outlet_vector</a> (vector&lt; int &gt; basin_junctions, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;dist_from_outlet)</td></tr>
<tr class="memdesc:a4d87a7f352be432a313cd710f697e2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This generates the upstream source nodes from a vector of basin junctions.  <a href="#a4d87a7f352be432a313cd710f697e2f9">More...</a><br/></td></tr>
<tr class="separator:a4d87a7f352be432a313cd710f697e2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61962a040dece1e354209e13717448a"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ad61962a040dece1e354209e13717448a">extract_basins_order_outlet_junctions</a> (int BasinOrder, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:ad61962a040dece1e354209e13717448a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This extracts the junction numbers, in a vector of integers, of all basins of a given order.  <a href="#ad61962a040dece1e354209e13717448a">More...</a><br/></td></tr>
<tr class="separator:ad61962a040dece1e354209e13717448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58eda65d1ed1ae4de1d61640f1516f2d"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a58eda65d1ed1ae4de1d61640f1516f2d">extract_basins_order_outlet_nodes</a> (vector&lt; int &gt; &amp;BasinOutletJunctions, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a58eda65d1ed1ae4de1d61640f1516f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function gets the outlet node of a list of basins.  <a href="#a58eda65d1ed1ae4de1d61640f1516f2d">More...</a><br/></td></tr>
<tr class="separator:a58eda65d1ed1ae4de1d61640f1516f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01765e9bb2f75defc8b3fcf4a08a46d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a01765e9bb2f75defc8b3fcf4a08a46d1">extract_tributary_junctions_to_main_stem</a> (<a class="el" href="class_l_s_d_index_channel.html">LSDIndexChannel</a> &amp;MainStem, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, vector&lt; int &gt; &amp;tributary_junctions, vector&lt; int &gt; &amp;nodes_on_main_stem_of_tributaries)</td></tr>
<tr class="memdesc:a01765e9bb2f75defc8b3fcf4a08a46d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets tributaries along a continous channel.  <a href="#a01765e9bb2f75defc8b3fcf4a08a46d1">More...</a><br/></td></tr>
<tr class="separator:a01765e9bb2f75defc8b3fcf4a08a46d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c19d30170d031509cab846f5adc95c7"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a3c19d30170d031509cab846f5adc95c7">get_pruned_tributaries_from_main_stem</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_junction_network.html">LSDJunctionNetwork</a> &amp;ChannelNetwork, int starting_junction, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DistanceFromOutlet, int pruning_switch, float pruning_threshold)</td></tr>
<tr class="memdesc:a3c19d30170d031509cab846f5adc95c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function gets the tributary junctions upstream of the starting_junction based on pruning criteria.  <a href="#a3c19d30170d031509cab846f5adc95c7">More...</a><br/></td></tr>
<tr class="separator:a3c19d30170d031509cab846f5adc95c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68178de68987b2b8fc940837cf07fc75"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a68178de68987b2b8fc940837cf07fc75">extract_basin_nodes_by_drainage_area</a> (float DrainageAreaThreshold, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a68178de68987b2b8fc940837cf07fc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts basin nodes according to their accumulated drainage area.  <a href="#a68178de68987b2b8fc940837cf07fc75">More...</a><br/></td></tr>
<tr class="separator:a68178de68987b2b8fc940837cf07fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09e0871448035a329b4bb959247a0ed"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ab09e0871448035a329b4bb959247a0ed">extract_basin_nodes_above_drainage_area_threshold</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, float DrainageAreaThreshold)</td></tr>
<tr class="memdesc:ab09e0871448035a329b4bb959247a0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts nodes where the basins of both tributaries are greater than a certain drainage area threshold. Moves downstream from sources to baselevel so that nested catchments will be selected.  <a href="#ab09e0871448035a329b4bb959247a0ed">More...</a><br/></td></tr>
<tr class="separator:ab09e0871448035a329b4bb959247a0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebc8a592980be9e4ab9654b6d59d9a0"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a0ebc8a592980be9e4ab9654b6d59d9a0">modify_basin_nodes_from_mask</a> (vector&lt; int &gt; basin_nodes, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;MaskRaster)</td></tr>
<tr class="memdesc:a0ebc8a592980be9e4ab9654b6d59d9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks all of the basin nodes to check if they fall within a mask (input raster). If they fall within the mask raster then the first node upstream not in the mask is selected.  <a href="#a0ebc8a592980be9e4ab9654b6d59d9a0">More...</a><br/></td></tr>
<tr class="separator:a0ebc8a592980be9e4ab9654b6d59d9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a2ca5fb541d19eb2c5d8e0e3ef5e60"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a30a2ca5fb541d19eb2c5d8e0e3ef5e60">extract_basin_junctions_from_nodes</a> (vector&lt; int &gt; basin_nodes, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a30a2ca5fb541d19eb2c5d8e0e3ef5e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts basin junctions from a list of basin outlet nodes.  <a href="#a30a2ca5fb541d19eb2c5d8e0e3ef5e60">More...</a><br/></td></tr>
<tr class="separator:a30a2ca5fb541d19eb2c5d8e0e3ef5e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ae8ad114fda70ca426f233da32b7bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#af0ae8ad114fda70ca426f233da32b7bf">extract_basin_from_junction</a> (int basin_junction, int basin_reference_number, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:af0ae8ad114fda70ca426f233da32b7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the node indices of outlets of basins of a certain order.  <a href="#af0ae8ad114fda70ca426f233da32b7bf">More...</a><br/></td></tr>
<tr class="separator:af0ae8ad114fda70ca426f233da32b7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5038fd71848da0bb949a65f05f7b708a"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a5038fd71848da0bb949a65f05f7b708a">Get_Channel_Head_Junctions</a> (vector&lt; int &gt; Sources, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a5038fd71848da0bb949a65f05f7b708a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts a list of sources used to generate the initial channel network into a list of junction indexes of channel heads which can be used to extract hollows.  <a href="#a5038fd71848da0bb949a65f05f7b708a">More...</a><br/></td></tr>
<tr class="separator:a5038fd71848da0bb949a65f05f7b708a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4777080ace73ce3f5afeab49a662f283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a4777080ace73ce3f5afeab49a662f283">extract_hollow</a> (int CH_junction, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a4777080ace73ce3f5afeab49a662f283"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts a single hollow from a given channel head junction.  <a href="#a4777080ace73ce3f5afeab49a662f283">More...</a><br/></td></tr>
<tr class="separator:a4777080ace73ce3f5afeab49a662f283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805b7b34f337af52776b7b4f1124e29a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a805b7b34f337af52776b7b4f1124e29a">extract_hollow</a> (vector&lt; int &gt; CH_junctions, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a805b7b34f337af52776b7b4f1124e29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts a series of hollows from a vector of channel head junctions.  <a href="#a805b7b34f337af52776b7b4f1124e29a">More...</a><br/></td></tr>
<tr class="separator:a805b7b34f337af52776b7b4f1124e29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6878d97c41e1a3bac6fcae888232c15d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a6878d97c41e1a3bac6fcae888232c15d">extract_basins_from_junction_vector</a> (vector&lt; int &gt; basin_junctions, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a6878d97c41e1a3bac6fcae888232c15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of basins draining from a vector of junctions.  <a href="#a6878d97c41e1a3bac6fcae888232c15d">More...</a><br/></td></tr>
<tr class="separator:a6878d97c41e1a3bac6fcae888232c15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64918a2da1abf5543f4793c069550045"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a64918a2da1abf5543f4793c069550045">extract_basins_from_junction_vector_nested</a> (vector&lt; int &gt; basin_junctions, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a64918a2da1abf5543f4793c069550045"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of basins draining from a vector of junctions.  <a href="#a64918a2da1abf5543f4793c069550045">More...</a><br/></td></tr>
<tr class="separator:a64918a2da1abf5543f4793c069550045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120542ae0b90784c40b86a6cb7c33283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a120542ae0b90784c40b86a6cb7c33283">extract_basins_from_junctions_rudimentary</a> (vector&lt; int &gt; junctions, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a120542ae0b90784c40b86a6cb7c33283"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of basins draining from a vector of junctions.  <a href="#a120542ae0b90784c40b86a6cb7c33283">More...</a><br/></td></tr>
<tr class="separator:a120542ae0b90784c40b86a6cb7c33283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1299d32f7cc52cfd557b93ffb4b6c7a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a1299d32f7cc52cfd557b93ffb4b6c7a3">ExtractBasinsOrder</a> (int BasinOrder, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a1299d32f7cc52cfd557b93ffb4b6c7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basin extraction - extracts all drainage basins of specified stream order.  <a href="#a1299d32f7cc52cfd557b93ffb4b6c7a3">More...</a><br/></td></tr>
<tr class="separator:a1299d32f7cc52cfd557b93ffb4b6c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35061b9f2025be4f7cb1968af6e4070"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#af35061b9f2025be4f7cb1968af6e4070">ExtractBasinJunctionOrder</a> (int BasinOrder, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:af35061b9f2025be4f7cb1968af6e4070"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts the juctions of all non-beheaded drainage basins of a given order, n.  <a href="#af35061b9f2025be4f7cb1968af6e4070">More...</a><br/></td></tr>
<tr class="separator:af35061b9f2025be4f7cb1968af6e4070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816391193d54949ae6a74921718dfdba"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a816391193d54949ae6a74921718dfdba">ExtractBasinJunctionOrderKeepEdgeBasins</a> (int BasinOrder, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a816391193d54949ae6a74921718dfdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts the juctions of all non-beheaded drainage basins of a given order, n. Like the previous version but in this case includes basins at the edge (abutting nodata)  <a href="#a816391193d54949ae6a74921718dfdba">More...</a><br/></td></tr>
<tr class="separator:a816391193d54949ae6a74921718dfdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4efde43de44a3a5e131d8b0d5e0a69"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a1f4efde43de44a3a5e131d8b0d5e0a69">FindFarthestUpslopeHilltopsFromSources</a> (int JunctionNumber, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;FlowDistance)</td></tr>
<tr class="memdesc:a1f4efde43de44a3a5e131d8b0d5e0a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get farthest upslope hilltops.  <a href="#a1f4efde43de44a3a5e131d8b0d5e0a69">More...</a><br/></td></tr>
<tr class="separator:a1f4efde43de44a3a5e131d8b0d5e0a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fd15411e57bf75c7aed72d3a9a881b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a02fd15411e57bf75c7aed72d3a9a881b">GetChannelHeadsChiMethodFromNode</a> (int NodeNumber, int MinSegLength, float A_0, float m_over_n, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;FlowDistance, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster)</td></tr>
<tr class="memdesc:a02fd15411e57bf75c7aed72d3a9a881b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates LSDChannels that run from the hilltops above all the sources of the junction JunctionNumber.  <a href="#a02fd15411e57bf75c7aed72d3a9a881b">More...</a><br/></td></tr>
<tr class="separator:a02fd15411e57bf75c7aed72d3a9a881b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d5d0653ad2f31a5375a37583759d44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a60d5d0653ad2f31a5375a37583759d44">GetChannelHeadsChiMethodFromSourceNode</a> (int NodeNumber, int MinSegLength, float A_0, float m_over_n, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;FlowDistance, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster, int <a class="el" href="class_l_s_d_junction_network.html#a134e1655f701796474746b0b2d6d2990">NJunctions</a>)</td></tr>
<tr class="memdesc:a60d5d0653ad2f31a5375a37583759d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates LSDChannels that run from the hilltops above all the sources from the valley network down to a specified number of downstream junctions below the sources.  <a href="#a60d5d0653ad2f31a5375a37583759d44">More...</a><br/></td></tr>
<tr class="separator:a60d5d0653ad2f31a5375a37583759d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5020205756ad9f39c9f68702cbdb6ae8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a5020205756ad9f39c9f68702cbdb6ae8">write_valley_hilltop_chi_profiles_to_csv</a> (vector&lt; int &gt; sources, float A_0, float m_over_n, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;FlowDistance, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster, int <a class="el" href="class_l_s_d_junction_network.html#a134e1655f701796474746b0b2d6d2990">NJunctions</a>, string output_path, string DEM_ID)</td></tr>
<tr class="memdesc:a5020205756ad9f39c9f68702cbdb6ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates LSDChannels that run from the hilltops above all the sources from the valley network down to a specified number of downstream junctions below the sources and writes the profile to csv.  <a href="#a5020205756ad9f39c9f68702cbdb6ae8">More...</a><br/></td></tr>
<tr class="separator:a5020205756ad9f39c9f68702cbdb6ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4371935878d556e8e7d7d2802fd27a28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a4371935878d556e8e7d7d2802fd27a28">GetChannelfromDreich</a> (int NodeNumber, int MinSegLength, float A_0, float m_over_n, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;FlowDistance, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster, string path_name, int <a class="el" href="class_l_s_d_junction_network.html#a134e1655f701796474746b0b2d6d2990">NJunctions</a>)</td></tr>
<tr class="memdesc:a4371935878d556e8e7d7d2802fd27a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the channel that runs from the hilltop above the furthest upslope source of the junction JunctionNumber.  <a href="#a4371935878d556e8e7d7d2802fd27a28">More...</a><br/></td></tr>
<tr class="separator:a4371935878d556e8e7d7d2802fd27a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ab76a1cbc73591a533e3623a3e293f"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ae8ab76a1cbc73591a533e3623a3e293f">GetChannelHeadsChiMethodFromValleys</a> (vector&lt; int &gt; ValleyNodes, int MinSegLength, float A_0, float m_over_n, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;FlowDistance, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster)</td></tr>
<tr class="memdesc:ae8ab76a1cbc73591a533e3623a3e293f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns all potential channel heads in a DEM. It looks for channel heads organized by a basin order which is fed to the code The basin order just determines how far downstream the algorithm looks for the 'fluvial' section. It returns a vector&lt;int&gt; of nodeindices where the channel heads are.  <a href="#ae8ab76a1cbc73591a533e3623a3e293f">More...</a><br/></td></tr>
<tr class="separator:ae8ab76a1cbc73591a533e3623a3e293f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652c837de1dc19f82c5da38c4e8f826d"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a652c837de1dc19f82c5da38c4e8f826d">GetChannelHeadsChiMethodFromSources</a> (vector&lt; int &gt; ValleySources, int MinSegLength, float A_0, float m_over_n, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;FlowDistance, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster, int <a class="el" href="class_l_s_d_junction_network.html#a134e1655f701796474746b0b2d6d2990">NJunctions</a>)</td></tr>
<tr class="memdesc:a652c837de1dc19f82c5da38c4e8f826d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns all potential channel heads in a DEM. It looks for.  <a href="#a652c837de1dc19f82c5da38c4e8f826d">More...</a><br/></td></tr>
<tr class="separator:a652c837de1dc19f82c5da38c4e8f826d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815eccfd9aa2a75b354d5c1d5437fc96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a815eccfd9aa2a75b354d5c1d5437fc96">GetChannelsDreich</a> (vector&lt; int &gt; ValleySources, int MinSegLength, float A_0, float m_over_n, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;FlowDistance, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster, string path_name, int <a class="el" href="class_l_s_d_junction_network.html#a134e1655f701796474746b0b2d6d2990">NJunctions</a>)</td></tr>
<tr class="memdesc:a815eccfd9aa2a75b354d5c1d5437fc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns all channels in the DEM that the DrEICH algorithm uses for segiment fitting. It looks for channels based on the outlet junctions of valleys. It returns a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with the channels.  <a href="#a815eccfd9aa2a75b354d5c1d5437fc96">More...</a><br/></td></tr>
<tr class="separator:a815eccfd9aa2a75b354d5c1d5437fc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cb2434e59e5a4105ae7a7aaf4fa53a"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a82cb2434e59e5a4105ae7a7aaf4fa53a">GetChannelHeadsChiMethodAllPixels</a> (int JunctionNumber, float A_0, float m_over_n, float bin_width, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster)</td></tr>
<tr class="memdesc:a82cb2434e59e5a4105ae7a7aaf4fa53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a 2D array containing the locations of all pixels identified as being part of the channel using chi profiles. It calculates the chi and elevation value of every pixel upstream of the given junction, then bins this data and calculates the pixels in the 95th percentile of each bin. Any pixels above the 95th percentile are considered part of the channel, and any below are considered to be hillslopes. This is the first part of the channel head prediction using chi profiles.  <a href="#a82cb2434e59e5a4105ae7a7aaf4fa53a">More...</a><br/></td></tr>
<tr class="separator:a82cb2434e59e5a4105ae7a7aaf4fa53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a42d4dfbd0784ae0e265035c9d67a5c"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a5a42d4dfbd0784ae0e265035c9d67a5c">GetSourceNodesChiMethodAllPixels</a> (int JunctionNumber, float A_0, float m_over_n, float bin_width, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster)</td></tr>
<tr class="memdesc:a5a42d4dfbd0784ae0e265035c9d67a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns an integer vector with the node indexes of the furthest upstream pixels identified as being part of the channel using chi profiles. It calculates the chi and elevation value of every pixel upstream of the given junction, then bins this data and calculates the pixels in the 95th percentile of each bin. Any pixels above the 95th percentile are considered part of the channel, and any below are considered to be hillslopes. This is the first part of the channel head prediction using chi profiles.  <a href="#a5a42d4dfbd0784ae0e265035c9d67a5c">More...</a><br/></td></tr>
<tr class="separator:a5a42d4dfbd0784ae0e265035c9d67a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e6902731cbfcc3d6e38d34ff379c4f"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a19e6902731cbfcc3d6e38d34ff379c4f">calculate_pelletier_channel_heads</a> (float tan_curv_threshold, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, Array2D&lt; float &gt; &amp;tan_curv_array)</td></tr>
<tr class="memdesc:a19e6902731cbfcc3d6e38d34ff379c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to predict channel head locations based on the method proposed by Pelletier (2013).  <a href="#a19e6902731cbfcc3d6e38d34ff379c4f">More...</a><br/></td></tr>
<tr class="separator:a19e6902731cbfcc3d6e38d34ff379c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6df45bea95af208aa160967fc566105"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aa6df45bea95af208aa160967fc566105">calculate_pelletier_channel_heads_DTM</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, Array2D&lt; float &gt; topography, float tan_curv_threshold, Array2D&lt; float &gt; &amp;tan_curv_array, Array2D&lt; float &gt; &amp;tan_curv_array_LW)</td></tr>
<tr class="memdesc:aa6df45bea95af208aa160967fc566105"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function predicts channel head locations based on a tangential threshold as proposed by Pelletier (2013).  <a href="#aa6df45bea95af208aa160967fc566105">More...</a><br/></td></tr>
<tr class="separator:aa6df45bea95af208aa160967fc566105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e58f4f2d8e85e7066d90b8a45299cdf"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a9e58f4f2d8e85e7066d90b8a45299cdf">identify_upstream_limits</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, Array2D&lt; float &gt; &amp;topography, vector&lt; int &gt; source_row_vec, vector&lt; int &gt; source_col_vec, Array2D&lt; float &gt; &amp;tan_curv)</td></tr>
<tr class="memdesc:a9e58f4f2d8e85e7066d90b8a45299cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function identifies upstream limit of channel network.  <a href="#a9e58f4f2d8e85e7066d90b8a45299cdf">More...</a><br/></td></tr>
<tr class="separator:a9e58f4f2d8e85e7066d90b8a45299cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9fe1201077fc24bc77340c8d1fcecb"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a8e9fe1201077fc24bc77340c8d1fcecb">find_valleys</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, Array2D&lt; float &gt; &amp;tan_curv_array, vector&lt; int &gt; sources, int no_connecting_nodes, float tan_curv_threshold=0.1)</td></tr>
<tr class="memdesc:a8e9fe1201077fc24bc77340c8d1fcecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to identify concave portions of the landscape using a tangential curvature threshold.  <a href="#a8e9fe1201077fc24bc77340c8d1fcecb">More...</a><br/></td></tr>
<tr class="separator:a8e9fe1201077fc24bc77340c8d1fcecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792eb222ef8579b40b74a79b770e71a6"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a792eb222ef8579b40b74a79b770e71a6">get_outlet_nodes_from_sources</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, vector&lt; int &gt; sources)</td></tr>
<tr class="memdesc:a792eb222ef8579b40b74a79b770e71a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get the outlet nodes from a vector of input source nodes.  <a href="#a792eb222ef8579b40b74a79b770e71a6">More...</a><br/></td></tr>
<tr class="separator:a792eb222ef8579b40b74a79b770e71a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e260d6b2544fb8f364a7646b6f71d54"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a9e260d6b2544fb8f364a7646b6f71d54">find_valleys_adaptive_threshold</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, Array2D&lt; float &gt; &amp;tan_curv_array, vector&lt; int &gt; sources, int no_connecting_nodes, Array2D&lt; float &gt; &amp;tan_curv_threshold)</td></tr>
<tr class="memdesc:a9e260d6b2544fb8f364a7646b6f71d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to identify concave portions of the landscape using a tangential curvature threshold which is adaptive for each portion of the landscape.  <a href="#a9e260d6b2544fb8f364a7646b6f71d54">More...</a><br/></td></tr>
<tr class="separator:a9e260d6b2544fb8f364a7646b6f71d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa235034604fe83a9e96ab91a525ddc"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#affa235034604fe83a9e96ab91a525ddc">find_valleys_using_channel_mask</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, Array2D&lt; int &gt; &amp;channel_mask, vector&lt; int &gt; sources, int no_connecting_nodes)</td></tr>
<tr class="memdesc:affa235034604fe83a9e96ab91a525ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses a predefined channel mask to locate valley junctions.  <a href="#affa235034604fe83a9e96ab91a525ddc">More...</a><br/></td></tr>
<tr class="separator:affa235034604fe83a9e96ab91a525ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b1f20e6efcdcc9c2b59e307822a71d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a29b1f20e6efcdcc9c2b59e307822a71d">ExtractRidges</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a29b1f20e6efcdcc9c2b59e307822a71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ridge network extraction - extracts ridge network, defined as boundaries between two basins of the same stream order.  <a href="#a29b1f20e6efcdcc9c2b59e307822a71d">More...</a><br/></td></tr>
<tr class="separator:a29b1f20e6efcdcc9c2b59e307822a71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c4bb0eab32e63172bf758ec1fa7410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aa9c4bb0eab32e63172bf758ec1fa7410">ExtractRidges</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, int &amp;min_order, int &amp;max_order)</td></tr>
<tr class="separator:aa9c4bb0eab32e63172bf758ec1fa7410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904b79b71676df41c10cb1118eafcb37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a904b79b71676df41c10cb1118eafcb37">ExtractHilltops</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;RidgeRaster, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;SlopeRaster, float MaxSlope)</td></tr>
<tr class="memdesc:a904b79b71676df41c10cb1118eafcb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This last function gets the hilltops: ridges limited by a maximum slope.  <a href="#a904b79b71676df41c10cb1118eafcb37">More...</a><br/></td></tr>
<tr class="separator:a904b79b71676df41c10cb1118eafcb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d598a23b425249001ab0e1032f171d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a2d598a23b425249001ab0e1032f171d8">ChannelIndexer</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;flowinfo)</td></tr>
<tr class="memdesc:a2d598a23b425249001ab0e1032f171d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function iterates through the junction nodes and assigns the unique junction ID to every stream pixel.  <a href="#a2d598a23b425249001ab0e1032f171d8">More...</a><br/></td></tr>
<tr class="separator:a2d598a23b425249001ab0e1032f171d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93118c2adc4fa5b4e22a3a5197c2daa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ae93118c2adc4fa5b4e22a3a5197c2daa">GetChannelNodesAndJunctions</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;flowinfo, vector&lt; int &gt; &amp;NIvec, vector&lt; int &gt; &amp;JIvec, vector&lt; int &gt; &amp;SOvec)</td></tr>
<tr class="memdesc:ae93118c2adc4fa5b4e22a3a5197c2daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This extracts vectors containing node incidex, junction indices and stream orders of pixels in the channel network.  The vectors are replaced by the method.  <a href="#ae93118c2adc4fa5b4e22a3a5197c2daa">More...</a><br/></td></tr>
<tr class="separator:ae93118c2adc4fa5b4e22a3a5197c2daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdd20387208c965eef18ae77869a057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a1fdd20387208c965eef18ae77869a057">SplitChannel</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, vector&lt; int &gt; Sources, int TargetSegmentLength)</td></tr>
<tr class="memdesc:a1fdd20387208c965eef18ae77869a057"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function splits the channel into a series of segments, providing a convenient unit with which to analyse landscapes. The user provides the TargetSegmentLength, which specifies how many nodes should be in each segment, and a MinimumSegmentLength, which specifies the fewest permissable number of nodes. Segments smaller than this are amalgamated into the upstream segment. The algorithm loops through the sources and traces downstream, stopping a segment after the target segment length, when the stream order increases (to preserve structure of drainage network), or when a channel pixel has already been visited.  <a href="#a1fdd20387208c965eef18ae77869a057">More...</a><br/></td></tr>
<tr class="separator:a1fdd20387208c965eef18ae77869a057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518c170d3e0808813157b0b7778b9bcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a518c170d3e0808813157b0b7778b9bcf">TypologyModel</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, vector&lt; int &gt; Sources, vector&lt; int &gt; BaselineSources, vector&lt; int &gt; CatchIDs, vector&lt; int &gt; HydroCodes, int MinReachLength, int search_radius, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DischargeRaster, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;ChannelSegments, vector&lt; vector&lt; int &gt; &gt; &amp;SegmentInfoInts, vector&lt; vector&lt; float &gt; &gt; &amp;SegmentInfoFloats)</td></tr>
<tr class="separator:a518c170d3e0808813157b0b7778b9bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541eb7632c5e14cb126cf2c45929e927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a541eb7632c5e14cb126cf2c45929e927">remove_tributary_segments</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, vector&lt; int &gt; Sources, vector&lt; vector&lt; int &gt; &gt; &amp;SegmentInfoInts, vector&lt; vector&lt; float &gt; &gt; &amp;SegmentInfoFloats)</td></tr>
<tr class="memdesc:a541eb7632c5e14cb126cf2c45929e927"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes channel segments from the typology model which are not downstream of a given list of source nodes.  <a href="#a541eb7632c5e14cb126cf2c45929e927">More...</a><br/></td></tr>
<tr class="separator:a541eb7632c5e14cb126cf2c45929e927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95cfb300f54f19990bd8f6dd3c358e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ac95cfb300f54f19990bd8f6dd3c358e4">print_channel_segments_to_csv</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, vector&lt; vector&lt; int &gt; &gt; SegmentInfoInts, vector&lt; vector&lt; float &gt; &gt; SegmentInfoFloats, string outfilename)</td></tr>
<tr class="memdesc:ac95cfb300f54f19990bd8f6dd3c358e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints information about the channel segments from the TypologyModel function to a csv file so it can be read by a GIS.  <a href="#ac95cfb300f54f19990bd8f6dd3c358e4">More...</a><br/></td></tr>
<tr class="separator:ac95cfb300f54f19990bd8f6dd3c358e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adf2319c3383cf8d9059ecc7e0d318e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a0adf2319c3383cf8d9059ecc7e0d318e">SplitHillslopes</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;ChannelSegmentsRaster)</td></tr>
<tr class="memdesc:a0adf2319c3383cf8d9059ecc7e0d318e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is intended to follow the SplitChannel function. It traces through the receiver nodes from every hillslope pixel and then assigns them an integer value that matches the index of the section of channel that is setting the base level of that hillslope.  <a href="#a0adf2319c3383cf8d9059ecc7e0d318e">More...</a><br/></td></tr>
<tr class="separator:a0adf2319c3383cf8d9059ecc7e0d318e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f0908f81dbffe7c863662597b1dcbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a02f0908f81dbffe7c863662597b1dcbd">SplitHillslopes</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;ChannelSegmentsRaster, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;MultiThreadChannelRaster)</td></tr>
<tr class="memdesc:a02f0908f81dbffe7c863662597b1dcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded function doing the same as the previous version to segment hillslopes according to the channel index of the channel setting its base level. However, this has been adapted to include an additional input raster - MultiThreadChannelRaster - which recognises that real channels may be multithreaded and/or have widths greater than or equal to one pixel. To be rigourous, these should be removed from analyses of hillslope properties.  <a href="#a02f0908f81dbffe7c863662597b1dcbd">More...</a><br/></td></tr>
<tr class="separator:a02f0908f81dbffe7c863662597b1dcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3f1b7cca4f1a587f8d31e4e1957b97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aff3f1b7cca4f1a587f8d31e4e1957b97">GetStreams</a> (int order)</td></tr>
<tr class="memdesc:aff3f1b7cca4f1a587f8d31e4e1957b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick and dirty way to get channels of a defined stream order.  <a href="#aff3f1b7cca4f1a587f8d31e4e1957b97">More...</a><br/></td></tr>
<tr class="separator:aff3f1b7cca4f1a587f8d31e4e1957b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b90694f9404cb07dc333eedd69d486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a05b90694f9404cb07dc333eedd69d486">GetStreams</a> (int min_order, int max_order)</td></tr>
<tr class="memdesc:a05b90694f9404cb07dc333eedd69d486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick and dirty way to get channels of a defined range of stream orders.  <a href="#a05b90694f9404cb07dc333eedd69d486">More...</a><br/></td></tr>
<tr class="separator:a05b90694f9404cb07dc333eedd69d486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4548116f9030acdb93b889b353d78e85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a4548116f9030acdb93b889b353d78e85">node_tester</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, int input_junction)</td></tr>
<tr class="memdesc:a4548116f9030acdb93b889b353d78e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to test whether a junction's upstream nodes border areas of No Data important to ensure basins are not being artificially truncated.  <a href="#a4548116f9030acdb93b889b353d78e85">More...</a><br/></td></tr>
<tr class="separator:a4548116f9030acdb93b889b353d78e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77781e76c57a03ffdf2ec887b33bafc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a77781e76c57a03ffdf2ec887b33bafc8">get_receiver_junction_for_specified_coordinates</a> (float X_coordinate, float Y_coordinate, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a77781e76c57a03ffdf2ec887b33bafc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to snap input coordinates to the nearest junction. This enables easy extraction of a particular catchment for analysis.  <a href="#a77781e76c57a03ffdf2ec887b33bafc8">More...</a><br/></td></tr>
<tr class="separator:a77781e76c57a03ffdf2ec887b33bafc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f463ea8d35bd7465d3a4aaafb4cb7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ae9f463ea8d35bd7465d3a4aaafb4cb7c">get_nodeindex_of_nearest_channel_for_specified_coordinates</a> (float X_coordinate, float Y_coordinate, int threshold_stream_order, int search_radius_nodes, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:ae9f463ea8d35bd7465d3a4aaafb4cb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to snap input coordinates to the nearest channel node. This enables easy extraction of a particular catchment for analysis.  <a href="#ae9f463ea8d35bd7465d3a4aaafb4cb7c">More...</a><br/></td></tr>
<tr class="separator:ae9f463ea8d35bd7465d3a4aaafb4cb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecaf7e1d912c71d9aef7b7684681262"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a5ecaf7e1d912c71d9aef7b7684681262">get_junction_of_nearest_channel_from_lat_long</a> (double latitude, double longitude, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a> Converter)</td></tr>
<tr class="memdesc:a5ecaf7e1d912c71d9aef7b7684681262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to snap input coordinates to the nearest channel node from latitude and longitude.  <a href="#a5ecaf7e1d912c71d9aef7b7684681262">More...</a><br/></td></tr>
<tr class="separator:a5ecaf7e1d912c71d9aef7b7684681262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43dc7e1a8cb2cb3923c405127fddf94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#af43dc7e1a8cb2cb3923c405127fddf94">get_info_nearest_channel_to_node</a> (int &amp;StartingNode, int &amp;threshold_SO, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DistFromOutlet, int &amp;ChannelNode, float &amp;FlowLength, float &amp;DistanceUpstream)</td></tr>
<tr class="memdesc:af43dc7e1a8cb2cb3923c405127fddf94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get info about the nearest channel node of a given node.  <a href="#af43dc7e1a8cb2cb3923c405127fddf94">More...</a><br/></td></tr>
<tr class="separator:af43dc7e1a8cb2cb3923c405127fddf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9191be7f7a307b89a53014d07cfb9692"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a9191be7f7a307b89a53014d07cfb9692">get_info_nearest_channel_to_node_main_stem</a> (int &amp;StartingNode, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DistFromOutlet, <a class="el" href="class_l_s_d_index_channel.html">LSDIndexChannel</a> &amp;MainStem, int &amp;ChannelNode, float &amp;FlowLength, float &amp;DistanceUpstream, float &amp;Relief)</td></tr>
<tr class="memdesc:a9191be7f7a307b89a53014d07cfb9692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get info about the nearest channel node on the main stem of a given node.  <a href="#a9191be7f7a307b89a53014d07cfb9692">More...</a><br/></td></tr>
<tr class="separator:a9191be7f7a307b89a53014d07cfb9692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1532af1ec0bfea04d57c283045d5cd7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a1532af1ec0bfea04d57c283045d5cd7c">find_upstream_junction_from_channel_nodeindex</a> (int ChannelNodeIndex, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a1532af1ec0bfea04d57c283045d5cd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a node index, checks to see if it is on a channel, and then works its way up the channel to find the upstream junction.  <a href="#a1532af1ec0bfea04d57c283045d5cd7c">More...</a><br/></td></tr>
<tr class="separator:a1532af1ec0bfea04d57c283045d5cd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7192d553ee1c3389b242f3d48e476ffc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a7192d553ee1c3389b242f3d48e476ffc">check_stream_order_of_upstream_nodes</a> (int junction, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a7192d553ee1c3389b242f3d48e476ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether any of the upstream nodes of a given junction are the same steam order as the junction itself. It returns an integer value which is 1 if the SO is the same and 0 if it is not the same.  <a href="#a7192d553ee1c3389b242f3d48e476ffc">More...</a><br/></td></tr>
<tr class="separator:a7192d553ee1c3389b242f3d48e476ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34889326edf0bf6c7fe5021d2c7f00a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ac34889326edf0bf6c7fe5021d2c7f00a">get_upstream_node_max_stream_order</a> (int current_node, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:ac34889326edf0bf6c7fe5021d2c7f00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the node index of the donor node of a given node with the highest stream order.  <a href="#ac34889326edf0bf6c7fe5021d2c7f00a">More...</a><br/></td></tr>
<tr class="separator:ac34889326edf0bf6c7fe5021d2c7f00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c96d5c74da714fa45eb8fe930e48be4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a7c96d5c74da714fa45eb8fe930e48be4">snap_point_locations_to_channels</a> (vector&lt; float &gt; x_locs, vector&lt; float &gt; y_locs, int search_radius_nodes, int threshold_stream_order, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, vector&lt; int &gt; &amp;valid_cosmo_points, vector&lt; int &gt; &amp;snapped_node_indices, vector&lt; int &gt; &amp;snapped_junction_indices)</td></tr>
<tr class="memdesc:a7c96d5c74da714fa45eb8fe930e48be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is a wrapper that takes a list of x and y locations, filters them to make sure they are in the data bounds, and then calculates the nearest channel and junction. It is primarily used to snap cosmo data to the channel network  <a href="#a7c96d5c74da714fa45eb8fe930e48be4">More...</a><br/></td></tr>
<tr class="separator:a7c96d5c74da714fa45eb8fe930e48be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91261ebe8074b335bbe1f915f9afb60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ab91261ebe8074b335bbe1f915f9afb60">find_base_level_node_of_junction</a> (int StartingJunction)</td></tr>
<tr class="memdesc:ab91261ebe8074b335bbe1f915f9afb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions takes a junction number and then follwos the receiver junctions until it hits a baselevel junction.  <a href="#ab91261ebe8074b335bbe1f915f9afb60">More...</a><br/></td></tr>
<tr class="separator:ab91261ebe8074b335bbe1f915f9afb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813e4e6ded76dcbf2e328bf405052659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a813e4e6ded76dcbf2e328bf405052659">print_junctions_to_csv</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, vector&lt; int &gt; JunctionList, string fname)</td></tr>
<tr class="memdesc:a813e4e6ded76dcbf2e328bf405052659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a list of junctions, with their locations in both UTM and in lat long WGS1984 to file  The format of the file is: junction,node,x,y,latitude,longitude.  <a href="#a813e4e6ded76dcbf2e328bf405052659">More...</a><br/></td></tr>
<tr class="separator:a813e4e6ded76dcbf2e328bf405052659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb662846c99587fc9c74cf9044a64530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aeb662846c99587fc9c74cf9044a64530">print_junctions_to_csv</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, string fname)</td></tr>
<tr class="memdesc:aeb662846c99587fc9c74cf9044a64530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints all junctions, with their locations in both UTM and in lat long WGS1984 to file  The format of the file is: junction,node,x,y,latitude,longitude.  <a href="#aeb662846c99587fc9c74cf9044a64530">More...</a><br/></td></tr>
<tr class="separator:aeb662846c99587fc9c74cf9044a64530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9026182e24ceddc156da2767c898451"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ae9026182e24ceddc156da2767c898451">get_NRows</a> () const </td></tr>
<tr class="separator:ae9026182e24ceddc156da2767c898451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc419ef163d08965e40786078036d371"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#acc419ef163d08965e40786078036d371">get_NCols</a> () const </td></tr>
<tr class="separator:acc419ef163d08965e40786078036d371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab771a27b9224ef0c642be99b2700a6e6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ab771a27b9224ef0c642be99b2700a6e6">get_XMinimum</a> () const </td></tr>
<tr class="separator:ab771a27b9224ef0c642be99b2700a6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef9888d30ce0dc9c0f3d0d77c40c14c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a7ef9888d30ce0dc9c0f3d0d77c40c14c">get_YMinimum</a> () const </td></tr>
<tr class="separator:a7ef9888d30ce0dc9c0f3d0d77c40c14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebb318b92e4ff303396ae0bdd24bd47"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a1ebb318b92e4ff303396ae0bdd24bd47">get_DataResolution</a> () const </td></tr>
<tr class="separator:a1ebb318b92e4ff303396ae0bdd24bd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f82f0a323e07e7704dfcadae6eacb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a46f82f0a323e07e7704dfcadae6eacb4">get_NoDataValue</a> () const </td></tr>
<tr class="separator:a46f82f0a323e07e7704dfcadae6eacb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4b5f46641df5ab68401ac699d8c28b"><td class="memItemLeft" align="right" valign="top">map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aec4b5f46641df5ab68401ac699d8c28b">get_GeoReferencingStrings</a> () const </td></tr>
<tr class="separator:aec4b5f46641df5ab68401ac699d8c28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3f4453cbd44f4fee7adfe08651a825"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a5c3f4453cbd44f4fee7adfe08651a825">get_Node_of_Junction</a> (int junction) const </td></tr>
<tr class="separator:a5c3f4453cbd44f4fee7adfe08651a825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bf86aa84503de0d4394f1a5a5394b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a70bf86aa84503de0d4394f1a5a5394b1">get_Receiver_of_Junction</a> (int junction) const </td></tr>
<tr class="separator:a70bf86aa84503de0d4394f1a5a5394b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86067f9ab2ff0b296fc44d577731e1e"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ac86067f9ab2ff0b296fc44d577731e1e">get_node_list_from_junction_list</a> (vector&lt; int &gt; junction_list)</td></tr>
<tr class="separator:ac86067f9ab2ff0b296fc44d577731e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8f03d3d2edd169b42f0aef4ea2cac3"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a7d8f03d3d2edd169b42f0aef4ea2cac3">get_node_list_of_penultimate_node_from_junction_list</a> (vector&lt; int &gt; junction_list, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="separator:a7d8f03d3d2edd169b42f0aef4ea2cac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e8ef760e1e4cd97814b8c3008c553b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a29e8ef760e1e4cd97814b8c3008c553b">get_downstream_junction</a> (int starting_junction, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="separator:a29e8ef760e1e4cd97814b8c3008c553b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8699e82c3d09a39deb9711212e0f4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aeb8699e82c3d09a39deb9711212e0f4b">get_StreamOrder_of_Node</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, int node)</td></tr>
<tr class="separator:aeb8699e82c3d09a39deb9711212e0f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09b4d550d156e92134a1b6b9d561353"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ae09b4d550d156e92134a1b6b9d561353">get_StreamOrder_of_Junction</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, int junction)</td></tr>
<tr class="separator:ae09b4d550d156e92134a1b6b9d561353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc7c5a1e19a6a8a3f67a003623586f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#acfc7c5a1e19a6a8a3f67a003623586f8">get_StreamOrder_of_Junction</a> (int junction)</td></tr>
<tr class="separator:acfc7c5a1e19a6a8a3f67a003623586f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891b77edfcc93b7e92da1bb39903a3f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a891b77edfcc93b7e92da1bb39903a3f2">get_Next_StreamOrder_Junction</a> (int junction)</td></tr>
<tr class="separator:a891b77edfcc93b7e92da1bb39903a3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c3f526a3e9f276a2441b016c485e0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a24c3f526a3e9f276a2441b016c485e0b">is_junction_upstream</a> (int current_junction, int test_junction)</td></tr>
<tr class="separator:a24c3f526a3e9f276a2441b016c485e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806183d6241a0d349772adff2261fcdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a806183d6241a0d349772adff2261fcdd">is_Junction_BaseLevel</a> (int junction)</td></tr>
<tr class="separator:a806183d6241a0d349772adff2261fcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351c374b2aa41f951d46c4b8c45dc1f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a351c374b2aa41f951d46c4b8c45dc1f9">get_NJunctions</a> () const </td></tr>
<tr class="separator:a351c374b2aa41f951d46c4b8c45dc1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5552c1deacf167134d831758e94a9ed"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ad5552c1deacf167134d831758e94a9ed">get_JunctionVector</a> () const </td></tr>
<tr class="separator:ad5552c1deacf167134d831758e94a9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba42cc7730347f00c18ca30045a8105"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aaba42cc7730347f00c18ca30045a8105">get_BaseLevelJunctions</a> () const </td></tr>
<tr class="separator:aaba42cc7730347f00c18ca30045a8105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2cb84eb053dfc795973773d1043fc4"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#afd2cb84eb053dfc795973773d1043fc4">get_ReceiverVector</a> () const </td></tr>
<tr class="separator:afd2cb84eb053dfc795973773d1043fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac761fb65066da746097b203e2e5fa798"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ac761fb65066da746097b203e2e5fa798">get_StreamOrderVector</a> () const </td></tr>
<tr class="separator:ac761fb65066da746097b203e2e5fa798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f289b7d5a1139a2a0fba97ea5dc7de"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a36f289b7d5a1139a2a0fba97ea5dc7de">get_SourcesVector</a> () const </td></tr>
<tr class="separator:a36f289b7d5a1139a2a0fba97ea5dc7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4d9a186d712ca4c68e3fb8308943f2"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a0a4d9a186d712ca4c68e3fb8308943f2">get_StreamOrderArray</a> () const </td></tr>
<tr class="separator:a0a4d9a186d712ca4c68e3fb8308943f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a76c01c64fed723b6c1e534fbcea77c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a76c01c64fed723b6c1e534fbcea77c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>couple_hillslope_nodes_to_channel_nodes</b> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Elevation, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;D_inf_Flowdir, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;ChannelNodeNetwork, int OutletJunction, vector&lt; int &gt; &amp;hillslope_nodes, vector&lt; int &gt; &amp;baselevel_channel_nodes)</td></tr>
<tr class="separator:a2a76c01c64fed723b6c1e534fbcea77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871cc7c5b542d93d8f757e849d063a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a871cc7c5b542d93d8f757e849d063a72">calculate_relief_from_channel</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, int threshold_SO)</td></tr>
<tr class="separator:a871cc7c5b542d93d8f757e849d063a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213a3d01866f3de14d360fe5bc59c81b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a213a3d01866f3de14d360fe5bc59c81b">calculate_relief_from_channel_connected_components</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;ConnectedComponents, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DistFromOutlet, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, int threshold_SO, int search_distance)</td></tr>
<tr class="separator:a213a3d01866f3de14d360fe5bc59c81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af217731f518d2386957a1682ccedfdf9"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#af217731f518d2386957a1682ccedfdf9">Get_Elevation_of_Nearest_Channel_for_Connected_Components</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;ConnectedComponents, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DistFromOutlet, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, int threshold_SO, int search_distance)</td></tr>
<tr class="separator:af217731f518d2386957a1682ccedfdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efcf3f6ab36e85282751a2ea86e2296"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a0efcf3f6ab36e85282751a2ea86e2296">find_mean_elevation_of_channel_reach</a> (int StartingNode, int search_distance, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ElevationRaster, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="separator:a0efcf3f6ab36e85282751a2ea86e2296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f5239ed6c7ec0188fb6c7ab0da4c56"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ac0f5239ed6c7ec0188fb6c7ab0da4c56">find_distance_to_nearest_floodplain_pixel</a> (int point_node, int search_distance, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;FloodplainRaster, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="separator:ac0f5239ed6c7ec0188fb6c7ab0da4c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1452172d2f74c1a9237c32e104a35a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a6e1452172d2f74c1a9237c32e104a35a">get_overlapping_channels</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, vector&lt; int &gt; BaseLevel_Junctions, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DistanceFromOutlet, vector&lt; int &gt; &amp;source_nodes, vector&lt; int &gt; &amp;outlet_nodes, int n_nodes_to_visit)</td></tr>
<tr class="separator:a6e1452172d2f74c1a9237c32e104a35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55091e049773f8344954e50c99c2ad3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a55091e049773f8344954e50c99c2ad3c">get_overlapping_channels</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, vector&lt; int &gt; BaseLevel_Junctions, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DistanceFromOutlet, vector&lt; int &gt; &amp;source_nodes, vector&lt; int &gt; &amp;outlet_nodes, vector&lt; int &gt; &amp;baselevel_nodes, int n_nodes_to_visit)</td></tr>
<tr class="separator:a55091e049773f8344954e50c99c2ad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5f4e316dd36c449518b466438c5965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a0a5f4e316dd36c449518b466438c5965">get_overlapping_channels_to_downstream_outlets</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, vector&lt; int &gt; BaseLevel_Junctions, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DistanceFromOutlet, vector&lt; int &gt; &amp;source_nodes, vector&lt; int &gt; &amp;outlet_nodes, int n_nodes_to_visit)</td></tr>
<tr class="separator:a0a5f4e316dd36c449518b466438c5965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1dff71bfe8d9e180a847c7276b2041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a9f1dff71bfe8d9e180a847c7276b2041">get_overlapping_channels_to_downstream_outlets</a> (<a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, vector&lt; int &gt; BaseLevel_Junctions, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DistanceFromOutlet, vector&lt; int &gt; &amp;source_nodes, vector&lt; int &gt; &amp;outlet_nodes, vector&lt; int &gt; &amp;baselevel_nodes, int n_nodes_to_visit)</td></tr>
<tr class="memdesc:a9f1dff71bfe8d9e180a847c7276b2041"><td class="mdescLeft">&#160;</td><td class="mdescRight">I THINK THIS MIGHT CAUSE A SEG FAULT: NEED TO UPDATE!!!!!  <a href="#a9f1dff71bfe8d9e180a847c7276b2041">More...</a><br/></td></tr>
<tr class="separator:a9f1dff71bfe8d9e180a847c7276b2041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ab8aa85777cfaea0b6f7ec6ee7ffd2"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a45ab8aa85777cfaea0b6f7ec6ee7ffd2">get_channel_pixels_along_line</a> (vector&lt; int &gt; line_rows, vector&lt; int &gt; line_cols, int threshold_SO, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="separator:a45ab8aa85777cfaea0b6f7ec6ee7ffd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e62388b02d10869dc8c44fc327a985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ae3e62388b02d10869dc8c44fc327a985">write_river_profiles_to_csv</a> (vector&lt; int &gt; &amp;BasinJunctions, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DistanceFromOutlet, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Elevation, string csv_filename)</td></tr>
<tr class="memdesc:ae3e62388b02d10869dc8c44fc327a985"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to take a vector of basin outlet junctions and write data about the longest channel in each to csv.  <a href="#ae3e62388b02d10869dc8c44fc327a985">More...</a><br/></td></tr>
<tr class="separator:ae3e62388b02d10869dc8c44fc327a985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d5fea180ef55d21caa643d2d58bb2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a32d5fea180ef55d21caa643d2d58bb2b">write_river_profiles_to_csv_all_tributaries</a> (vector&lt; int &gt; &amp;BasinJunctions, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DistanceFromOutlet, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Elevation, string csv_filename)</td></tr>
<tr class="memdesc:a32d5fea180ef55d21caa643d2d58bb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to take a vector of basin outlet junctions and write data about all tribs to csv  <a href="#a32d5fea180ef55d21caa643d2d58bb2b">More...</a><br/></td></tr>
<tr class="separator:a32d5fea180ef55d21caa643d2d58bb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9ffd6b9a28371ee82d515719a38ced"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a2b9ffd6b9a28371ee82d515719a38ced">GetTotalChannelLengthUpstream</a> (int this_node, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo)</td></tr>
<tr class="memdesc:a2b9ffd6b9a28371ee82d515719a38ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">function get the total length of channels upstream of a node  <a href="#a2b9ffd6b9a28371ee82d515719a38ced">More...</a><br/></td></tr>
<tr class="separator:a2b9ffd6b9a28371ee82d515719a38ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88c277b5ec55fd259ec5102ea8ffeeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ae88c277b5ec55fd259ec5102ea8ffeeb">write_river_profiles_to_csv_all_sources</a> (float channel_length, int slope_window_size, <a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;FlowInfo, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Elevation, string csv_filename)</td></tr>
<tr class="memdesc:ae88c277b5ec55fd259ec5102ea8ffeeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to write data about channels downstream of all channel heads for a specified length  <a href="#ae88c277b5ec55fd259ec5102ea8ffeeb">More...</a><br/></td></tr>
<tr class="separator:ae88c277b5ec55fd259ec5102ea8ffeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9d7447fd6c105a4c8f436a57a67ffd2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d7447fd6c105a4c8f436a57a67ffd2f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a9d7447fd6c105a4c8f436a57a67ffd2f">NRows</a></td></tr>
<tr class="memdesc:a9d7447fd6c105a4c8f436a57a67ffd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows. <br/></td></tr>
<tr class="separator:a9d7447fd6c105a4c8f436a57a67ffd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc590d7f6606eae4229bc5bc154dfd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dc590d7f6606eae4229bc5bc154dfd0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a1dc590d7f6606eae4229bc5bc154dfd0">NCols</a></td></tr>
<tr class="memdesc:a1dc590d7f6606eae4229bc5bc154dfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns. <br/></td></tr>
<tr class="separator:a1dc590d7f6606eae4229bc5bc154dfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cddcd5d890869f325d2ffad5ef6ca9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cddcd5d890869f325d2ffad5ef6ca9c"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a8cddcd5d890869f325d2ffad5ef6ca9c">XMinimum</a></td></tr>
<tr class="memdesc:a8cddcd5d890869f325d2ffad5ef6ca9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum X coordinate. <br/></td></tr>
<tr class="separator:a8cddcd5d890869f325d2ffad5ef6ca9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52db671b51e00d23e843581efe0757bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52db671b51e00d23e843581efe0757bc"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a52db671b51e00d23e843581efe0757bc">YMinimum</a></td></tr>
<tr class="memdesc:a52db671b51e00d23e843581efe0757bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum Y coordinate. <br/></td></tr>
<tr class="separator:a52db671b51e00d23e843581efe0757bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc5d529f402206adfa937e05213b187"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dc5d529f402206adfa937e05213b187"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a8dc5d529f402206adfa937e05213b187">DataResolution</a></td></tr>
<tr class="memdesc:a8dc5d529f402206adfa937e05213b187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data resolution. <br/></td></tr>
<tr class="separator:a8dc5d529f402206adfa937e05213b187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efbd2a13fb330aa51490d9f09ca656a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0efbd2a13fb330aa51490d9f09ca656a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a0efbd2a13fb330aa51490d9f09ca656a">NoDataValue</a></td></tr>
<tr class="memdesc:a0efbd2a13fb330aa51490d9f09ca656a"><td class="mdescLeft">&#160;</td><td class="mdescRight">No data value. <br/></td></tr>
<tr class="separator:a0efbd2a13fb330aa51490d9f09ca656a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e7f94e44d15d24fe063efcd2e8062e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61e7f94e44d15d24fe063efcd2e8062e"></a>
map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a61e7f94e44d15d24fe063efcd2e8062e">GeoReferencingStrings</a></td></tr>
<tr class="memdesc:a61e7f94e44d15d24fe063efcd2e8062e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of strings for holding georeferencing information. <br/></td></tr>
<tr class="separator:a61e7f94e44d15d24fe063efcd2e8062e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134e1655f701796474746b0b2d6d2990"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a134e1655f701796474746b0b2d6d2990"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a134e1655f701796474746b0b2d6d2990">NJunctions</a></td></tr>
<tr class="memdesc:a134e1655f701796474746b0b2d6d2990"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of junctions. <br/></td></tr>
<tr class="separator:a134e1655f701796474746b0b2d6d2990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54acefb0ac3582effe9a23aa417694b"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ab54acefb0ac3582effe9a23aa417694b">SourcesVector</a></td></tr>
<tr class="memdesc:ab54acefb0ac3582effe9a23aa417694b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of the node indices that are sources.  <a href="#ab54acefb0ac3582effe9a23aa417694b">More...</a><br/></td></tr>
<tr class="separator:ab54acefb0ac3582effe9a23aa417694b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae530f042e059993e11eb8d88dac4625f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae530f042e059993e11eb8d88dac4625f"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ae530f042e059993e11eb8d88dac4625f">BaseLevelJunctions</a></td></tr>
<tr class="memdesc:ae530f042e059993e11eb8d88dac4625f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This vector lists the node index of the base level nodes that have a source within their catchements. <br/></td></tr>
<tr class="separator:ae530f042e059993e11eb8d88dac4625f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde373c6644923d3ca5abd3d6263b923"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acde373c6644923d3ca5abd3d6263b923"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#acde373c6644923d3ca5abd3d6263b923">JunctionVector</a></td></tr>
<tr class="memdesc:acde373c6644923d3ca5abd3d6263b923"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of the junctions. It is an index into the nodevector from the FlowInfo object. <br/></td></tr>
<tr class="separator:acde373c6644923d3ca5abd3d6263b923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad531fcfbb5e7554fd2e0bfcd58026d71"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ad531fcfbb5e7554fd2e0bfcd58026d71">StreamOrderVector</a></td></tr>
<tr class="memdesc:ad531fcfbb5e7554fd2e0bfcd58026d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stream order of the junction node/link.  <a href="#ad531fcfbb5e7554fd2e0bfcd58026d71">More...</a><br/></td></tr>
<tr class="separator:ad531fcfbb5e7554fd2e0bfcd58026d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3b374a8d782eb7f54289e386c18385"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec3b374a8d782eb7f54289e386c18385"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aec3b374a8d782eb7f54289e386c18385">BLBasinVector</a></td></tr>
<tr class="memdesc:aec3b374a8d782eb7f54289e386c18385"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector that give the baselevel index of each junction node. <br/></td></tr>
<tr class="separator:aec3b374a8d782eb7f54289e386c18385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d932b4f40383f36c5f053af8f5d833"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9d932b4f40383f36c5f053af8f5d833"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ac9d932b4f40383f36c5f053af8f5d833">NDonorsVector</a></td></tr>
<tr class="memdesc:ac9d932b4f40383f36c5f053af8f5d833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the number of donors to each junction. <br/></td></tr>
<tr class="separator:ac9d932b4f40383f36c5f053af8f5d833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e62dc721a8ea322d6c07b60715844b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e62dc721a8ea322d6c07b60715844b0"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a2e62dc721a8ea322d6c07b60715844b0">ReceiverVector</a></td></tr>
<tr class="memdesc:a2e62dc721a8ea322d6c07b60715844b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the node index of the receiving junction. <br/></td></tr>
<tr class="separator:a2e62dc721a8ea322d6c07b60715844b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5679fccce4dfc1485d2798a7215968a"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#ae5679fccce4dfc1485d2798a7215968a">DeltaVector</a></td></tr>
<tr class="separator:ae5679fccce4dfc1485d2798a7215968a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de29089b9a822a8afd3420f41d2410f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3de29089b9a822a8afd3420f41d2410f"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a3de29089b9a822a8afd3420f41d2410f">DonorStackVector</a></td></tr>
<tr class="memdesc:a3de29089b9a822a8afd3420f41d2410f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a vector that stores the donor junction of of the junction and is indexed by the DeltaVector. <br/></td></tr>
<tr class="separator:a3de29089b9a822a8afd3420f41d2410f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0884753878be4533eb8e28ac75f6d6"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aff0884753878be4533eb8e28ac75f6d6">SVector</a></td></tr>
<tr class="memdesc:aff0884753878be4533eb8e28ac75f6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This vector is used to calculate flow accumulation.  <a href="#aff0884753878be4533eb8e28ac75f6d6">More...</a><br/></td></tr>
<tr class="separator:aff0884753878be4533eb8e28ac75f6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba1228a2cb7728bd3ec95a3337ee525"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ba1228a2cb7728bd3ec95a3337ee525"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a4ba1228a2cb7728bd3ec95a3337ee525">SVectorIndex</a></td></tr>
<tr class="memdesc:a4ba1228a2cb7728bd3ec95a3337ee525"><td class="mdescLeft">&#160;</td><td class="mdescRight">This points to the starting point in the S vector of each node. <br/></td></tr>
<tr class="separator:a4ba1228a2cb7728bd3ec95a3337ee525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bc84aa22d45c561d5ad976240f3daf"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#a70bc84aa22d45c561d5ad976240f3daf">NContributingJunctions</a></td></tr>
<tr class="memdesc:a70bc84aa22d45c561d5ad976240f3daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of contributing junctions !!INCULDING SELF!! to a current pixel.  <a href="#a70bc84aa22d45c561d5ad976240f3daf">More...</a><br/></td></tr>
<tr class="separator:a70bc84aa22d45c561d5ad976240f3daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fcce75740658d6b655911f96fac58d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9fcce75740658d6b655911f96fac58d"></a>
Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aa9fcce75740658d6b655911f96fac58d">StreamOrderArray</a></td></tr>
<tr class="memdesc:aa9fcce75740658d6b655911f96fac58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This array stores the stream indices of all the channels. <br/></td></tr>
<tr class="separator:aa9fcce75740658d6b655911f96fac58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4f20576ed80f29c36d306f7627e89a"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aef4f20576ed80f29c36d306f7627e89a">JunctionArray</a></td></tr>
<tr class="memdesc:aef4f20576ed80f29c36d306f7627e89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This array stores a junction counter.  <a href="#aef4f20576ed80f29c36d306f7627e89a">More...</a><br/></td></tr>
<tr class="separator:aef4f20576ed80f29c36d306f7627e89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7b5523309aecc373b587ba604f3d1b"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_junction_network.html#aed7b5523309aecc373b587ba604f3d1b">JunctionIndexArray</a></td></tr>
<tr class="separator:aed7b5523309aecc373b587ba604f3d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Object to create a channel network from an <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afb42f26427d26fe1c51190125c343d65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDJunctionNetwork::LSDJunctionNetwork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This defines a channel network, is empty. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>30/07/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a1807746e8a8c665d7e6c7c0d26e7ab8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDJunctionNetwork::LSDJunctionNetwork </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>Sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This defines a channel network based on a FlowInfo object and a list of source nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
    <tr><td class="paramname">Sources</td><td>vector of source nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad39d182f738f3e8aaf921c9472ba30dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::add_to_stack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lm_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>j_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bl_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive add_to_stack routine to build the junction tree, from Braun and Willett (2012) equations 12 and 13. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lm_index</td><td>Integer </td></tr>
    <tr><td class="paramname">j_index</td><td>Integer </td></tr>
    <tr><td class="paramname">bl_node</td><td>Integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="abe72ea4fa4d35fab5c10c7f145d5940e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::calculate_junction_angle_statistics_for_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BasinOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>junction_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>junction_angle_averages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>junction_angle_stderr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>N_junctions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes the junction angle statistics for all basins of a given order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td>the <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">BasinOrder</td><td>the basin order of interest </td></tr>
    <tr><td class="paramname">junction_list</td><td>a vector of ints holding the junctions of interest is replaced in the function </td></tr>
    <tr><td class="paramname">junction_angle_averages</td><td>Average junction angles is replaced in the function </td></tr>
    <tr><td class="paramname">junction_angle_stder</td><td>a vector junction angle standard errors is replaced in the function </td></tr>
    <tr><td class="paramname">N_junctions</td><td>a vector of ints holding the numer of junctions in each larger basin is replaced in the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24/04/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a288fa7b3c05ecd32b1e6d2946e99f1be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDJunctionNetwork::calculate_junction_angle_statistics_upstream_of_junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the mean and standard error of every junction angle upslope of a given junction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_junction</td><td>The target junction </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>an <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of that has the mean and the standard error of the upslope junction angles </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23/04/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a1ed209a7fa8985c997a724029aa82cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;float&gt; LSDJunctionNetwork::calculate_junction_angle_statistics_upstream_of_junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold_SO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded function similar to above but removes any junctions not greater than threshold SO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_junction</td><td>The target junction </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>an <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">threshold_SO</td><td>threshold stream order to keep junctions (greater than this) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of that has the stats of the upslope junction angles </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>08/03/18 </dd></dl>

</div>
</div>
<a class="anchor" id="af480d83ed5f332a9a50dd1ac18ea3a5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; int, vector&lt; float &gt; &gt; LSDJunctionNetwork::calculate_junction_angles </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>JunctionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This calculates the junction angles based on a number of junctions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">JunctionList</td><td>a list of junctions </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>an <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of junction angles </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/04/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a19e6902731cbfcc3d6e38d34ff379c4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::calculate_pelletier_channel_heads </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tan_curv_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>tan_curv_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to predict channel head locations based on the method proposed by Pelletier (2013). </p>
<p>It creates a contour curvature map and identifies channel heads as pixels greater than a user defined contour curvature threshold value, set by default at 0.1. The threshold curvature can also be defined as a multiple of the standard deviation of the curvature. Before this function is called the DEM must be filtered using the wiener filter in the <a class="el" href="class_l_s_d_raster_spectral.html" title="This object performs spectral analysis. ">LSDRasterSpectral</a> object in order to remove high frequency noise.</p>
<p>Reference: Pelletier (2013) A robust, two-parameter method for the extraction of drainage networks from high-resolution digital elevation models (DEMs): Evaluation using synthetic and real-world DEMs, Water Resources Research 49: 1-15</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tan_curv_threshold</td><td>Double curvature threshold value. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>Flow Info object </td></tr>
    <tr><td class="paramname">tan_curv_array</td><td>2D array of tangential curvature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2D array of predicted channel head locations. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/07/13 </dd></dl>

</div>
</div>
<a class="anchor" id="aa6df45bea95af208aa160967fc566105"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::calculate_pelletier_channel_heads_DTM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>topography</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tan_curv_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>tan_curv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>tan_curv_array_LW</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function predicts channel head locations based on a tangential threshold as proposed by Pelletier (2013). </p>
<p>This function is used to predict channel head locations based on the method proposed by Pelletier (2013). First it creates a contour curvature map and identifies channel heads as pixels with tangential curvature greater than a user defined threshold value. This map needed to be reduced to give the source pixels only. This is done by i) sorting all the possible sources by elevation and ii) routing flow from each potential source using an adaption of Freeman MD flow. Any potential sources that are located on ANY down-slope pathway within convergent part of the topography from previously visited source pixels are excluded.</p>
<p>Reference: Pelletier (2013) A robust, two-parameter method for the extraction of drainage networks from high-resolution digital elevation models (DEMs): Evaluation using synthetic and real-world DEMs, Water Resources Research 49: 1-15</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td>object </td></tr>
    <tr><td class="paramname">raster</td><td>containing elevation data </td></tr>
    <tr><td class="paramname">a</td><td>threshold value of tangential curvature </td></tr>
    <tr><td class="paramname">an</td><td>array of tangential curvature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>03/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a871cc7c5b542d93d8f757e849d063a72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDJunctionNetwork::calculate_relief_from_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold_SO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calculates the relief of each pixel compared to the nearest downstream channel pixel equal or greater to the threshold stream order </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ElevationRaster</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> with elevations </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">threshold_SO</td><td>threshold stream order to calculate relief from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> with channel relief </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/11/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a213a3d01866f3de14d360fe5bc59c81b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDJunctionNetwork::calculate_relief_from_channel_connected_components </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ConnectedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DistFromOutlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold_SO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calculates the relief of each pixel compared to the nearest downstream channel pixel equal or greater to the threshold stream order for that connected components patch </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ElevationRaster</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> with elevations </td></tr>
    <tr><td class="paramname">ConnectedComponents</td><td>connected components raster </td></tr>
    <tr><td class="paramname">DistFromOutlet</td><td>raster of flow lengths </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">threshold_SO</td><td>original threshold stream order to calculate relief from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> with channel relief </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/09/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a2d598a23b425249001ab0e1032f171d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::ChannelIndexer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>flowinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function iterates through the junction nodes and assigns the unique junction ID to every stream pixel. </p>
<p>This can be used with the <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> hilltop_flow_routing function to assign a unique ID to each hilltop section tying it to a specific section of the channel network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flowinfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the indexed channel newtork. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a7192d553ee1c3389b242f3d48e476ffc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::check_stream_order_of_upstream_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether any of the upstream nodes of a given junction are the same steam order as the junction itself. It returns an integer value which is 1 if the SO is the same and 0 if it is not the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">junction</td><td>junction of interest </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value 0 or 1 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC and MAH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/03/16 </dd></dl>

</div>
</div>
<a class="anchor" id="af0ae8ad114fda70ca426f233da32b7bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::extract_basin_from_junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>basin_junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>basin_reference_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the node indices of outlets of basins of a certain order. </p>
<p>IMPORTANT: The junctions always point downstream since they can have one and only one receiver. However, for a basin of given order, this starts just upstream of the confluence to the next basin order. So the basin <b>INCLUDES</b> the channel flowing downstream to the penultamite node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basin_junction</td><td>Junction of basin to be extracted. </td></tr>
    <tr><td class="paramname">basin_reference_number</td><td>Reference number for printing to the IndexRaster. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of extracted basin. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a30a2ca5fb541d19eb2c5d8e0e3ef5e60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::extract_basin_junctions_from_nodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>basin_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts basin junctions from a list of basin outlet nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basin_nodes</td><td>list of basin outlet nodes </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of basin junctions </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ab09e0871448035a329b4bb959247a0ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::extract_basin_nodes_above_drainage_area_threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>DrainageAreaThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts nodes where the basins of both tributaries are greater than a certain drainage area threshold. Moves downstream from sources to baselevel so that nested catchments will be selected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
    <tr><td class="paramname">DrainageAreaThreshold</td><td>Threshold drainage area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of basin nodes. These are the nodes just upstream of the outlet junction at the confluence of the basins. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/01/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a68178de68987b2b8fc940837cf07fc75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::extract_basin_nodes_by_drainage_area </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>DrainageAreaThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts basin nodes according to their accumulated drainage area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Threshold</td><td>Threshold drainage area. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of basin nodes. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>07/05/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a6878d97c41e1a3bac6fcae888232c15d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::extract_basins_from_junction_vector </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>basin_junctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of basins draining from a vector of junctions. </p>
<p>IMPORTANT: The junctions always point downstream since they can have one and only one receiver. However, for a basin of given order, this starts just upstream of the confluence to the next basin order. So the basin <b>INCLUDES</b> the channel flowing downstream to the penultamite node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basin_junctions</td><td>Vector of junction numbers of basins to be extracted. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of extracted basin. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a64918a2da1abf5543f4793c069550045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::extract_basins_from_junction_vector_nested </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>basin_junctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of basins draining from a vector of junctions. </p>
<p>IMPORTANT: The junctions always point downstream since they can have one and only one receiver. However, for a basin of given order, this starts just upstream of the confluence to the next basin order. So the basin <b>INCLUDES</b> the channel flowing downstream to the penultamite node. UPDATED so that if basins are nested, they don't overwrite each other - basins are sorted by the number of contributing pixels, and the smaller basins are written first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basin_junctions</td><td>Vector of junction numbers of basins to be extracted. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of extracted basin. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/01/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a120542ae0b90784c40b86a6cb7c33283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::extract_basins_from_junctions_rudimentary </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>junctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of basins draining from a vector of junctions. </p>
<p>IThis is a highly rudimentary version, which just collects all the upslope nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basin_junctions</td><td>Vector of junction numbers of basins to be extracted. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of extracted basin. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>08/05/15 </dd></dl>

</div>
</div>
<a class="anchor" id="ad61962a040dece1e354209e13717448a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::extract_basins_order_outlet_junctions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BasinOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This extracts the junction numbers, in a vector of integers, of all basins of a given order. </p>
<p>For basins, the basin includes nodes downstream of the basinJunction, until the penulatmite node in this downstream channel.</p>
<p>IMPORTANT: the junctions always point downstream since they can have one and only one receiver. However, for a basin of given order, this starts just upstream of the confluence to the next basin order. So the basin <b>INCLUDES</b> the channel flowing downstream to the penultamite node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BasinOrder</td><td>Integer of the basin order. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of junctions of basins of given order. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a58eda65d1ed1ae4de1d61640f1516f2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::extract_basins_order_outlet_nodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>BasinOutletJunctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function gets the outlet node of a list of basins. </p>
<p>The basin outlet node is <em>DOWNSTREAM</em> from the outlet junction, it is the penultamite node of the channel index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BasinOutletJunctions</td><td></td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of outlet nodes of basins. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a4777080ace73ce3f5afeab49a662f283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::extract_hollow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CH_junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts a single hollow from a given channel head junction. </p>
<p>The junction index of channel heads can be extracted using <a class="el" href="class_l_s_d_junction_network.html#a5038fd71848da0bb949a65f05f7b708a" title="This function converts a list of sources used to generate the initial channel network into a list of ...">LSDJunctionNetwork.Get_Channel_Head_Junctions</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CH_junction</td><td>Junction index to extract. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the extracted hollow, coded with junction number. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>05/12/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a805b7b34f337af52776b7b4f1124e29a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::extract_hollow </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>CH_junctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts a series of hollows from a vector of channel head junctions. </p>
<p>The junction index of channel heads can be extracted using <a class="el" href="class_l_s_d_junction_network.html#a5038fd71848da0bb949a65f05f7b708a" title="This function converts a list of sources used to generate the initial channel network into a list of ...">LSDJunctionNetwork.Get_Channel_Head_Junctions</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CH_junctions</td><td>Vector of juntions to extract. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the extracted hollows, coded with junction numbers. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>05/12/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a01765e9bb2f75defc8b3fcf4a08a46d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::extract_tributary_junctions_to_main_stem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_channel.html">LSDIndexChannel</a> &amp;&#160;</td>
          <td class="paramname"><em>MainStem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>tributary_junctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes_on_main_stem_of_tributaries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets tributaries along a continous channel. </p>
<p>What it does is goes down the index channel looking at the JunctionIndexArray to see if there is a junction. If it hits a junction then all the contributing junction it overwrites two vectors: <br/>
tributary_junctions, which lists all junctions whose reciever is the main stem and nodes_on_main_stem_of_tributaries, which are the njodes on the main_stem <a class="el" href="class_l_s_d_index_channel.html" title="This object contains the node indexes as well as the row and col indices for individual channel segme...">LSDIndexChannel</a> where the tributaries intersect the main stem this second vector is used to calcualte the chi values of the downstream node of the tributaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MainStem</td><td><a class="el" href="class_l_s_d_index_channel.html" title="This object contains the node indexes as well as the row and col indices for individual channel segme...">LSDIndexChannel</a> of the main stem. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
    <tr><td class="paramname">tributary_junctions</td><td></td></tr>
    <tr><td class="paramname">nodes_on_main_stem_of_tributaries</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="af35061b9f2025be4f7cb1968af6e4070"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::ExtractBasinJunctionOrder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BasinOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts the juctions of all non-beheaded drainage basins of a given order, n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BasinOrder</td><td>Integer basin order to extract. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of junction indexes. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a816391193d54949ae6a74921718dfdba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::ExtractBasinJunctionOrderKeepEdgeBasins </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BasinOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts the juctions of all non-beheaded drainage basins of a given order, n. Like the previous version but in this case includes basins at the edge (abutting nodata) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BasinOrder</td><td>Integer basin order to extract. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of junction indexes. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/04/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a1299d32f7cc52cfd557b93ffb4b6c7a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::ExtractBasinsOrder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BasinOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basin extraction - extracts all drainage basins of specified stream order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BasinOrder</td><td>Integer basin order to extract. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of extracted basins. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/10/2012 </dd></dl>

</div>
</div>
<a class="anchor" id="a904b79b71676df41c10cb1118eafcb37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDJunctionNetwork::ExtractHilltops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>RidgeRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>SlopeRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>MaxSlope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This last function gets the hilltops: ridges limited by a maximum slope. </p>
<p>Resticts ridgeline to part of ridge network where the slope is less than a threshold value.</p>
<p>Now outputs an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to fall in line with other hilltop tools - SWDG 29/8/13 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RidgeRaster</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of extracted ridges. </td></tr>
    <tr><td class="paramname">SlopeRaster</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of slope. </td></tr>
    <tr><td class="paramname">MaxSlope</td><td>Maximum threshold slope value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of hilltops. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/04/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a29b1f20e6efcdcc9c2b59e307822a71d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDJunctionNetwork::ExtractRidges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ridge network extraction - extracts ridge network, defined as boundaries between two basins of the same stream order. </p>
<p>This function extracts the ridge network by defining it as the co-boundaries of basins of equivalent order, for all basin orders within the landscape. This is relatively trivial since in each array containing the basins of the same order, each basin is labelled with a unique identifier, thus co- boundaries are found by locating pixels that neighbour pixels from another basin of the same order.</p>
<p>Updated to return an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object as ridges can now be assigned CHT values, using <a class="el" href="class_l_s_d_raster.html#afca4a22a3e5ea44a2eb2d0224ec40766" title="Module to sample LSDRaster values running along a ridgetop network. ">LSDRaster::RidgeSample</a>, which are not integers. - SWDG </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of ridges. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/10/2012 </dd></dl>

</div>
</div>
<a class="anchor" id="aa9c4bb0eab32e63172bf758ec1fa7410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDJunctionNetwork::ExtractRidges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>min_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>max_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overloaded function extracts the ridge network for a defined stream order, passed in by the user.</p>
<p>Updated to return an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object as ridges can now be assigned CHT values, using <a class="el" href="class_l_s_d_raster.html#afca4a22a3e5ea44a2eb2d0224ec40766" title="Module to sample LSDRaster values running along a ridgetop network. ">LSDRaster::RidgeSample</a>, which are not integers. - SWDG </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
    <tr><td class="paramname">min_order</td><td>Lowest order of ridges to extract. </td></tr>
    <tr><td class="paramname">max_order</td><td>Highest order of ridges to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of ridges. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM, SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/10/2012, 28/03/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="ab91261ebe8074b335bbe1f915f9afb60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::find_base_level_node_of_junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>StartingJunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions takes a junction number and then follwos the receiver junctions until it hits a baselevel junction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>junction node to start from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base level junction to which the starting junction drains </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/02/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ac0f5239ed6c7ec0188fb6c7ab0da4c56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDJunctionNetwork::find_distance_to_nearest_floodplain_pixel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>point_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FloodplainRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the node index of the nearest FIP to a specified node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_node</td><td>Node to start with </td></tr>
    <tr><td class="paramname">search_distance</td><td>Distance to search upstream and downstream for a FIP </td></tr>
    <tr><td class="paramname">FloodplainRaster</td><td>Raster with binary floodplain </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node index of nearest FIP </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>09/09/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a0efcf3f6ab36e85282751a2ea86e2296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDJunctionNetwork::find_mean_elevation_of_channel_reach </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>StartingNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function finds the mean elevation of the channel reach given a node on the channel network </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StartingNode</td><td>node to check </td></tr>
    <tr><td class="paramname">search_distance</td><td>reach distance - will check both upstream and downstream this distance </td></tr>
    <tr><td class="paramname">ElevationRaster</td><td>elevation raster </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mean elevation of reach </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/09/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a1532af1ec0bfea04d57c283045d5cd7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::find_upstream_junction_from_channel_nodeindex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ChannelNodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a node index, checks to see if it is on a channel, and then works its way up the channel to find the upstream junction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelNodeIndex</td><td>is the node index of the channel node (if it isn't a channel the function returns NoDataValue </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the Junction Number of the nearest upslope junction </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a8e9fe1201077fc24bc77340c8d1fcecb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; int &gt; LSDJunctionNetwork::find_valleys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>tan_curv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_connecting_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tan_curv_threshold</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to identify concave portions of the landscape using a tangential curvature threshold. </p>
<p>It defines the threshold based on a multiple of the standard deviation of the curvature. It then identifies valleys in which there are a linked series of pixels which have a curvature value greater than the threshold, and finds the outlet junction number of this valley. This can be passed to the channel head prediction algorithm using the chi method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">tan_curv_array</td><td>2D array with curvature </td></tr>
    <tr><td class="paramname">sources</td><td>vector with sources of channel network </td></tr>
    <tr><td class="paramname">no_connecting_nodes</td><td>number of nodes that need to be above the threshold before the valley is identified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array2D&lt;int&gt; with nodes at the base of each of the valleys </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a9e260d6b2544fb8f364a7646b6f71d54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; int &gt; LSDJunctionNetwork::find_valleys_adaptive_threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>tan_curv_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_connecting_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>tan_curv_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to identify concave portions of the landscape using a tangential curvature threshold which is adaptive for each portion of the landscape. </p>
<p>It defines the threshold based on the standard deviation of the curvature. It then identifies valleys in which there are a linked series of pixels which have a curvature value greater than the threshold, and finds the outlet junction number of this valley. This can be passed to the channel head prediction algorithm using the chi method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">tan_curv_array</td><td>2D array with curvature </td></tr>
    <tr><td class="paramname">sources</td><td>vector with sources of channel network </td></tr>
    <tr><td class="paramname">no_connecting_nodes</td><td>number of nodes that need to be above the threshold before the valley is identified </td></tr>
    <tr><td class="paramname">tan_curv_threshold</td><td>array with the curvature thresholds for each row and col </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array2D&lt;int&gt; with nodes at the base of each of the valleys </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="affa235034604fe83a9e96ab91a525ddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; int &gt; LSDJunctionNetwork::find_valleys_using_channel_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>channel_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_connecting_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function uses a predefined channel mask to locate valley junctions. </p>
<p>This uses the same approach as the find_valleys function, but allows greater flexibility in how the valley network is defined</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">channel_mask</td><td>2D binary array with multi-pixel channel network marked by 1s </td></tr>
    <tr><td class="paramname">sources</td><td>vector with sources of channel network </td></tr>
    <tr><td class="paramname">no_connecting_nodes</td><td>number of nodes that need to be above the threshold before the valley is identified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array2D&lt;int&gt; with nodes at the base of each of the valleys </dd></dl>

</div>
</div>
<a class="anchor" id="a1f4efde43de44a3a5e131d8b0d5e0a69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::FindFarthestUpslopeHilltopsFromSources </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>JunctionNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get farthest upslope hilltops. </p>
<p>This function looks at all the source junctions in a network upstream of a given junction and returns the node index of the hilltop node that is the farthest upstream from the source junction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">JunctionNumber</td><td>the junction number upstream of which you want to search for sources </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>the flow info object </td></tr>
    <tr><td class="paramname">FlowDistance</td><td>distance upslope </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;int&gt; a vector of node indices to the ridge nodes that are farthest upslope of the sources </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/09/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a3fbc073a080a8c54f000c3904b9ab678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_channel.html">LSDIndexChannel</a> LSDJunctionNetwork::generate_link_index_channel_from_junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This generates an LSDChannelIndex object given a junction. </p>
<p>NOTE: junctions start at the upstream end of the channel section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_junction</td><td>Junction to extract the channel from. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The channel for the given junction. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a425ffd07f5f5c1829070781f83c4d974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_channel.html">LSDIndexChannel</a> LSDJunctionNetwork::generate_longest_index_channel_from_junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outlet_junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>dist_from_outlet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts the longest channel originating from a junction number outlet_junction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outlet_junction</td><td>Outlet of junction. </td></tr>
    <tr><td class="paramname">FInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
    <tr><td class="paramname">dist_from_outlet</td><td>Distance from outlet junction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the longest channel. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a3b8e79c1a4c0e3802d516ac3c41ccdf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_channel.html">LSDIndexChannel</a> LSDJunctionNetwork::generate_longest_index_channel_in_basin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>basin_junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>dist_from_outlet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This generates the longest channel in a basin. </p>
<p>The basin starts where a channel of some order intersects with a channel of higher order. So the bain includes the basin junction, but also the channel flowing downstream from this basin junction. It starts from the node of the reciever junction, so if one were to extract the basin from this node one would get a basin that starts one node upstream from the lowest node in this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basin_junction</td><td></td></tr>
    <tr><td class="paramname">FInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
    <tr><td class="paramname">dist_from_outlet</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the longest channel. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a53e8ccf64a0ac88d0cde7ffa3e8330fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_all_source_junctions_of_an_outlet_junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>junction_number_outlet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This finds all the junctions that are source junctions upslope of a given junction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">junction_number_outlet</td><td>The junction number of the outlet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>source_junctions a vector of junction numbers: these are the sources </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/05/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a3e33e2d37d483f691784acd970c65c0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_all_source_nodes_of_an_outlet_junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>junction_number_outlet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This finds all the nodes that are source nodes upslope of a given junction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">junction_number_outlet</td><td>The junction number of the outlet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>source_nodes a vector of node numbers: these are the sources the nodes are node indices from the FlowInof object </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19/05/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a993913490fc153f93e4f84fe3e74e2d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_BaseLevel_DonorJunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets the largest donor junction to the baselevel nodes so that you can automate basin selection. (e.g. for use with chi analysis) </p>
<p>This function returns a integer vector containing the junction number of the largest donor catchment (i.e. donor junction with greatest drainage area) upslope of each baselevel node. These can then be used as the starting locations for performing chi analysis.</p>
<p>IMPORTANT: the junctions always point downstream since they can have one and only one receiver. However, for a basin of given order, this starts just upstream of the confluence to the next basin order. So the basin <b>INCLUDES</b> the channel flowing downstream to the penultamite node. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer vector containing the junction number of the largest donor catchment. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>MDH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19/6/13 </dd></dl>

</div>
</div>
<a class="anchor" id="aaba42cc7730347f00c18ca30045a8105"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDJunctionNetwork::get_BaseLevelJunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Get the baselevel junstions </dd></dl>

</div>
</div>
<a class="anchor" id="a4d87a7f352be432a313cd710f697e2f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_basin_sources_from_outlet_vector </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>basin_junctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>dist_from_outlet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This generates the upstream source nodes from a vector of basin junctions. </p>
<p>The basin starts where a channel of some order intersects with a channel of higher order. So the bain includes the basin junction, but also the channel flowing downstream from this basin junction. It starts from the node of the reciever junction, so if one were to extract the basin from this node one would get a basin that starts one node upstream from the lowest node in this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basin_junction</td><td></td></tr>
    <tr><td class="paramname">FInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
    <tr><td class="paramname">dist_from_outlet</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the longest channel. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/03/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a5038fd71848da0bb949a65f05f7b708a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::Get_Channel_Head_Junctions </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>Sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts a list of sources used to generate the initial channel network into a list of junction indexes of channel heads which can be used to extract hollows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Sources</td><td>A vector of source nodes that correspond to channel heads. </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of junction indexes for each channel head. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>05/12/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a45ab8aa85777cfaea0b6f7ec6ee7ffd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_channel_pixels_along_line </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>line_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>line_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold_SO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets all the pixels along a line defined by a series of points and finds the pixels greater than a specified stream order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Points</td><td><a class="el" href="struct_point_data.html">PointData</a> object with the points </td></tr>
    <tr><td class="paramname">ElevationRaster</td><td>raster of elevations </td></tr>
    <tr><td class="paramname">threshold_SO</td><td>threshold stream order </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/04/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a868e9d936a6d802f64ef75573c1d636a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_contributing_pixels_from_specified_junctions </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>JunctionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowAcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You give this a list of junction numbers and it returns the number of upslope pixels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseLevelJunctions_Initial</td><td>a vector of integers containg an inital list of base level nodes </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>The <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">FlowAcc</td><td>an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with the number of pixels for flow accumulation </td></tr>
    <tr><td class="paramname">Threshold</td><td>The minimum number of accumulated pixels needed to keep a base level node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with the N contributing pixels for the junctions specified </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/06/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a1ebb318b92e4ff303396ae0bdd24bd47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDJunctionNetwork::get_DataResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Data resolution as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5990bfef78ee423bdcecb247c0ef36d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_donor_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function gets a list of the junction indices of the donors to a particular junction  IMPORTANT: this has only retained the string "node" to keep equivalence with the FlowInfo object. It takes junctions and returns junctions!! Also note that base level nodes have themselves as a donor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>this is the nodeindex of the node for which you want to find the donors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of the donor nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15/06/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a29e8ef760e1e4cd97814b8c3008c553b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_downstream_junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>starting_junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get downstream junction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_junction</td><td>starting junction </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer with downstream junction number </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>08/10/15 </dd></dl>

</div>
</div>
<a class="anchor" id="af217731f518d2386957a1682ccedfdf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; int &gt; LSDJunctionNetwork::Get_Elevation_of_Nearest_Channel_for_Connected_Components </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ConnectedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DistFromOutlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold_SO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function takes in a raster of connected component patches. It finds the elevation of the nearest channel for the patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ConnectedComponents</td><td>connected components raster </td></tr>
    <tr><td class="paramname">ElevationRaster</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of elevations </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">DistFromOutlet</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of flow lengths </td></tr>
    <tr><td class="paramname">threshold_SO</td><td>threshold stream order to calculate relief from </td></tr>
    <tr><td class="paramname">search_distance</td><td>length of channel reach to get elevation from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2D array with the elevation of nearest channel for each patch </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/09/16 </dd></dl>

</div>
</div>
<a class="anchor" id="aec4b5f46641df5ab68401ac699d8c28b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string,string&gt; LSDJunctionNetwork::get_GeoReferencingStrings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Georeferencing information </dd></dl>

</div>
</div>
<a class="anchor" id="af43dc7e1a8cb2cb3923c405127fddf94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::get_info_nearest_channel_to_node </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>StartingNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>threshold_SO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DistFromOutlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ChannelNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>FlowLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>DistanceUpstream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get info about the nearest channel node of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StartingNode</td><td>index of node of interest </td></tr>
    <tr><td class="paramname">threshold_SO</td><td>threshold stream order for finding the nearest channel </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">DistFromOutlet</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of flow lengths </td></tr>
    <tr><td class="paramname">ChannelNode</td><td>int to store the NI of the nearest channel </td></tr>
    <tr><td class="paramname">FlowLength</td><td>float to store the flow length to the nearest channel </td></tr>
    <tr><td class="paramname">DistanceUpstream</td><td>float to store the distance upstream of the nearest channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/09/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a9191be7f7a307b89a53014d07cfb9692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::get_info_nearest_channel_to_node_main_stem </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>StartingNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DistFromOutlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_channel.html">LSDIndexChannel</a> &amp;&#160;</td>
          <td class="paramname"><em>MainStem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ChannelNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>FlowLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>DistanceUpstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>Relief</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get info about the nearest channel node on the main stem of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StartingNode</td><td>index of node of interest </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">ElevationRaster</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of elevations </td></tr>
    <tr><td class="paramname">DistFromOutlet</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of flow lengths </td></tr>
    <tr><td class="paramname">ChannelNode</td><td>int to store the NI of the nearest channel </td></tr>
    <tr><td class="paramname">FlowLength</td><td>float to store the flow length to the nearest channel </td></tr>
    <tr><td class="paramname">DistanceUpstream</td><td>float to store the distance upstream of the nearest channel </td></tr>
    <tr><td class="paramname">Relief</td><td>float to store relief compared to nearest channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>05/10/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a5ecaf7e1d912c71d9aef7b7684681262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_junction_of_nearest_channel_from_lat_long </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>latitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>longitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a>&#160;</td>
          <td class="paramname"><em>Converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to snap input coordinates to the nearest channel node from latitude and longitude. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latitude</td><td></td></tr>
    <tr><td class="paramname">longitude</td><td></td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
    <tr><td class="paramname">Converter</td><td><a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the NodeIndex of the nearest channel node. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/11/17 </dd></dl>

</div>
</div>
<a class="anchor" id="ab4da4a7eaf3ff7f3cadf122550fc35e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_Junction_of_Node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets the junction number of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Node</td><td></td></tr>
    <tr><td class="paramname">FlowInfo</td><td>Flow Info object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JunctionNumber </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>31/10/13 </dd></dl>

</div>
</div>
<a class="anchor" id="aff034fabc2f1d6c7dc908140e9667b66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_Junctions_of_Sources </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets the junction number all the sources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td>Flow Info object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of junctions from all the sources </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>08/05/15 </dd></dl>

</div>
</div>
<a class="anchor" id="ad5552c1deacf167134d831758e94a9ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDJunctionNetwork::get_JunctionVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The Vector of Junctions. Note that these are the node indices of the junctions. The junction numbers just go from 0 to NJunctions </dd></dl>

</div>
</div>
<a class="anchor" id="a547da43828e94bcf7e441485a541a570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::get_lat_and_long_locations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>longitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a>&#160;</td>
          <td class="paramname"><em>Converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function to get the lat and long of a node in the raster  Assumes WGS84 ellipsiod </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the node </td></tr>
    <tr><td class="paramname">col</td><td>the col of the node </td></tr>
    <tr><td class="paramname">lat</td><td>the latitude of the node (in decimal degrees, replaced by function) Note: this is a double, because a float does not have sufficient precision relative to a UTM location (which is in metres) </td></tr>
    <tr><td class="paramname">long</td><td>the longitude of the node (in decimal degrees, replaced by function) Note: this is a double, because a float does not have sufficient precision relative to a UTM location (which is in metres) </td></tr>
    <tr><td class="paramname">Converter</td><td>a converter object (from LSDShapeTools) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a4071c346788998d9a9614bebb7de50b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_maximum_stream_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the maximum stream order in the DEM. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum stream order as an integer. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="acc419ef163d08965e40786078036d371"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_NCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of columns as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a891b77edfcc93b7e92da1bb39903a3f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_Next_StreamOrder_Junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>junction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This gets the junction that is at the next Strahler stream order from the current junction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">junction</td><td>the current junction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the junction that is at the next stream order if the next stream order is not reached before baselevel it returns a NoDataValue </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/10/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a351c374b2aa41f951d46c4b8c45dc1f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_NJunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of junctions </dd></dl>

</div>
</div>
<a class="anchor" id="a46f82f0a323e07e7704dfcadae6eacb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_NoDataValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>No Data Value as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ac86067f9ab2ff0b296fc44d577731e1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_node_list_from_junction_list </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>junction_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a node list from a junction list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">junction_list</td><td>a vector of junctions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/01/2018 </dd></dl>

</div>
</div>
<a class="anchor" id="a7d8f03d3d2edd169b42f0aef4ea2cac3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_node_list_of_penultimate_node_from_junction_list </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>junction_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a node list from a junction list. The nodes are the penultimate nodes before the reciever juctions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">junction_list</td><td>a vector of junctions </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>the <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/01/2018 </dd></dl>

</div>
</div>
<a class="anchor" id="a5c3f4453cbd44f4fee7adfe08651a825"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_Node_of_Junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>junction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the node of a junction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">junction</td><td>integer node index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer node of junction. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ae9f463ea8d35bd7465d3a4aaafb4cb7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_nodeindex_of_nearest_channel_for_specified_coordinates </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>X_coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Y_coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold_stream_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_radius_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to snap input coordinates to the nearest channel node. This enables easy extraction of a particular catchment for analysis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X_coordinate</td><td>of point. In coordiantes of DEM (usually UTM). </td></tr>
    <tr><td class="paramname">Y_coordinate</td><td>of point. In coordiantes of DEM (usually UTM). </td></tr>
    <tr><td class="paramname">threshold_stream_order</td><td>The minimum stream order that will be considers a 'channel' by the algorithm </td></tr>
    <tr><td class="paramname">search_radius_nodes</td><td>the radius of the kernal used to check if there is a nearby channel. A radius of 0 only includes the centre point, a radius of 1 has a kernal diameter of 3, radius of 2 has a kernal diameter of 5 and so on </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the NodeIndex of the nearest channel node. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="ae9026182e24ceddc156da2767c898451"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_NRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of rows as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a469924e6d87c33fdd4b79ff886abd236"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_number_of_streams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stream_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the number of streams of a given stream order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">stream_order</td><td>Stream order of interest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer with number of streams. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15/03/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a792eb222ef8579b40b74a79b770e71a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_outlet_nodes_from_sources </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>sources</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to get the outlet nodes from a vector of input source nodes. </p>
<p>It is used to get a list of valley nodes that can be used in the DrEICH algorithm. The function goes downstream from each source node until the stream order of the downstream node is greater than that of the current node</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">sources</td><td>vector with sources of channel network </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;int&gt; with node at the base of each of the valleys </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19/08/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a6e1452172d2f74c1a9237c32e104a35a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::get_overlapping_channels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>BaseLevel_Junctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DistanceFromOutlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>source_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outlet_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_nodes_to_visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overwrites two vecotrs that give all of the starting and finishing nodes of channels in a basin </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td>an <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">BaseLevel_Junctions</td><td>an integer vector that contains the base level junctions </td></tr>
    <tr><td class="paramname">DistanceFromOutlet</td><td>an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> with the flow distance </td></tr>
    <tr><td class="paramname">source_nodes</td><td>a vector continaing the sorted sorce nodes (by flow distance) THIS GETS OVERWRITTEN </td></tr>
    <tr><td class="paramname">outlet_nodes</td><td>a vector continaing the outlet nodes THIS GETS OVERWRITTEN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/05/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a55091e049773f8344954e50c99c2ad3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::get_overlapping_channels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>BaseLevel_Junctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DistanceFromOutlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>source_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outlet_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>baselevel_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_nodes_to_visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overwrites two vecotrs that give all of the starting and finishing nodes of channels in a basin </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td>an <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">BaseLevel_Junctions</td><td>an integer vector that contains the base level junctions </td></tr>
    <tr><td class="paramname">DistanceFromOutlet</td><td>an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> with the flow distance </td></tr>
    <tr><td class="paramname">source_nodes</td><td>a vector continaing the sorted sorce nodes (by flow distance) THIS GETS OVERWRITTEN </td></tr>
    <tr><td class="paramname">outlet_nodes</td><td>a vector continaing the outlet nodes THIS GETS OVERWRITTEN </td></tr>
    <tr><td class="paramname">baselevel_nodes</td><td>a vector continaing the baselevel nodes (i.e. the node of the outlet of the basin) THIS GETS OVERWRITTEN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/06/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a0a5f4e316dd36c449518b466438c5965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::get_overlapping_channels_to_downstream_outlets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>BaseLevel_Junctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DistanceFromOutlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>source_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outlet_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_nodes_to_visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overwrites two vectors that give all of the starting and finishing nodes of channels in a basin continuing downstream from the selected junction to its outlet </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td>an <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">BaseLevel_Junctions</td><td>an integer vector that contains the base level junctions </td></tr>
    <tr><td class="paramname">DistanceFromOutlet</td><td>an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> with the flow distance </td></tr>
    <tr><td class="paramname">source_nodes</td><td>a vector continaing the sorted sorce nodes (by flow distance) THIS GETS OVERWRITTEN </td></tr>
    <tr><td class="paramname">outlet_nodes</td><td>a vector continaing the outlet nodes THIS GETS OVERWRITTEN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>MDH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/6/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a9f1dff71bfe8d9e180a847c7276b2041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::get_overlapping_channels_to_downstream_outlets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>BaseLevel_Junctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DistanceFromOutlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>source_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outlet_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>baselevel_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_nodes_to_visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I THINK THIS MIGHT CAUSE A SEG FAULT: NEED TO UPDATE!!!!! </p>
<p>This overwrites two vectors that give all of the starting and finishing nodes of channels in a basin continuing downstream from the selected junction to its outlet </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td>an <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">BaseLevel_Junctions</td><td>an integer vector that contains the base level junctions </td></tr>
    <tr><td class="paramname">DistanceFromOutlet</td><td>an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> with the flow distance </td></tr>
    <tr><td class="paramname">source_nodes</td><td>a vector continaing the sorted sorce nodes (by flow distance) THIS GETS OVERWRITTEN </td></tr>
    <tr><td class="paramname">outlet_nodes</td><td>a vector continaing the outlet nodes THIS GETS OVERWRITTEN </td></tr>
    <tr><td class="paramname">baselevel_nodes</td><td>a vector continaing the baselevel nodes (i.e. the node of the outlet of the basin) THIS GETS OVERWRITTEN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/6/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a5bb9c6ebec401ac3899732d15de3fbe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_penultimate_node_from_stream_link </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upstream_junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the penultimate node of the stream link below given junction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upstream</td><td>junction of desired stream link </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node index (for FlowInfo) of penultimate node in stream link </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/06/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a3c19d30170d031509cab846f5adc95c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_pruned_tributaries_from_main_stem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_junction_network.html">LSDJunctionNetwork</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>starting_junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DistanceFromOutlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pruning_switch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pruning_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function gets the tributary junctions upstream of the starting_junction based on pruning criteria. </p>
<p>This function extracts tributaries juncions to the main stem of the channel, then selects a sample based on various criteria set by an integer called pruning switch <br/>
<br/>
pruning_switch == 0 channels are only added if they exceed a threshold drainage area <br/>
pruning_switch == 1 channels are only added if the ratio between them and the mainstem exceeds a certain value (pruning_threshold)<br/>
pruning_switch == 2 channels are only added if the ratio between them and the area of the mainstem <em>at the junction</em> exceeds a certain value<br/>
pruning_switch == 3 channels are only added if the channel order is &gt;= threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
    <tr><td class="paramname">ChannelNetwork</td><td><a class="el" href="class_l_s_d_junction_network.html" title="Object to create a channel network from an LSDFlowInfo object. ">LSDJunctionNetwork</a> object. </td></tr>
    <tr><td class="paramname">starting_junction</td><td></td></tr>
    <tr><td class="paramname">DistanceFromOutlet</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of outlet distances. </td></tr>
    <tr><td class="paramname">pruning_switch</td><td></td></tr>
    <tr><td class="paramname">pruning_threshold</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pruned tributary junctions. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>30/04/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a77781e76c57a03ffdf2ec887b33bafc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_receiver_junction_for_specified_coordinates </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>X_coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Y_coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to snap input coordinates to the nearest junction. This enables easy extraction of a particular catchment for analysis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X_coordinate</td><td>of point. In coordiantes of DEM (usually UTM). </td></tr>
    <tr><td class="paramname">Y_coordinate</td><td>of point. In coordiantes of DEM (usually UTM). </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a70bf86aa84503de0d4394f1a5a5394b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_Receiver_of_Junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>junction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the receiver of a junction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">junction</td><td>integer reciever index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer reciever of junction. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="afd2cb84eb053dfc795973773d1043fc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDJunctionNetwork::get_ReceiverVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The Vector of recievers. </dd></dl>

</div>
</div>
<a class="anchor" id="a36f289b7d5a1139a2a0fba97ea5dc7de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDJunctionNetwork::get_SourcesVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The vector of sources. The vector is composed of node indices </dd></dl>

</div>
</div>
<a class="anchor" id="ae09b4d550d156e92134a1b6b9d561353"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_StreamOrder_of_Junction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>junction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the stream order of a junction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">junction</td><td>the junction of interest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer with stream order of junction </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/03/14 </dd></dl>

</div>
</div>
<a class="anchor" id="acfc7c5a1e19a6a8a3f67a003623586f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_StreamOrder_of_Junction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>junction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the stream order of a junction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">junction</td><td>the junction of interest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer with stream order of junction </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/10/14 </dd></dl>

</div>
</div>
<a class="anchor" id="aeb8699e82c3d09a39deb9711212e0f4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_StreamOrder_of_Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the stream order of a node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">node</td><td>node of interest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer with stream order of junction </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/09/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a0a4d9a186d712ca4c68e3fb8308943f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt;int&gt; LSDJunctionNetwork::get_StreamOrderArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the stream order array </dd></dl>

</div>
</div>
<a class="anchor" id="ac761fb65066da746097b203e2e5fa798"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDJunctionNetwork::get_StreamOrderVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The Vector of stream orders. </dd></dl>

</div>
</div>
<a class="anchor" id="aeedb1028393a20cba5a9e019628794c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::get_upslope_junctions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>junction_number_outlet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns all the upstream junction of a junction_number_outlet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">junction_number_outlet</td><td>Integer of junction of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer vector containing all the junction numbers upslope of the chosen junction. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="ac34889326edf0bf6c7fe5021d2c7f00a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::get_upstream_node_max_stream_order </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>current_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the node index of the donor node of a given node with the highest stream order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_node</td><td>The current node index </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node index of the donor node with the highest stream order </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>31/01/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a5b32a7bf1825980898039736d0f2931d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::get_UTM_information </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>UTM_zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>is_North</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function gets the UTM_zone and a boolean that is true if the map is in the northern hemisphere </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UTM_zone</td><td>the UTM zone. Replaced in function. </td></tr>
    <tr><td class="paramname">is_North</td><td>a boolean that is true if the DEM is in the northern hemisphere. replaced in function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a98ee5fbf4a6c5c79dc0bd599e29c1cb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::get_x_and_y_from_latlong </td>
          <td>(</td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>latitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>longitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>UTME</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>UTMN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes latitude and longitude (in WGS 84) and converts to vectors of easting and northing in UTM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latitude</td><td>a vector of latitudes in UTM84 </td></tr>
    <tr><td class="paramname">longitude</td><td>a vector of longitudes in WGS84 </td></tr>
    <tr><td class="paramname">UTME</td><td>The easting coordinate (is overwritten) </td></tr>
    <tr><td class="paramname">UTMN</td><td>The northing coordinate (is overwritten) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/02/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="aea1be926dd745bad78f7b82da89201c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::get_x_and_y_locations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y_loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this gets the x and y location of a node at row and column </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the node </td></tr>
    <tr><td class="paramname">col</td><td>the column of the node </td></tr>
    <tr><td class="paramname">x_loc</td><td>the x location (Northing) of the node </td></tr>
    <tr><td class="paramname">y_loc</td><td>the y location (Easting) of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="af8b3099bdeb9f74ecba4bdceba99615d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::get_x_and_y_locations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>x_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>y_loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this gets the x and y location of a node at row and column </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the node </td></tr>
    <tr><td class="paramname">col</td><td>the column of the node </td></tr>
    <tr><td class="paramname">x_loc</td><td>the x location (Northing) of the node </td></tr>
    <tr><td class="paramname">y_loc</td><td>the y location (Easting) of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ab771a27b9224ef0c642be99b2700a6e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDJunctionNetwork::get_XMinimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Minimum X coordinate as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ef9888d30ce0dc9c0f3d0d77c40c14c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDJunctionNetwork::get_YMinimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Minimum Y coordinate as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a4371935878d556e8e7d7d2802fd27a28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::GetChannelfromDreich </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NodeNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MinSegLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NJunctions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the channel that runs from the hilltop above the furthest upslope source of the junction JunctionNumber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BasinOrder</td><td></td></tr>
    <tr><td class="paramname">MinSegLength</td><td></td></tr>
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">FlowInfo</td><td></td></tr>
    <tr><td class="paramname">FlowDistance</td><td></td></tr>
    <tr><td class="paramname">ElevationRaster</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with channel </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/08/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a82cb2434e59e5a4105ae7a7aaf4fa53a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; int &gt; LSDJunctionNetwork::GetChannelHeadsChiMethodAllPixels </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>JunctionNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bin_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a 2D array containing the locations of all pixels identified as being part of the channel using chi profiles. It calculates the chi and elevation value of every pixel upstream of the given junction, then bins this data and calculates the pixels in the 95th percentile of each bin. Any pixels above the 95th percentile are considered part of the channel, and any below are considered to be hillslopes. This is the first part of the channel head prediction using chi profiles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">JunctionNumber</td><td></td></tr>
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">bin_width</td><td></td></tr>
    <tr><td class="paramname">FlowInfo</td><td>Flow Info object </td></tr>
    <tr><td class="paramname">ElevationRaster</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array2D&lt;float&gt; with channel pixels </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a02fd15411e57bf75c7aed72d3a9a881b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::GetChannelHeadsChiMethodFromNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NodeNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MinSegLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates LSDChannels that run from the hilltops above all the sources of the junction JunctionNumber. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/09/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a60d5d0653ad2f31a5375a37583759d44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::GetChannelHeadsChiMethodFromSourceNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NodeNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MinSegLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NJunctions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates LSDChannels that run from the hilltops above all the sources from the valley network down to a specified number of downstream junctions below the sources. </p>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/09/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a652c837de1dc19f82c5da38c4e8f826d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::GetChannelHeadsChiMethodFromSources </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>ValleySources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MinSegLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NJunctions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns all potential channel heads in a DEM. It looks for. </p>
<p>channel heads based on the valley source nodes identified as concave parts of the landscape </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ValleyJunctions</td><td></td></tr>
    <tr><td class="paramname">MinSegLength</td><td></td></tr>
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">FlowInfo</td><td></td></tr>
    <tr><td class="paramname">FlowDistance</td><td></td></tr>
    <tr><td class="paramname">ElevationRaster</td><td></td></tr>
    <tr><td class="paramname">NJunctions</td><td>number of downstream junctions to run the channel profiles from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;int&gt; a vector of node_indices of potential channel heads </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/09/15 </dd></dl>

</div>
</div>
<a class="anchor" id="ae8ab76a1cbc73591a533e3623a3e293f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::GetChannelHeadsChiMethodFromValleys </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>ValleyNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MinSegLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns all potential channel heads in a DEM. It looks for channel heads organized by a basin order which is fed to the code The basin order just determines how far downstream the algorithm looks for the 'fluvial' section. It returns a vector&lt;int&gt; of nodeindices where the channel heads are. </p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;int&gt; a vector of node_indices of potential channel heads </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/09/2013 This function returns all potential channel heads in a DEM. It looks for channel heads based on the outlet junctions of the valleys (which are identified by looking for portions of the landscape with 10 or more nodes with a high curvature that are linked) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ValleyJunctions</td><td></td></tr>
    <tr><td class="paramname">MinSegLength</td><td></td></tr>
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">FlowInfo</td><td></td></tr>
    <tr><td class="paramname">FlowDistance</td><td></td></tr>
    <tr><td class="paramname">ElevationRaster</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;int&gt; a vector of node_indices of potential channel heads </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>31/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="ae93118c2adc4fa5b4e22a3a5197c2daa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::GetChannelNodesAndJunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>flowinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>NIvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>JIvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>SOvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This extracts vectors containing node incidex, junction indices and stream orders of pixels in the channel network.  The vectors are replaced by the method. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>14/11/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a815eccfd9aa2a75b354d5c1d5437fc96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::GetChannelsDreich </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>ValleySources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MinSegLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NJunctions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns all channels in the DEM that the DrEICH algorithm uses for segiment fitting. It looks for channels based on the outlet junctions of valleys. It returns a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with the channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ValleyNodes</td><td></td></tr>
    <tr><td class="paramname">MinSegLength</td><td></td></tr>
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">FlowInfo</td><td></td></tr>
    <tr><td class="paramname">FlowDistance</td><td></td></tr>
    <tr><td class="paramname">ElevationRaster</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with all channels </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/08/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a5a42d4dfbd0784ae0e265035c9d67a5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::GetSourceNodesChiMethodAllPixels </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>JunctionNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bin_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns an integer vector with the node indexes of the furthest upstream pixels identified as being part of the channel using chi profiles. It calculates the chi and elevation value of every pixel upstream of the given junction, then bins this data and calculates the pixels in the 95th percentile of each bin. Any pixels above the 95th percentile are considered part of the channel, and any below are considered to be hillslopes. This is the first part of the channel head prediction using chi profiles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">JunctionNumber</td><td></td></tr>
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">bin_width</td><td></td></tr>
    <tr><td class="paramname">FlowInfo</td><td>Flow Info object </td></tr>
    <tr><td class="paramname">ElevationRaster</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;int&gt; with source nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="aff3f1b7cca4f1a587f8d31e4e1957b97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::GetStreams </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quick and dirty way to get channels of a defined stream order. </p>
<p>No input error handling, will return an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of NoDataValues if an erroneous order is passed in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Integer of the required stream order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the desired channels. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a05b90694f9404cb07dc333eedd69d486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::GetStreams </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quick and dirty way to get channels of a defined range of stream orders. </p>
<p>No input error handling, will return an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of NoDataValues if an erroneous order is passed in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_order</td><td>Integer of the miniumum required stream order. </td></tr>
    <tr><td class="paramname">max_order</td><td>Integer of the max required stream order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the desired channels. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a2b9ffd6b9a28371ee82d515719a38ced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDJunctionNetwork::GetTotalChannelLengthUpstream </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>this_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function get the total length of channels upstream of a node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this_node</td><td>node of interest </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>30/04/18 </dd></dl>

</div>
</div>
<a class="anchor" id="a9e58f4f2d8e85e7066d90b8a45299cdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::identify_upstream_limits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>topography</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>source_row_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>source_col_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>tan_curv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function identifies upstream limit of channel network. </p>
<p>This is used to reduce a map of channel pixels down to a vector of sources for channel extraction. It finds the upstream limit of each channel and then removes channelised pixels that are on ANY downslope pathway, within convergent part of the topography, from previous sources. It uses a similar algorithm to the Freeman multi-directional flow routing algorithm in the <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td>object </td></tr>
    <tr><td class="paramname">raster</td><td>containing elevation data </td></tr>
    <tr><td class="paramname">a</td><td>vector of row coordinates for possible source pixels </td></tr>
    <tr><td class="paramname">a</td><td>vector of column coordinates for possible source pixels </td></tr>
    <tr><td class="paramname">an</td><td>array of tangential curvature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>03/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a806183d6241a0d349772adff2261fcdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::is_Junction_BaseLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>junction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an integer to check whether junction is at base level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">junction</td><td>the junction of interest @ return int 1 = base level, 0 = not base level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>11/01/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a24c3f526a3e9f276a2441b016c485e0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LSDJunctionNetwork::is_junction_upstream </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>current_junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>test_junction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an bool to check whether junction is upstream of another base level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_junction</td><td>the junction of interest </td></tr>
    <tr><td class="paramname">test_junction</td><td>the junction to see if it is upstream @ return true or false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23/06/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="ace692517891020b57724d95851f73c20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::JunctionArray_to_LSDIndexRaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This sends the JunctionArray to a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of JunctionArray. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a670e0ab97bcd2531ef6b53a103dd7006"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::JunctionIndexArray_to_LSDIndexRaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This sends the JunctionIndexArray to a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of JunctionIndexArray. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="ab28e1ba59ce7b0356960bacb9e5c252f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::map_junction_to_upslope_junction_list </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>upslope_junctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>junction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function maps a junction onto the indexing of the upslope junction list. </p>
<p>If you get an upslope junction list the indexing starts at the furthest downslope junction. All of the junction pointing refers to the master junction list however. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upslope_junctions</td><td>Vector of upslope junctions of interest. </td></tr>
    <tr><td class="paramname">junction</td><td>Integer of junction of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of mapped junctions. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a0ebc8a592980be9e4ab9654b6d59d9a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::modify_basin_nodes_from_mask </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>basin_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>MaskRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks all of the basin nodes to check if they fall within a mask (input raster). If they fall within the mask raster then the first node upstream not in the mask is selected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basin_nodes</td><td>vector of basin nodes </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">MaskRaster</td><td>raster to use as mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with the modified basin nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>31/01/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a4548116f9030acdb93b889b353d78e85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LSDJunctionNetwork::node_tester </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input_junction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to test whether a junction's upstream nodes border areas of No Data important to ensure basins are not being artificially truncated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
    <tr><td class="paramname">input_junction</td><td>Junction to be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean indicating if no data values are present or not: <br/>
false (0) = only good data values <br/>
true (1) = no data values present <br/>
Updated 24/10/13 to handle junction numbers in the same way that the basin extraction code does, by searching one junction downstream of the given junction and then going back up by one node - SWDG. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/06/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a34a03b0d231f199a198c101900042940"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_junction_network.html">LSDJunctionNetwork</a> &amp; LSDJunctionNetwork::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_l_s_d_junction_network.html">LSDJunctionNetwork</a> &amp;&#160;</td>
          <td class="paramname"><em>LSDR</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>the copy constructor </p>

</div>
</div>
<a class="anchor" id="ac95cfb300f54f19990bd8f6dd3c358e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::print_channel_segments_to_csv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; int &gt; &gt;&#160;</td>
          <td class="paramname"><em>SegmentInfoInts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; float &gt; &gt;&#160;</td>
          <td class="paramname"><em>SegmentInfoFloats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>outfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints information about the channel segments from the TypologyModel function to a csv file so it can be read by a GIS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">SegmentInfoInts</td><td>vec&lt;vec&gt; of segment info (integer) </td></tr>
    <tr><td class="paramname">SegmentInfoFloats</td><td>vec&lt;vec&gt; of segment info (floating point) </td></tr>
    <tr><td class="paramname">outfilename</td><td>string, csv filename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a748fcb383c71b142401ca71a6eb8fa11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::print_junction_angles_from_basin_list </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>JunctionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>csv_outname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a vector of basin junctions and prints statistics of all the junctions upstream of each basin junction to a CSV. The statstics are separated by stream order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">JunctionList</td><td>list of basin junctions </td></tr>
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">csv_outname</td><td>name of output csv </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>08/03/18 </dd></dl>

</div>
</div>
<a class="anchor" id="ab79f12f408209d34ce125f4a40f792b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::print_junction_angles_to_csv </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>JunctionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>csv_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This prints the junction angles to a csv file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">JunctionList</td><td>The list of junctions to analyze. If this is an empty vector, the code analyses all junctions in the DEM </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>The <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">csv_name</td><td>The name of the file. Needs full path and csv extension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23/04/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a4e71b549418702e4ef17a4bf5e89cf4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::print_junction_info_vectors </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the information about the junctions to file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Output filename to be appended with '.txt'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a813e4e6ded76dcbf2e328bf405052659"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::print_junctions_to_csv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>JunctionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a list of junctions, with their locations in both UTM and in lat long WGS1984 to file  The format of the file is: junction,node,x,y,latitude,longitude. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td>an <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">JunctionList</td><td>A list of junctions in an integer vector </td></tr>
    <tr><td class="paramname">fname</td><td>The filename of the csv file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/05/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="aeb662846c99587fc9c74cf9044a64530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::print_junctions_to_csv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints all junctions, with their locations in both UTM and in lat long WGS1984 to file  The format of the file is: junction,node,x,y,latitude,longitude. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td>an <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">fname</td><td>The filename of the csv file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/04/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a943520cce153fd6cb185a772af0d8418"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::print_longest_channel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outlet_junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>dist_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>dist_from_outlet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for printing out the longest channel upstream of a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outlet_junction</td><td></td></tr>
    <tr><td class="paramname">FInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object. </td></tr>
    <tr><td class="paramname">dist_code</td><td></td></tr>
    <tr><td class="paramname">dist_from_outlet</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a6b003b148a825727477e838461ce615e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::PrintChannelNetworkToCSV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>flowinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname_prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This prints a stream network to a csv in WGS84  This function prints a network that is ordered by sources, channels have stream orders and junction numbers attached param FlowInfo the flow info object which translates node indices to actual points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName_prefix</td><td>The prefix of the file to write, if no path is included it will write to the current directory. The csv extension is added automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>14/11/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a32b8968fc63339dea5120fc538940696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::Prune_Junctions_Area </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>BaseLevelJunctions_Initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a list of junctions and then prunes junctions based on their number of contributing pixels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseLevelJunctions_Initial</td><td>a vector of integers containg an inital list of base level nodes </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>The <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">FlowAcc</td><td>an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with the number of pixels for flow accumulation </td></tr>
    <tr><td class="paramname">Threshold</td><td>The minimum number of accumulated pixels needed to keep a base level node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pruned list of base level nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/05/16 </dd></dl>

</div>
</div>
<a class="anchor" id="aaafe6c2cbf177c867092df0500208db8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::Prune_Junctions_By_Contributing_Pixel_Window </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Junctions_Initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lower_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upper_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function removes basins that fall outside a contributing pixel Window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Junctions_Initial</td><td>a vector of integers containg an inital list of junctions </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>The <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">FlowAcc</td><td>an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with the number of pixels for flow accumulation </td></tr>
    <tr><td class="paramname">lower_limit</td><td>The minimum number of contributing pixels </td></tr>
    <tr><td class="paramname">upper_limit</td><td>The maximum number of contributing pixels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pruned list of base level nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/06/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a3d89b334bb9521c703adb4efa47e00e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::Prune_Junctions_By_Contributing_Pixel_Window_Remove_Nested_And_Nodata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>TestRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lower_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upper_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function removes basins that fall outside a contributing pixel Window, those that are bounded by nodata, and those that are nested. A rather intensive pruning process that hopeuflly results in a number of basins that are a similar size  This doesn't just look for baselevel junctions: it goes through all junctions in the DEM. Warning: computationally expensive! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td>The <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">TestRaster</td><td>A raster that is just used to look for nodata </td></tr>
    <tr><td class="paramname">FlowAcc</td><td>an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with the number of pixels for flow accumulation </td></tr>
    <tr><td class="paramname">lower_limit</td><td>The minimum number of contributing pixels </td></tr>
    <tr><td class="paramname">upper_limit</td><td>The maximum number of contributing pixels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pruned list of base level nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/06/17 </dd></dl>

</div>
</div>
<a class="anchor" id="af304d34c18bf1bcb463785d39a2e2633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::Prune_Junctions_Edge </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>BaseLevelJunctions_Initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a list of junctions and then prunes junctions based whether they drain from the edge. This attempts to remove junctions that are through-flowing and thus do not have the correct drainage area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseLevelJunctions_Initial</td><td>a vector of integers containg an inital list of base level nodes </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>The <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pruned list of base level nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/05/16 </dd></dl>

</div>
</div>
<a class="anchor" id="abb1fb89053c0852dced2cc1c1fceb9a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::Prune_Junctions_Edge_Ignore_Outlet_Reach </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>BaseLevelJunctions_Initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>TestRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a list of junctions and then prunes junctions based whether they drain from the edge. This attempts to remove junctions that are through-flowing and thus do not have the correct drainage area  Only gets the donor of the baselelve donor to ignore the nodes near the outlet, which often intersect nodata in cut DEMs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseLevelJunctions_Initial</td><td>a vector of integers containg an inital list of base level nodes </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>The <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">TestRaster</td><td>A raster that is just used to look for nodata </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pruned list of base level nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/05/17 </dd></dl>

</div>
</div>
<a class="anchor" id="ada4e6b46c22f76ad0c3e48033bf06c36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::Prune_Junctions_Elevation_Window </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>BaseLevelJunctions_Initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Elev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lower_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upper_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a list of junctions retains ONLY the junctions that have an outlet elevation with an elevation window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseLevelJunctions_Initial</td><td>a vector of integers containg an inital list of base level nodes </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>The <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">Elev</td><td>an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of elevation </td></tr>
    <tr><td class="paramname">lower_threshold</td><td>the lower threshold elevation </td></tr>
    <tr><td class="paramname">upper_threshold</td><td>the lower threshold elevation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pruned list of base level nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19/01/18 </dd></dl>

</div>
</div>
<a class="anchor" id="a47e0c4bd9c7c41f2494a44a14a1a6e26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::Prune_Junctions_If_Nested </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Junctions_Initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowAcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function removes basins that are nested within any other basin in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Junctions_Initial</td><td>a vector of integers containg an inital list of junctions </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>The <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">TestRaster</td><td>A raster that is just used to look for nodata </td></tr>
    <tr><td class="paramname">FlowAcc</td><td>an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with the number of pixels for flow accumulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pruned list of base level nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/06/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a265b836771e5cc12fedd6f35d39be9a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::Prune_Junctions_Largest </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>BaseLevelJunctions_Initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowAcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a list of junctions retains ONLY the larges bains The junction is returned as an int vector so that it can be passed to other functions requiring junction lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseLevelJunctions_Initial</td><td>a vector of integers containg an inital list of base level nodes </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>The <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">FlowAcc</td><td>an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with the number of pixels for flow accumulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pruned list of base level nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>03/06/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a5ed9ae91e36b7848f7ca6c9f43dec394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::Prune_Junctions_Threshold_Elevation </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>BaseLevelJunctions_Initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Elev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold_elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_junctions_below_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a list of junctions retains ONLY the junctions that have an outlet elevation greater or less than the threshold elevation Selection of greater or lower is determined by bool keep_junctions_below_threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseLevelJunctions_Initial</td><td>a vector of integers containg an inital list of base level nodes </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>The <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">Elev</td><td>an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of elevation </td></tr>
    <tr><td class="paramname">threshold_elevation</td><td>the threshold elevation to kepp </td></tr>
    <tr><td class="paramname">keep_junctions_below_threshold</td><td>if true keep junctions below threshold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pruned list of base level nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/01/18 </dd></dl>

</div>
</div>
<a class="anchor" id="a5bd2a44c7068ee4b9921cc3c7e09d145"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDJunctionNetwork::Prune_To_Largest_Complete_Basins </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>BaseLevelJunctions_Initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>TestRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowAcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function looks through all baselevel nodes and then looks for the largest basin that is not influenced by the edge. It returns a vector of these junctions.  Note that it only returns one basin per baselevel node at most so might not do a great job of space filling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseLevelJunctions_Initial</td><td>a vector of integers containg an inital list of base level nodes </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>The <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">TestRaster</td><td>A raster that is just used to look for nodata </td></tr>
    <tr><td class="paramname">FlowAcc</td><td>an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with the number of pixels for flow accumulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pruned list of base level nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/06/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a541eb7632c5e14cb126cf2c45929e927"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::remove_tributary_segments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>Sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>SegmentInfoInts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>SegmentInfoFloats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function removes channel segments from the typology model which are not downstream of a given list of source nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">Sources</td><td>vector of source nodes </td></tr>
    <tr><td class="paramname">SegmentInfoInts</td><td>vec&lt;vec&gt; of segment info (integer) </td></tr>
    <tr><td class="paramname">SegmentInfoFloats</td><td>vec&lt;vec&gt; of segment info (floating point) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa05530213caf8239343ca216eb111325"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDJunctionNetwork::retrieve_junction_number_at_row_and_column </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Junction number at a location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Integer row index. </td></tr>
    <tr><td class="paramname">col</td><td>Integer column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Junction number at location row,col. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a7c96d5c74da714fa45eb8fe930e48be4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::snap_point_locations_to_channels </td>
          <td>(</td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>x_locs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>y_locs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_radius_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold_stream_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_cosmo_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>snapped_node_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>snapped_junction_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function is a wrapper that takes a list of x and y locations, filters them to make sure they are in the data bounds, and then calculates the nearest channel and junction. It is primarily used to snap cosmo data to the channel network </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_locs</td><td>the x locations of the points </td></tr>
    <tr><td class="paramname">y_locs</td><td>the y locations of the points </td></tr>
    <tr><td class="paramname">search_radius_nodes</td><td>the number of nodes around the point to search for a channel </td></tr>
    <tr><td class="paramname">threshold_stream_order</td><td>the minimum stream order to which the point will snap </td></tr>
    <tr><td class="paramname">FlowInfo</td><td>the <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">valid_cosmo_points</td><td>a vector&lt;int&gt; of indices into the x and y vectors. for example if the only valid points were at x_loc[12] and x_loc[34] this would return a vector with two elements, 12 and 34. This vector is overwritten by this function </td></tr>
    <tr><td class="paramname">snapped_node_indices</td><td>a vector containing the node indices of the points snapped to the nearest channel (within search radius and over the drainage order threshold). This is overwritten by this method. </td></tr>
    <tr><td class="paramname">snapped_junction_indices</td><td>a vector&lt;int&gt; continaing the junction numbers downstream of the nearest channel node. This is overwritten by this method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>14/11/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a1fdd20387208c965eef18ae77869a057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::SplitChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>Sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>TargetSegmentLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function splits the channel into a series of segments, providing a convenient unit with which to analyse landscapes. The user provides the TargetSegmentLength, which specifies how many nodes should be in each segment, and a MinimumSegmentLength, which specifies the fewest permissable number of nodes. Segments smaller than this are amalgamated into the upstream segment. The algorithm loops through the sources and traces downstream, stopping a segment after the target segment length, when the stream order increases (to preserve structure of drainage network), or when a channel pixel has already been visited. </p>
<p>SplitChannel </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">Sources</td><td>a vector of sources </td></tr>
    <tr><td class="paramname">TargetSegmentLength</td><td>(suggest 200 for 1m DEM) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> with channel segments labelled by unique ID </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a0adf2319c3383cf8d9059ecc7e0d318e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::SplitHillslopes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelSegmentsRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is intended to follow the SplitChannel function. It traces through the receiver nodes from every hillslope pixel and then assigns them an integer value that matches the index of the section of channel that is setting the base level of that hillslope. </p>
<p>SplitHillslopes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">ChannelSegmentsRaster</td><td>a raster of channel segments, produced by the SplitChannel function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> hillslope segments labelled by ID of channel segments </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a02f0908f81dbffe7c863662597b1dcbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::SplitHillslopes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelSegmentsRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>MultiThreadChannelRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded function doing the same as the previous version to segment hillslopes according to the channel index of the channel setting its base level. However, this has been adapted to include an additional input raster - MultiThreadChannelRaster - which recognises that real channels may be multithreaded and/or have widths greater than or equal to one pixel. To be rigourous, these should be removed from analyses of hillslope properties. </p>
<p>SplitHillslopes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">ChannelSegmentsRaster</td><td>a raster of channel segments, produced by the SplitChannel function </td></tr>
    <tr><td class="paramname">MultiThreadChannelRaster</td><td>a binary raster with the full channel extent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> hillslope segments labelled by ID of channel segments </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="af9209dc43cfd5c3b75af3283cf31ca96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::StreamOrderArray_to_BinaryNetwork_LSDIndexRaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns the StreamOrderArray into a binary rastser where 1 is channel and 0 is hillslope. </p>
<dl class="section return"><dt>Returns</dt><dd>Binary <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the channel network. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a9d933d422cc70a0b2d726e809aa0bea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDJunctionNetwork::StreamOrderArray_to_LSDIndexRaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This sends the StreamOrderArray to a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of StreamOrderArray. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a5b799eb9c084d1b84ea2e24450216d94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::StreamOrderArray_to_WGS84CSV </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>FileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to flatten an te stream order array and place the non NDV values in a csv file.  Each value is placed on its own line, so that it can be read more quickly in python etc. It includes the lat long coordinates in CSV, in WGS84 coordinate system EPSG:4326. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName_prefix</td><td>The prefix of the file to write, if no path is included it will write to the current directory. The csv extension is added automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>12/11/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a518c170d3e0808813157b0b7778b9bcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::TypologyModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>Sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>BaselineSources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>CatchIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>HydroCodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MinReachLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DischargeRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>SegmentInfoInts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>SegmentInfoFloats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TypologyModel</p>
<p>This function splits the channel into a series of segments, providing a convenient unit with which to analyse landscapes. Function modified from original SplitChannel function so that the segment length varies with the drainage area of the cahtchment. Length (m) is calculated based on: L = Min_reach_length * sqrt(Drainage Area (km)) User must pass in the minimum reach length in metres The algorithm starts a new segment either after the target length, when the stream order increases, or when a channel pixel has already been visited. User must pass in an empty IndexRaster which will be populated with the channel segments data, and two vector of vectors which will be populated: vector&lt; vector&lt;int&gt; &gt; SegmentInfoInts has the following layout: 0 - segment IDS 1 - start node of each segment (upstream) 2 - end nodes (downstream) vector&lt; vector&lt;float&gt; &gt; SegmentInfoFloats has the following layout: 0 - segment lengths 1 - elevation of the start nodes 2 - slope of the segment</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowInfo</td><td><a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">Sources</td><td>a vector of sources </td></tr>
    <tr><td class="paramname">BaselineSources</td><td>vector of baseline DRN sources </td></tr>
    <tr><td class="paramname">CatchIDs</td><td>vector of catchment IDs from DRN </td></tr>
    <tr><td class="paramname">HydroCodes</td><td>vector of hydrocodes from DRN </td></tr>
    <tr><td class="paramname">MinReachLength</td><td>in metres </td></tr>
    <tr><td class="paramname">search_radius</td><td>search radius for snapping rasters to the channel segments (pixels) </td></tr>
    <tr><td class="paramname">ElevationRaster</td><td>raster with elevation values </td></tr>
    <tr><td class="paramname">DischargeRaster</td><td>raster with discharge values (CEH one is in l/second, weirdly) </td></tr>
    <tr><td class="paramname">ChannelSegments</td><td>empty <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>, returned with channel segments labelled by unique ID </td></tr>
    <tr><td class="paramname">SegmentInfoInt</td><td>vec&lt;vec&gt; with integer segment info </td></tr>
    <tr><td class="paramname">SegmentInfoFloat</td><td>vec&lt;vec&gt; with floating segment info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>06/02/17 </dd></dl>

</div>
</div>
<a class="anchor" id="ae3e62388b02d10869dc8c44fc327a985"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::write_river_profiles_to_csv </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>BasinJunctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DistanceFromOutlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>csv_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to take a vector of basin outlet junctions and write data about the longest channel in each to csv. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BasinJunctions</td><td>vector of basin junctions </td></tr>
    <tr><td class="paramname">FlowInfo</td><td></td></tr>
    <tr><td class="paramname">DistanceFromOutlet</td><td></td></tr>
    <tr><td class="paramname">Elevation</td><td>elev raster </td></tr>
    <tr><td class="paramname">csv_filename</td><td>the output csv file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>06/04/18 </dd></dl>

</div>
</div>
<a class="anchor" id="ae88c277b5ec55fd259ec5102ea8ffeeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::write_river_profiles_to_csv_all_sources </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>channel_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slope_window_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>csv_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to write data about channels downstream of all channel heads for a specified length </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_length</td><td>length downstream to stop writing info </td></tr>
    <tr><td class="paramname">FlowInfo</td><td></td></tr>
    <tr><td class="paramname">Elevation</td><td>elev raster </td></tr>
    <tr><td class="paramname">csv_filename</td><td>the output csv file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>02/05/18 </dd></dl>

</div>
</div>
<a class="anchor" id="a32d5fea180ef55d21caa643d2d58bb2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::write_river_profiles_to_csv_all_tributaries </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>BasinJunctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DistanceFromOutlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>csv_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to take a vector of basin outlet junctions and write data about all tribs to csv </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BasinJunctions</td><td>vector of basin junctions </td></tr>
    <tr><td class="paramname">FlowInfo</td><td></td></tr>
    <tr><td class="paramname">DistanceFromOutlet</td><td></td></tr>
    <tr><td class="paramname">Elevation</td><td>elev raster </td></tr>
    <tr><td class="paramname">csv_filename</td><td>the output csv file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>02/05/18 </dd></dl>

</div>
</div>
<a class="anchor" id="a5020205756ad9f39c9f68702cbdb6ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDJunctionNetwork::write_valley_hilltop_chi_profiles_to_csv </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_flow_info.html">LSDFlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>ElevationRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NJunctions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>output_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>DEM_ID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates LSDChannels that run from the hilltops above all the sources from the valley network down to a specified number of downstream junctions below the sources and writes the profile to csv. </p>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23/12/16 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae5679fccce4dfc1485d2798a7215968a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDJunctionNetwork::DeltaVector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the delta vector which is used to index into the donor stack and order contributing junction see Braun and Willett [2012]. </p>

</div>
</div>
<a class="anchor" id="aef4f20576ed80f29c36d306f7627e89a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt;int&gt; LSDJunctionNetwork::JunctionArray</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This array stores a junction counter. </p>
<p>If zero there is no junction <br/>
if 1 it is a junction unvisted by the junction gathering algorithm <br/>
if 2 or more it is a previously visited junction </p>

</div>
</div>
<a class="anchor" id="aed7b5523309aecc373b587ba604f3d1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt;int&gt; LSDJunctionNetwork::JunctionIndexArray</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an array where the elements are nodata if there is no junction and an integer indicating the junction number. </p>

</div>
</div>
<a class="anchor" id="a70bc84aa22d45c561d5ad976240f3daf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDJunctionNetwork::NContributingJunctions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of contributing junctions !!INCULDING SELF!! to a current pixel. </p>
<p>It is used in conjunction with the SVectorIndex to build basins upslope of any and all nodes in the junction list. </p>

</div>
</div>
<a class="anchor" id="ab54acefb0ac3582effe9a23aa417694b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDJunctionNetwork::SourcesVector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of the node indices that are sources. </p>
<p>Note: are not the node indices not junctions. To find the junctions you need to use the get_Junction_of_Node member function </p>

</div>
</div>
<a class="anchor" id="ad531fcfbb5e7554fd2e0bfcd58026d71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDJunctionNetwork::StreamOrderVector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The stream order of the junction node/link. </p>
<p>Note that each junction has one and only one receiver junction so the stream order of a junction node will apply to all nodes along the path to the next junction. </p>

</div>
</div>
<a class="anchor" id="aff0884753878be4533eb8e28ac75f6d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDJunctionNetwork::SVector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This vector is used to calculate flow accumulation. </p>
<p>For each base level junction it progresses from a hilltop to a confluence and then jumps to the next hilltop so that by cascading down through the node indices in this list one can quickly calculate drainage area, discharge, sediment flux, etc. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_l_s_d_junction_network_8hpp_source.html">LSDJunctionNetwork.hpp</a></li>
<li>src/LSDJunctionNetwork.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
