<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LSDTopoTools2: LSDFlowInfo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LSDTopoTools2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_l_s_d_flow_info-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LSDFlowInfo Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Object to perform flow routing.  
 <a href="class_l_s_d_flow_info.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_l_s_d_flow_info_8hpp_source.html">LSDFlowInfo.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a71de786a2041fff1691ff3690229c8a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a71de786a2041fff1691ff3690229c8a8">LSDFlowInfo</a> ()</td></tr>
<tr class="memdesc:a71de786a2041fff1691ff3690229c8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The create function. This is default and throws an error.  <a href="#a71de786a2041fff1691ff3690229c8a8">More...</a><br/></td></tr>
<tr class="separator:a71de786a2041fff1691ff3690229c8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330498c7d149053891518b5ff2987aba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a330498c7d149053891518b5ff2987aba">LSDFlowInfo</a> (string fname)</td></tr>
<tr class="memdesc:a330498c7d149053891518b5ff2987aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a FlowInfo object from a binary flowinfo data.  <a href="#a330498c7d149053891518b5ff2987aba">More...</a><br/></td></tr>
<tr class="separator:a330498c7d149053891518b5ff2987aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298a3e0a97ec15864f8368cb6f8a4a88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a298a3e0a97ec15864f8368cb6f8a4a88">LSDFlowInfo</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;TopoRaster)</td></tr>
<tr class="memdesc:a298a3e0a97ec15864f8368cb6f8a4a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a FlowInfo object from a binary flowinfo data.  This assumes no flux boundaries.  <a href="#a298a3e0a97ec15864f8368cb6f8a4a88">More...</a><br/></td></tr>
<tr class="separator:a298a3e0a97ec15864f8368cb6f8a4a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff2067b00d2575c6e72d7740b59786d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a9ff2067b00d2575c6e72d7740b59786d">LSDFlowInfo</a> (vector&lt; string &gt; &amp;<a class="el" href="class_l_s_d_flow_info.html#a7b6d2a809055715812f57dc311363517">BoundaryConditions</a>, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;TopoRaster)</td></tr>
<tr class="memdesc:a9ff2067b00d2575c6e72d7740b59786d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a FlowInfo object from topography.  <a href="#a9ff2067b00d2575c6e72d7740b59786d">More...</a><br/></td></tr>
<tr class="separator:a9ff2067b00d2575c6e72d7740b59786d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aef49e633a7d74e8257c4a6567c05ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a7aef49e633a7d74e8257c4a6567c05ff">get_UTM_information</a> (int &amp;UTM_zone, bool &amp;is_North)</td></tr>
<tr class="memdesc:a7aef49e633a7d74e8257c4a6567c05ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function gets the UTM_zone and a boolean that is true if the map is in the northern hemisphere  <a href="#a7aef49e633a7d74e8257c4a6567c05ff">More...</a><br/></td></tr>
<tr class="separator:a7aef49e633a7d74e8257c4a6567c05ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb461de3f6735852a771fd386e14ef15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#aeb461de3f6735852a771fd386e14ef15">get_x_and_y_locations</a> (int row, int col, double &amp;x_loc, double &amp;y_loc)</td></tr>
<tr class="memdesc:aeb461de3f6735852a771fd386e14ef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">this gets the x and y location of a node at row and column  <a href="#aeb461de3f6735852a771fd386e14ef15">More...</a><br/></td></tr>
<tr class="separator:aeb461de3f6735852a771fd386e14ef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5586d098c8e976b5e743a1a9b65fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#afc5586d098c8e976b5e743a1a9b65fce">get_x_and_y_locations</a> (int row, int col, float &amp;x_loc, float &amp;y_loc)</td></tr>
<tr class="memdesc:afc5586d098c8e976b5e743a1a9b65fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">this gets the x and y location of a node at row and column  <a href="#afc5586d098c8e976b5e743a1a9b65fce">More...</a><br/></td></tr>
<tr class="separator:afc5586d098c8e976b5e743a1a9b65fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d7a5547e984b5735adadc7eb4a4137"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a92d7a5547e984b5735adadc7eb4a4137">get_lat_and_long_locations</a> (int row, int col, double &amp;lat, double &amp;longitude, <a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a> Converter)</td></tr>
<tr class="memdesc:a92d7a5547e984b5735adadc7eb4a4137"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function to get the lat and long of a node in the raster  Assumes WGS84 ellipsiod  <a href="#a92d7a5547e984b5735adadc7eb4a4137">More...</a><br/></td></tr>
<tr class="separator:a92d7a5547e984b5735adadc7eb4a4137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026d9a23d364d47bb0f2da8f2bb50890"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a026d9a23d364d47bb0f2da8f2bb50890">get_lat_and_long_locations</a> (double X, double Y, double &amp;lat, double &amp;longitude, <a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a> Converter)</td></tr>
<tr class="memdesc:a026d9a23d364d47bb0f2da8f2bb50890"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function to get the lat and long of a location provided as northing and easting  Assumes WGS84 ellipsiod  <a href="#a026d9a23d364d47bb0f2da8f2bb50890">More...</a><br/></td></tr>
<tr class="separator:a026d9a23d364d47bb0f2da8f2bb50890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34c62d09c74e2b06923cda4b7db8f56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ae34c62d09c74e2b06923cda4b7db8f56">check_if_point_is_in_raster</a> (float X_coordinate, float Y_coordinate)</td></tr>
<tr class="memdesc:ae34c62d09c74e2b06923cda4b7db8f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">this check to see if a point is within the raster  <a href="#ae34c62d09c74e2b06923cda4b7db8f56">More...</a><br/></td></tr>
<tr class="separator:ae34c62d09c74e2b06923cda4b7db8f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40b12a6ea3966fb36a7979a2330c1aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ac40b12a6ea3966fb36a7979a2330c1aa">retrieve_receiver_information</a> (int current_node, int &amp;reveiver_node, int &amp;receiver_row, int &amp;receiver_col)</td></tr>
<tr class="memdesc:ac40b12a6ea3966fb36a7979a2330c1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the reciever information for a given node.  <a href="#ac40b12a6ea3966fb36a7979a2330c1aa">More...</a><br/></td></tr>
<tr class="separator:ac40b12a6ea3966fb36a7979a2330c1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f889dd60be2c63aa6c1638edd8146cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a9f889dd60be2c63aa6c1638edd8146cf">retrieve_receiver_information</a> (int current_node, int &amp;reveiver_node)</td></tr>
<tr class="memdesc:a9f889dd60be2c63aa6c1638edd8146cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the reciever information for a given node.  <a href="#a9f889dd60be2c63aa6c1638edd8146cf">More...</a><br/></td></tr>
<tr class="separator:a9f889dd60be2c63aa6c1638edd8146cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884cde464cdf104cf3e07599e9b65c07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a884cde464cdf104cf3e07599e9b65c07">retrieve_current_row_and_col</a> (int current_node, int &amp;curr_row, int &amp;curr_col)</td></tr>
<tr class="memdesc:a884cde464cdf104cf3e07599e9b65c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the row and column indices of a given node.  <a href="#a884cde464cdf104cf3e07599e9b65c07">More...</a><br/></td></tr>
<tr class="separator:a884cde464cdf104cf3e07599e9b65c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f358ea8483f2508d278fcc4e8c29855"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a6f358ea8483f2508d278fcc4e8c29855">get_NodeIndex_from_row_col</a> (int row, int col)</td></tr>
<tr class="memdesc:a6f358ea8483f2508d278fcc4e8c29855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index from row/col.  <a href="#a6f358ea8483f2508d278fcc4e8c29855">More...</a><br/></td></tr>
<tr class="separator:a6f358ea8483f2508d278fcc4e8c29855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfd16c986996082a18f73b912f8eb1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a5dfd16c986996082a18f73b912f8eb1d">get_x_and_y_from_current_node</a> (int current_node, float &amp;current_X, float &amp;current_Y)</td></tr>
<tr class="memdesc:a5dfd16c986996082a18f73b912f8eb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the X and Y coordinates of a given node.  <a href="#a5dfd16c986996082a18f73b912f8eb1d">More...</a><br/></td></tr>
<tr class="separator:a5dfd16c986996082a18f73b912f8eb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdffcafa61f370cf32d5d6d14e251f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#abbdffcafa61f370cf32d5d6d14e251f5">get_lat_and_long_from_current_node</a> (int current_node, double &amp;current_lat, double &amp;current_long, <a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a> Converter)</td></tr>
<tr class="memdesc:abbdffcafa61f370cf32d5d6d14e251f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lat and longitude coordinates of a given node.  <a href="#abbdffcafa61f370cf32d5d6d14e251f5">More...</a><br/></td></tr>
<tr class="separator:abbdffcafa61f370cf32d5d6d14e251f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce3c7b126c3dac582ebb1e1beee3397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a3ce3c7b126c3dac582ebb1e1beee3397">print_vector_of_nodeindices_to_csv_file</a> (vector&lt; int &gt; &amp;nodeindex_vec, string outfilename)</td></tr>
<tr class="memdesc:a3ce3c7b126c3dac582ebb1e1beee3397"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a vector of node indices and prints a csv file that can be read by arcmap.  <a href="#a3ce3c7b126c3dac582ebb1e1beee3397">More...</a><br/></td></tr>
<tr class="separator:a3ce3c7b126c3dac582ebb1e1beee3397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643c1a70fa907faeace7036da258ab67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a643c1a70fa907faeace7036da258ab67">print_vector_of_nodeindices_to_csv_file_with_latlong</a> (vector&lt; int &gt; &amp;nodeindex_vec, string outfilename)</td></tr>
<tr class="memdesc:a643c1a70fa907faeace7036da258ab67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a vector of node indices and prints a csv file that can be read by arcmap: similar to above but also prints lat and long.  <a href="#a643c1a70fa907faeace7036da258ab67">More...</a><br/></td></tr>
<tr class="separator:a643c1a70fa907faeace7036da258ab67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17ed5d38d330441e41466c9702b4ae2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ab17ed5d38d330441e41466c9702b4ae2">print_vector_of_nodeindices_to_csv_file_Unique</a> (vector&lt; int &gt; &amp;nodeindex_vec, string outfilename)</td></tr>
<tr class="memdesc:ab17ed5d38d330441e41466c9702b4ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a vector of node indices and prints a csv file that can be read by arcmap, adding in a unique id to each row, independent of the nodeindex.  <a href="#ab17ed5d38d330441e41466c9702b4ae2">More...</a><br/></td></tr>
<tr class="separator:ab17ed5d38d330441e41466c9702b4ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd9e9a21df1d7208eac74f06d533b2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#acdd9e9a21df1d7208eac74f06d533b2f">retrieve_contributing_pixels_of_node</a> (int node)</td></tr>
<tr class="memdesc:acdd9e9a21df1d7208eac74f06d533b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of pixels flowing into a node.  <a href="#acdd9e9a21df1d7208eac74f06d533b2f">More...</a><br/></td></tr>
<tr class="separator:acdd9e9a21df1d7208eac74f06d533b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c42ddee889181abed5b38d988e24a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a22c42ddee889181abed5b38d988e24a8">retrieve_flow_length_code_of_node</a> (int node)</td></tr>
<tr class="memdesc:a22c42ddee889181abed5b38d988e24a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the FlowLengthCode of a given node.  <a href="#a22c42ddee889181abed5b38d988e24a8">More...</a><br/></td></tr>
<tr class="separator:a22c42ddee889181abed5b38d988e24a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f6bb5feb4e2006d3b4be9d42d9a0cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a73f6bb5feb4e2006d3b4be9d42d9a0cb">get_LocalFlowDirection</a> (int row, int col)</td></tr>
<tr class="memdesc:a73f6bb5feb4e2006d3b4be9d42d9a0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the FlowDirection of a row and column pair.  <a href="#a73f6bb5feb4e2006d3b4be9d42d9a0cb">More...</a><br/></td></tr>
<tr class="separator:a73f6bb5feb4e2006d3b4be9d42d9a0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149ba017a2fab24c073377c571ebf791"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a149ba017a2fab24c073377c571ebf791">retrieve_ndonors_to_node</a> (int current_node)</td></tr>
<tr class="memdesc:a149ba017a2fab24c073377c571ebf791"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of donors to a given node  <a href="#a149ba017a2fab24c073377c571ebf791">More...</a><br/></td></tr>
<tr class="separator:a149ba017a2fab24c073377c571ebf791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3d603727e9cee20d6a24d65bbc611e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a9a3d603727e9cee20d6a24d65bbc611e">retrieve_node_from_row_and_column</a> (int row, int column)</td></tr>
<tr class="memdesc:a9a3d603727e9cee20d6a24d65bbc611e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node for a cell at a given row and column.  <a href="#a9a3d603727e9cee20d6a24d65bbc611e">More...</a><br/></td></tr>
<tr class="separator:a9a3d603727e9cee20d6a24d65bbc611e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8edd8c062c1072cc945ca47c6dfed02"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ab8edd8c062c1072cc945ca47c6dfed02">retrieve_donors_to_node</a> (int current_node)</td></tr>
<tr class="memdesc:ab8edd8c062c1072cc945ca47c6dfed02"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets a vector of all the donors to a given node  <a href="#ab8edd8c062c1072cc945ca47c6dfed02">More...</a><br/></td></tr>
<tr class="separator:ab8edd8c062c1072cc945ca47c6dfed02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10adeea4cf404477ee2886ee7dab090c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a10adeea4cf404477ee2886ee7dab090c">get_DrainageArea_square_km</a> (int this_node)</td></tr>
<tr class="memdesc:a10adeea4cf404477ee2886ee7dab090c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the draiange area of a node in square km  <a href="#a10adeea4cf404477ee2886ee7dab090c">More...</a><br/></td></tr>
<tr class="separator:a10adeea4cf404477ee2886ee7dab090c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d60a5c2f274755d478589f201b4286d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a5d60a5c2f274755d478589f201b4286d">get_DrainageArea_square_m</a> (int this_node)</td></tr>
<tr class="memdesc:a5d60a5c2f274755d478589f201b4286d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the draiange area of a node in square m  <a href="#a5d60a5c2f274755d478589f201b4286d">More...</a><br/></td></tr>
<tr class="separator:a5d60a5c2f274755d478589f201b4286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf58c52d2770111f3e40a23328ed969"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a2cf58c52d2770111f3e40a23328ed969">get_NRows</a> () const </td></tr>
<tr class="separator:a2cf58c52d2770111f3e40a23328ed969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1191a6fd02ae41143bfb91a72aa94a1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a1191a6fd02ae41143bfb91a72aa94a1e">get_NCols</a> () const </td></tr>
<tr class="separator:a1191a6fd02ae41143bfb91a72aa94a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5473119e763ddc3be2f09b0068fbc7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a1b5473119e763ddc3be2f09b0068fbc7">get_XMinimum</a> () const </td></tr>
<tr class="separator:a1b5473119e763ddc3be2f09b0068fbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36063e3c4aefcd270645ff65a98874cf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a36063e3c4aefcd270645ff65a98874cf">get_YMinimum</a> () const </td></tr>
<tr class="separator:a36063e3c4aefcd270645ff65a98874cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2380e21eeebe616891c3bf283362aa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ade2380e21eeebe616891c3bf283362aa">get_DataResolution</a> () const </td></tr>
<tr class="separator:ade2380e21eeebe616891c3bf283362aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1b7cb15e5da5636e704e86add9314f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a7f1b7cb15e5da5636e704e86add9314f">get_NoDataValue</a> () const </td></tr>
<tr class="separator:a7f1b7cb15e5da5636e704e86add9314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a10ba47ff2ab7f532ea0cb3edff5970"><td class="memItemLeft" align="right" valign="top">map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a1a10ba47ff2ab7f532ea0cb3edff5970">get_GeoReferencingStrings</a> () const </td></tr>
<tr class="separator:a1a10ba47ff2ab7f532ea0cb3edff5970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a05debd93d95cb8cb304e244afc71a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a65a05debd93d95cb8cb304e244afc71a">get_NDataNodes</a> () const </td></tr>
<tr class="separator:a65a05debd93d95cb8cb304e244afc71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe40b37ac16464fd0360ba92f7b75f7"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#aabe40b37ac16464fd0360ba92f7b75f7">get_BaseLevelNodeList</a> ()</td></tr>
<tr class="separator:aabe40b37ac16464fd0360ba92f7b75f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c420edac35799ae1eece2cee323751d"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a5c420edac35799ae1eece2cee323751d">get_donorStack</a> () const </td></tr>
<tr class="separator:a5c420edac35799ae1eece2cee323751d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114056bfcda7a410b9ce51f569788d86"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a114056bfcda7a410b9ce51f569788d86">get_SVector</a> () const </td></tr>
<tr class="separator:a114056bfcda7a410b9ce51f569788d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ae185533c1891b793ed368d6afa714"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a41ae185533c1891b793ed368d6afa714">get_FlowDirection</a> () const </td></tr>
<tr class="separator:a41ae185533c1891b793ed368d6afa714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372a1cce7347b9d7b3a2ec8c59869d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a372a1cce7347b9d7b3a2ec8c59869d59">add_to_stack</a> (int lm_index, int &amp;j_index, int bl_node)</td></tr>
<tr class="memdesc:a372a1cce7347b9d7b3a2ec8c59869d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive add_to_stack routine, from Braun and Willett (2012) equations 12 and 13.  <a href="#a372a1cce7347b9d7b3a2ec8c59869d59">More...</a><br/></td></tr>
<tr class="separator:a372a1cce7347b9d7b3a2ec8c59869d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8387d52c91360001a8f8ec91a734133"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ad8387d52c91360001a8f8ec91a734133">write_NodeIndex_to_LSDIndexRaster</a> ()</td></tr>
<tr class="memdesc:ad8387d52c91360001a8f8ec91a734133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write NodeIndex to an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>.  <a href="#ad8387d52c91360001a8f8ec91a734133">More...</a><br/></td></tr>
<tr class="separator:ad8387d52c91360001a8f8ec91a734133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b8861234730afcb147ce6a3f151694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a49b8861234730afcb147ce6a3f151694">write_FlowDirection_to_LSDIndexRaster</a> ()</td></tr>
<tr class="memdesc:a49b8861234730afcb147ce6a3f151694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write FlowDirection to an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>.  <a href="#a49b8861234730afcb147ce6a3f151694">More...</a><br/></td></tr>
<tr class="separator:a49b8861234730afcb147ce6a3f151694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705e1cf7741aeee7174accbc8521c8c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a705e1cf7741aeee7174accbc8521c8c3">write_FlowLengthCode_to_LSDIndexRaster</a> ()</td></tr>
<tr class="memdesc:a705e1cf7741aeee7174accbc8521c8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write FlowLengthCode to an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>.  <a href="#a705e1cf7741aeee7174accbc8521c8c3">More...</a><br/></td></tr>
<tr class="separator:a705e1cf7741aeee7174accbc8521c8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4105e2de5868f3ff8586366df15137c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#aa4105e2de5868f3ff8586366df15137c">write_NodeIndexVector_to_LSDIndexRaster</a> (vector&lt; int &gt; &amp;nodeindexvec)</td></tr>
<tr class="memdesc:aa4105e2de5868f3ff8586366df15137c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes and <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> containing the location of nodes in the nodeindexvector.  <a href="#aa4105e2de5868f3ff8586366df15137c">More...</a><br/></td></tr>
<tr class="separator:aa4105e2de5868f3ff8586366df15137c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5208624568ee6286a6d5c491b07b194c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a5208624568ee6286a6d5c491b07b194c">write_NodeIndexVector_to_LSDIndexRaster_Unique</a> (vector&lt; int &gt; &amp;nodeindexvec)</td></tr>
<tr class="memdesc:a5208624568ee6286a6d5c491b07b194c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes an LSDIndesxRaster given a list of node indices, and give every pixel its nodeindex value, which is unique.  <a href="#a5208624568ee6286a6d5c491b07b194c">More...</a><br/></td></tr>
<tr class="separator:a5208624568ee6286a6d5c491b07b194c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830bffe6b748db4f141a650e4b068e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a830bffe6b748db4f141a650e4b068e80">write_NContributingNodes_to_LSDIndexRaster</a> ()</td></tr>
<tr class="memdesc:a830bffe6b748db4f141a650e4b068e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write NContributingNodes to an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>.  <a href="#a830bffe6b748db4f141a650e4b068e80">More...</a><br/></td></tr>
<tr class="separator:a830bffe6b748db4f141a650e4b068e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba659a392678c0eef0d15003bac101f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#aba659a392678c0eef0d15003bac101f6">write_FlowDirection_to_LSDIndexRaster_Arcformat</a> ()</td></tr>
<tr class="memdesc:aba659a392678c0eef0d15003bac101f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes flow directions to an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>. Flow direction in arcmap format is: <br/>
<br/>
 32 64 128 <br/>
 16 0 1 <br/>
 8 4 2 <br/>
.  <a href="#aba659a392678c0eef0d15003bac101f6">More...</a><br/></td></tr>
<tr class="separator:aba659a392678c0eef0d15003bac101f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98aa863276380f5db58005d40567e06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ae98aa863276380f5db58005d40567e06">write_DrainageArea_to_LSDRaster</a> ()</td></tr>
<tr class="separator:ae98aa863276380f5db58005d40567e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f2ee60233cfa2bb585a702a6da27c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ae2f2ee60233cfa2bb585a702a6da27c5">print_flow_info_vectors</a> (string filename)</td></tr>
<tr class="memdesc:ae2f2ee60233cfa2bb585a702a6da27c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the flow information to file.  <a href="#ae2f2ee60233cfa2bb585a702a6da27c5">More...</a><br/></td></tr>
<tr class="separator:ae2f2ee60233cfa2bb585a702a6da27c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c992c1866e409f496d7b26b3c39177"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a97c992c1866e409f496d7b26b3c39177">unpickle</a> (string filename)</td></tr>
<tr class="memdesc:a97c992c1866e409f496d7b26b3c39177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpickles flow information data from a binary file.  <a href="#a97c992c1866e409f496d7b26b3c39177">More...</a><br/></td></tr>
<tr class="separator:a97c992c1866e409f496d7b26b3c39177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f89d3dc520d1a032719e13b713e15de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a1f89d3dc520d1a032719e13b713e15de">pickle</a> (string filename)</td></tr>
<tr class="memdesc:a1f89d3dc520d1a032719e13b713e15de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pickles flow information data from a binary file.  <a href="#a1f89d3dc520d1a032719e13b713e15de">More...</a><br/></td></tr>
<tr class="separator:a1f89d3dc520d1a032719e13b713e15de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68f441180adede8c274d26b47a4623b"><td class="memItemLeft" align="right" valign="top">map&lt; string, vector&lt; string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ac68f441180adede8c274d26b47a4623b">load_csv_data</a> (string filename)</td></tr>
<tr class="memdesc:ac68f441180adede8c274d26b47a4623b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This loads a csv file, putting the data into a data map.  <a href="#ac68f441180adede8c274d26b47a4623b">More...</a><br/></td></tr>
<tr class="separator:ac68f441180adede8c274d26b47a4623b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046c668ca53a462ba7cd828d6154f0b5"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a046c668ca53a462ba7cd828d6154f0b5">get_data_column</a> (string column_name, map&lt; string, vector&lt; string &gt; &gt; data_map)</td></tr>
<tr class="memdesc:a046c668ca53a462ba7cd828d6154f0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets a data column from the csv file.  <a href="#a046c668ca53a462ba7cd828d6154f0b5">More...</a><br/></td></tr>
<tr class="separator:a046c668ca53a462ba7cd828d6154f0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027e03d34a1b6f8bc703f545b999f9c1"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a027e03d34a1b6f8bc703f545b999f9c1">data_column_to_float</a> (string column_name, map&lt; string, vector&lt; string &gt; &gt; data_map)</td></tr>
<tr class="memdesc:a027e03d34a1b6f8bc703f545b999f9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets a data column from the csv file, and converts it to a float vector.  <a href="#a027e03d34a1b6f8bc703f545b999f9c1">More...</a><br/></td></tr>
<tr class="separator:a027e03d34a1b6f8bc703f545b999f9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e122225b8d3ca1ae122ff7c5f5dad5"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a48e122225b8d3ca1ae122ff7c5f5dad5">data_column_to_int</a> (string column_name, map&lt; string, vector&lt; string &gt; &gt; data_map)</td></tr>
<tr class="memdesc:a48e122225b8d3ca1ae122ff7c5f5dad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets a data column from the csv file, and converts it to an int vector.  <a href="#a48e122225b8d3ca1ae122ff7c5f5dad5">More...</a><br/></td></tr>
<tr class="separator:a48e122225b8d3ca1ae122ff7c5f5dad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b8a4fe4f6f12b5ccbd367469536553"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a01b8a4fe4f6f12b5ccbd367469536553">Ingest_Channel_Heads</a> (string filename, string extension, int input_switch=2)</td></tr>
<tr class="memdesc:a01b8a4fe4f6f12b5ccbd367469536553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to ingest the channel heads raster generated using channel_heads_driver.cpp into a vector of source nodes so that an <a class="el" href="class_l_s_d_junction_network.html" title="Object to create a channel network from an LSDFlowInfo object. ">LSDJunctionNetwork</a> can be created easily from them. <b>UPDATE</b> if the extension is a csv file it reads the node indices directly <b>UPDATE, FJC 20/01/16 - changed default input switch to 2</b>  <a href="#a01b8a4fe4f6f12b5ccbd367469536553">More...</a><br/></td></tr>
<tr class="separator:a01b8a4fe4f6f12b5ccbd367469536553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afdec6603e149c915375499e39aad1e"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a2afdec6603e149c915375499e39aad1e">Ingest_Channel_Heads</a> (string filename, int input_switch=2)</td></tr>
<tr class="memdesc:a2afdec6603e149c915375499e39aad1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to ingest the channel heads raster generated using channel_heads_driver.cpp into a vector of source nodes so that an <a class="el" href="class_l_s_d_junction_network.html" title="Object to create a channel network from an LSDFlowInfo object. ">LSDJunctionNetwork</a> can be created easily from them. <b>UPDATE</b> if the extension is a csv file it reads the node indices directly <b>UPDATE, FJC 20/01/16 - changed default input switch to 2</b> ***********UPDATE - overloaded function to read in the column headers using the csv logic rather than assume that the columns have to be in a specific order. ONLY WORKS WITH CSV EXTENSIONS. FJC 23/03/17*************************.  <a href="#a2afdec6603e149c915375499e39aad1e">More...</a><br/></td></tr>
<tr class="separator:a2afdec6603e149c915375499e39aad1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c82a534553ee1e63342b36493a6d61f"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a6c82a534553ee1e63342b36493a6d61f">Ingest_Channel_Heads_OS</a> (string csv_filename)</td></tr>
<tr class="memdesc:a6c82a534553ee1e63342b36493a6d61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to ingest sources from OS MasterMap Water Network Layer (csv) into a vector of source nodes so that an <a class="el" href="class_l_s_d_junction_network.html" title="Object to create a channel network from an LSDFlowInfo object. ">LSDJunctionNetwork</a> can be easily created from them.  <a href="#a6c82a534553ee1e63342b36493a6d61f">More...</a><br/></td></tr>
<tr class="separator:a6c82a534553ee1e63342b36493a6d61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4909d5d0ed03764813db71a243a02a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a6d4909d5d0ed03764813db71a243a02a">calculate_n_pixels_contributing_from_upslope</a> ()</td></tr>
<tr class="memdesc:a6d4909d5d0ed03764813db71a243a02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the contributing pixels. It can be converted to contributing area by multiplying by the DataResolution^2. In this function a pixel that has no donors has a contributing pixel value of 0.  <a href="#a6d4909d5d0ed03764813db71a243a02a">More...</a><br/></td></tr>
<tr class="separator:a6d4909d5d0ed03764813db71a243a02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267d29c63a08cd9f0f7ba34fe333c39c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a267d29c63a08cd9f0f7ba34fe333c39c">calculate_upslope_reference_indices</a> ()</td></tr>
<tr class="memdesc:a267d29c63a08cd9f0f7ba34fe333c39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This calculates area and makes an index into the s vector for efficient calculation of the basin upslope of a given node.  <a href="#a267d29c63a08cd9f0f7ba34fe333c39c">More...</a><br/></td></tr>
<tr class="separator:a267d29c63a08cd9f0f7ba34fe333c39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20d9bdf9de01bdb642b7990b1d66480"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ac20d9bdf9de01bdb642b7990b1d66480">retrieve_largest_base_level</a> ()</td></tr>
<tr class="memdesc:ac20d9bdf9de01bdb642b7990b1d66480"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the base level node with the greatest drainage area.  <a href="#ac20d9bdf9de01bdb642b7990b1d66480">More...</a><br/></td></tr>
<tr class="separator:ac20d9bdf9de01bdb642b7990b1d66480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05f910c1f72f83a250f3fd4a1a781a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ac05f910c1f72f83a250f3fd4a1a781a7">retrieve_base_level_node</a> (int node)</td></tr>
<tr class="memdesc:ac05f910c1f72f83a250f3fd4a1a781a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the base level node for any given node.  <a href="#ac05f910c1f72f83a250f3fd4a1a781a7">More...</a><br/></td></tr>
<tr class="separator:ac05f910c1f72f83a250f3fd4a1a781a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66c3da828897cbcaf2c65e05e59ed0a"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ab66c3da828897cbcaf2c65e05e59ed0a">get_upslope_nodes</a> (int node_number_outlet)</td></tr>
<tr class="memdesc:ab66c3da828897cbcaf2c65e05e59ed0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns an integer vector containing all the node indexes upslope of of the node with number node_number_outlet.  <a href="#ab66c3da828897cbcaf2c65e05e59ed0a">More...</a><br/></td></tr>
<tr class="separator:ab66c3da828897cbcaf2c65e05e59ed0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6d00123f3cf1516a11bab756349b56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#acc6d00123f3cf1516a11bab756349b56">get_upslope_node_mask</a> (vector&lt; int &gt; source_nodes)</td></tr>
<tr class="memdesc:acc6d00123f3cf1516a11bab756349b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a list of sources and then creates a raster with nodata values where points are not upslope of the sources and 1.0 if they are upslope.  <a href="#acc6d00123f3cf1516a11bab756349b56">More...</a><br/></td></tr>
<tr class="separator:acc6d00123f3cf1516a11bab756349b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362d53cadc85cee33b4b0759b7bf7481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a362d53cadc85cee33b4b0759b7bf7481">get_upslope_node_mask</a> (vector&lt; int &gt; source_nodes, vector&lt; float &gt; node_values)</td></tr>
<tr class="memdesc:a362d53cadc85cee33b4b0759b7bf7481"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a list of sources and then creates a raster with nodata values where points are not upslope of the sources and node_values if they are upslope.  <a href="#a362d53cadc85cee33b4b0759b7bf7481">More...</a><br/></td></tr>
<tr class="separator:a362d53cadc85cee33b4b0759b7bf7481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e5bfcc36a8ade88c7a8d75b1420c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#af8e5bfcc36a8ade88c7a8d75b1420c14">upslope_variable_accumulator</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;accum_raster)</td></tr>
<tr class="memdesc:af8e5bfcc36a8ade88c7a8d75b1420c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function accumulates some variable from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> The most probably use is to accumulate precipitation in order to get a discharge raster.  <a href="#af8e5bfcc36a8ade88c7a8d75b1420c14">More...</a><br/></td></tr>
<tr class="separator:af8e5bfcc36a8ade88c7a8d75b1420c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9e0af9de771adad45f0492dd14ce61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#acf9e0af9de771adad45f0492dd14ce61">is_node_upstream</a> (int current_node, int test_node)</td></tr>
<tr class="memdesc:acf9e0af9de771adad45f0492dd14ce61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether one node is upstream of another node.  <a href="#acf9e0af9de771adad45f0492dd14ce61">More...</a><br/></td></tr>
<tr class="separator:acf9e0af9de771adad45f0492dd14ce61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a90480af6e0f8d8efdeb068dcb61c7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a2a90480af6e0f8d8efdeb068dcb61c7e">is_node_base_level</a> (int node)</td></tr>
<tr class="memdesc:a2a90480af6e0f8d8efdeb068dcb61c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether a node is a base level node.  <a href="#a2a90480af6e0f8d8efdeb068dcb61c7e">More...</a><br/></td></tr>
<tr class="separator:a2a90480af6e0f8d8efdeb068dcb61c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20646aec698fe63841348af402752918"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a20646aec698fe63841348af402752918">get_donor_nodes</a> (int node)</td></tr>
<tr class="memdesc:a20646aec698fe63841348af402752918"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function gets a list of the node indices of the donors to a particular node  <a href="#a20646aec698fe63841348af402752918">More...</a><br/></td></tr>
<tr class="separator:a20646aec698fe63841348af402752918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec62a50b93c3fa21069461cc582adf2"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a2ec62a50b93c3fa21069461cc582adf2">get_upslope_chi</a> (int starting_node, float m_over_n, float A_0)</td></tr>
<tr class="memdesc:a2ec62a50b93c3fa21069461cc582adf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the chi function for all the nodes upslope of a given node.  <a href="#a2ec62a50b93c3fa21069461cc582adf2">More...</a><br/></td></tr>
<tr class="separator:a2ec62a50b93c3fa21069461cc582adf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f469457e6340a523394376ec1c5af5"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a81f469457e6340a523394376ec1c5af5">get_upslope_chi</a> (int starting_node, float m_over_n, float A_0, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Discharge)</td></tr>
<tr class="memdesc:a81f469457e6340a523394376ec1c5af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the chi function for all the nodes upslope of a given node.  this version uses discharge rather than area.  <a href="#a81f469457e6340a523394376ec1c5af5">More...</a><br/></td></tr>
<tr class="separator:a81f469457e6340a523394376ec1c5af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d03a0737d1e0d785f6e1fd6dc73615f"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a4d03a0737d1e0d785f6e1fd6dc73615f">get_upslope_chi</a> (vector&lt; int &gt; &amp;upslope_pixel_list, float m_over_n, float A_0)</td></tr>
<tr class="memdesc:a4d03a0737d1e0d785f6e1fd6dc73615f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the chi function for a list of nodes it isn't really a standalone modules, but is only called from get_upslope_chi above.  <a href="#a4d03a0737d1e0d785f6e1fd6dc73615f">More...</a><br/></td></tr>
<tr class="separator:a4d03a0737d1e0d785f6e1fd6dc73615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b3c7734ba0d0fe9323197aa9756f1d"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ae6b3c7734ba0d0fe9323197aa9756f1d">get_upslope_chi</a> (vector&lt; int &gt; &amp;upslope_pixel_list, float m_over_n, float A_0, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Discharge)</td></tr>
<tr class="memdesc:ae6b3c7734ba0d0fe9323197aa9756f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the chi function for a list of nodes it isn't really a standalone modules, but is only called from get_upslope_chi above  this version uses discharge rather than area.  <a href="#ae6b3c7734ba0d0fe9323197aa9756f1d">More...</a><br/></td></tr>
<tr class="separator:ae6b3c7734ba0d0fe9323197aa9756f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2042aed7d976b065b27aae6367504c"><td class="memItemLeft" align="right" valign="top">map&lt; int, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a4c2042aed7d976b065b27aae6367504c">get_upslope_chi_return_map</a> (vector&lt; int &gt; &amp;upslope_pixel_list, float m_over_n, float A_0, int minimum_pixels)</td></tr>
<tr class="memdesc:a4c2042aed7d976b065b27aae6367504c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the chi function for a list of nodes it isn't really a standalone modules, but is only called from get_upslope_chi above. It returns a map, which is used to speed up computation.  <a href="#a4c2042aed7d976b065b27aae6367504c">More...</a><br/></td></tr>
<tr class="separator:a4c2042aed7d976b065b27aae6367504c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6b3288ff5844e73b687d20d49fa797"><td class="memItemLeft" align="right" valign="top">map&lt; int, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a5a6b3288ff5844e73b687d20d49fa797">get_upslope_chi_return_map</a> (vector&lt; int &gt; &amp;upslope_pixel_list, float m_over_n, float A_0, int minimum_pixels, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Discharge)</td></tr>
<tr class="memdesc:a5a6b3288ff5844e73b687d20d49fa797"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the chi function for a list of nodes it isn't really a standalone modules, but is only called from get_upslope_chi above. It returns a map, which is used to speed up computation  this version uses discharge rather than area.  <a href="#a5a6b3288ff5844e73b687d20d49fa797">More...</a><br/></td></tr>
<tr class="separator:a5a6b3288ff5844e73b687d20d49fa797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8baec90dbb9e5c6cfa43cf95909f65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a3f8baec90dbb9e5c6cfa43cf95909f65">get_upslope_chi_from_multiple_starting_nodes</a> (vector&lt; int &gt; &amp;starting_nodes, float m_over_n, float A_0, float area_threshold)</td></tr>
<tr class="memdesc:a3f8baec90dbb9e5c6cfa43cf95909f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function takes a vector that contains the node indices of starting nodes, and then calculates chi upslope of these nodes to produce a chi map. A threshold drainage area can be used to only map chi where nodes have greater than the threshold drainage area  <a href="#a3f8baec90dbb9e5c6cfa43cf95909f65">More...</a><br/></td></tr>
<tr class="separator:a3f8baec90dbb9e5c6cfa43cf95909f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b466114b4b3e5bfba0aeb7d8fe4997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ae3b466114b4b3e5bfba0aeb7d8fe4997">get_upslope_chi_from_multiple_starting_nodes</a> (vector&lt; int &gt; &amp;starting_nodes, float m_over_n, float A_0, float area_threshold, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Discharge)</td></tr>
<tr class="memdesc:ae3b466114b4b3e5bfba0aeb7d8fe4997"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function takes a vector that contains the node indices of starting nodes, and then calculates chi upslope of these nodes to produce a chi map. A threshold drainage area can be used to only map chi where nodes have greater than the threshold drainage area  <a href="#ae3b466114b4b3e5bfba0aeb7d8fe4997">More...</a><br/></td></tr>
<tr class="separator:ae3b466114b4b3e5bfba0aeb7d8fe4997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069f0b2a7f9a6afe6d9a9333df3222f3"><td class="memItemLeft" align="right" valign="top">map&lt; int, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a069f0b2a7f9a6afe6d9a9333df3222f3">get_upslope_chi_from_single_starting_node</a> (int starting_node, float m_over_n, float A_0, int minimum_pixels)</td></tr>
<tr class="memdesc:a069f0b2a7f9a6afe6d9a9333df3222f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This funtion gets all the upslope chi of a starting node (assuming chi at starting node is 0) and returns a map.  <a href="#a069f0b2a7f9a6afe6d9a9333df3222f3">More...</a><br/></td></tr>
<tr class="separator:a069f0b2a7f9a6afe6d9a9333df3222f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f2ff3b2e4b8b53e5c14898a6bc6368"><td class="memItemLeft" align="right" valign="top">map&lt; int, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a64f2ff3b2e4b8b53e5c14898a6bc6368">get_upslope_chi_from_single_starting_node</a> (int starting_node, float m_over_n, float A_0, int minimum_pixels, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Discharge)</td></tr>
<tr class="memdesc:a64f2ff3b2e4b8b53e5c14898a6bc6368"><td class="mdescLeft">&#160;</td><td class="mdescRight">This funtion gets all the upslope chi of a starting node (assuming chi at starting node is 0) and returns a map.  <a href="#a64f2ff3b2e4b8b53e5c14898a6bc6368">More...</a><br/></td></tr>
<tr class="separator:a64f2ff3b2e4b8b53e5c14898a6bc6368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f73f0e3453d10a014ec589456607de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a81f73f0e3453d10a014ec589456607de">get_upslope_chi_from_all_baselevel_nodes</a> (float m_over_n, float A_0, float area_threshold)</td></tr>
<tr class="memdesc:a81f73f0e3453d10a014ec589456607de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the chi upslope of every base level node that is, it gets the chi values of the entire DEM, assuming all base level nodes have a chi of 0  because this assumes all base level nodes have a chi of 0, this function is probably only appropriate for numerical models.  <a href="#a81f73f0e3453d10a014ec589456607de">More...</a><br/></td></tr>
<tr class="separator:a81f73f0e3453d10a014ec589456607de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeadaaae6baa670269f308c97fe3d577"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#aeeadaaae6baa670269f308c97fe3d577">get_upslope_chi_from_all_baselevel_nodes</a> (float m_over_n, float Q_0, float area_threshold, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Discharge)</td></tr>
<tr class="memdesc:aeeadaaae6baa670269f308c97fe3d577"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the chi upslope of every base level node that is, it gets the chi values of the entire DEM, assuming all base level nodes have a chi of 0  because this assumes all base level nodes have a chi of 0, this function is probably only appropriate for numerical models. This version of the function allows computation with a discharge raster.  <a href="#aeeadaaae6baa670269f308c97fe3d577">More...</a><br/></td></tr>
<tr class="separator:aeeadaaae6baa670269f308c97fe3d577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3f1240445168fc2d584a00f47d076e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a2f3f1240445168fc2d584a00f47d076e">distance_from_outlet</a> ()</td></tr>
<tr class="memdesc:a2f3f1240445168fc2d584a00f47d076e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the distance from outlet of all the base level nodes. Distance is given in spatial units, not in pixels.  <a href="#a2f3f1240445168fc2d584a00f47d076e">More...</a><br/></td></tr>
<tr class="separator:a2f3f1240445168fc2d584a00f47d076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56632f7ad39263926df9e7ee67250af3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a56632f7ad39263926df9e7ee67250af3">calculate_d8_slope</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Elevation)</td></tr>
<tr class="separator:a56632f7ad39263926df9e7ee67250af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9616964fcf461972b1fc2c6a38bd75e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#af9616964fcf461972b1fc2c6a38bd75e">find_farthest_upslope_node</a> (int node, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;DistFromOutlet)</td></tr>
<tr class="memdesc:af9616964fcf461972b1fc2c6a38bd75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the node index of the pixel farthest upslope from the input node.  <a href="#af9616964fcf461972b1fc2c6a38bd75e">More...</a><br/></td></tr>
<tr class="separator:af9616964fcf461972b1fc2c6a38bd75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e172357f7b6b0fb9ecf16124097ffb3"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a6e172357f7b6b0fb9ecf16124097ffb3">sort_node_list_based_on_raster</a> (vector&lt; int &gt; node_vec, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;SortingRaster)</td></tr>
<tr class="memdesc:a6e172357f7b6b0fb9ecf16124097ffb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes a list of nodes and sorts them according to a sorting raster (it could be anything) fin ascending order nodes are then reordered to reflect the sorting of the raster.  <a href="#a6e172357f7b6b0fb9ecf16124097ffb3">More...</a><br/></td></tr>
<tr class="separator:a6e172357f7b6b0fb9ecf16124097ffb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e6526a07ab30e3e65d5ceb4653ca81"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ac3e6526a07ab30e3e65d5ceb4653ca81">sort_node_list_based_on_raster</a> (vector&lt; int &gt; node_vec, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;SortingRaster)</td></tr>
<tr class="memdesc:ac3e6526a07ab30e3e65d5ceb4653ca81"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes a list of nodes and sorts them according to a sorting raster (it could be anything) fin ascending order nodes are then reordered to reflect the sorting of the raster.  <a href="#ac3e6526a07ab30e3e65d5ceb4653ca81">More...</a><br/></td></tr>
<tr class="separator:ac3e6526a07ab30e3e65d5ceb4653ca81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55842b7824c2aaf0a0ab1836078e903"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ae55842b7824c2aaf0a0ab1836078e903">get_node_index_of_coordinate_point</a> (float X_coordinate, float Y_coordinate)</td></tr>
<tr class="memdesc:ae55842b7824c2aaf0a0ab1836078e903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the node index for a point using its X and Y coordinates.  <a href="#ae55842b7824c2aaf0a0ab1836078e903">More...</a><br/></td></tr>
<tr class="separator:ae55842b7824c2aaf0a0ab1836078e903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0135fe6f5e735308a7fe52b98a16da3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a0135fe6f5e735308a7fe52b98a16da3c">get_nodeindices_from_csv</a> (string csv_filename, vector&lt; int &gt; &amp;NIs, vector&lt; float &gt; &amp;X_coords, vector&lt; float &gt; &amp;Y_coords)</td></tr>
<tr class="memdesc:a0135fe6f5e735308a7fe52b98a16da3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vector of nodeindices from csv file.  <a href="#a0135fe6f5e735308a7fe52b98a16da3c">More...</a><br/></td></tr>
<tr class="separator:a0135fe6f5e735308a7fe52b98a16da3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4599121dbcf3d3514b0225bbceb17d3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#af4599121dbcf3d3514b0225bbceb17d3">snap_RasterData_to_Node</a> (int <a class="el" href="class_l_s_d_flow_info.html#a44416159b43371392411d4dafb589bfe">NodeIndex</a>, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;InputRaster, int search_radius)</td></tr>
<tr class="memdesc:af4599121dbcf3d3514b0225bbceb17d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to return the closest value of a raster to a specified node index.  <a href="#af4599121dbcf3d3514b0225bbceb17d3">More...</a><br/></td></tr>
<tr class="separator:af4599121dbcf3d3514b0225bbceb17d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047d37c69f9058164a80f7268bdc974a"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a047d37c69f9058164a80f7268bdc974a">get_sources_index_threshold</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;FlowPixels, int threshold)</td></tr>
<tr class="memdesc:a047d37c69f9058164a80f7268bdc974a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A get sources version that uses the flow accumulation pixels.  <a href="#a047d37c69f9058164a80f7268bdc974a">More...</a><br/></td></tr>
<tr class="separator:a047d37c69f9058164a80f7268bdc974a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6342b2e3e65e15a4356e7fb130078c1b"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a6342b2e3e65e15a4356e7fb130078c1b">get_sources_slope_area</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;FlowPixels, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Slope, int threshold)</td></tr>
<tr class="memdesc:a6342b2e3e65e15a4356e7fb130078c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A get sources version that uses AS^2 (area and slope).  <a href="#a6342b2e3e65e15a4356e7fb130078c1b">More...</a><br/></td></tr>
<tr class="separator:a6342b2e3e65e15a4356e7fb130078c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609f6ba59b5122df126b18fa7f957910"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a609f6ba59b5122df126b18fa7f957910">get_sources_from_mapped_channel_heads</a> (vector&lt; float &gt; &amp;X_coords, vector&lt; float &gt; &amp;Y_coords)</td></tr>
<tr class="memdesc:a609f6ba59b5122df126b18fa7f957910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector of source nodes based on the X and Y coordinates of mapped channel heads. Can be used if all the channel heads in a basin were mapped to get the stream network and calculate the drainage density.  <a href="#a609f6ba59b5122df126b18fa7f957910">More...</a><br/></td></tr>
<tr class="separator:a609f6ba59b5122df126b18fa7f957910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42c90b98d47f315f000827bde55a9c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ac42c90b98d47f315f000827bde55a9c1">D8_Trace</a> (int i, int j, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> StreamNetwork, float &amp;length, int &amp;receiver_row, int &amp;receiver_col, Array2D&lt; int &gt; &amp;Path)</td></tr>
<tr class="memdesc:ac42c90b98d47f315f000827bde55a9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a downslope trace using D8 from a given point source (i,j).  <a href="#ac42c90b98d47f315f000827bde55a9c1">More...</a><br/></td></tr>
<tr class="separator:ac42c90b98d47f315f000827bde55a9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f31d6e8f6f7bb27f0374cd6363b164b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a6f31d6e8f6f7bb27f0374cd6363b164b">MoveChannelHeadDown</a> (vector&lt; int &gt; Sources, float MoveDist, vector&lt; int &gt; &amp;DownslopeSources, vector&lt; int &gt; &amp;FinalHeads)</td></tr>
<tr class="memdesc:a6f31d6e8f6f7bb27f0374cd6363b164b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the location of the channel head downslope by a user defined distance.  <a href="#a6f31d6e8f6f7bb27f0374cd6363b164b">More...</a><br/></td></tr>
<tr class="separator:a6f31d6e8f6f7bb27f0374cd6363b164b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ede99c078aa517d85d51edd3645958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ad2ede99c078aa517d85d51edd3645958">MoveChannelHeadUp</a> (vector&lt; int &gt; Sources, float MoveDist, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> DEM, vector&lt; int &gt; &amp;UpslopeSources, vector&lt; int &gt; &amp;FinalHeads)</td></tr>
<tr class="memdesc:ad2ede99c078aa517d85d51edd3645958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the location of the channel head upslope by a user defined distance.  <a href="#ad2ede99c078aa517d85d51edd3645958">More...</a><br/></td></tr>
<tr class="separator:ad2ede99c078aa517d85d51edd3645958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe884a21a2f30af0be84acda83ceb2d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe884a21a2f30af0be84acda83ceb2d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>HilltopFlowRoutingOriginal</b> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Elevation, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Hilltops, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Slope, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Aspect, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> StreamNetwork)</td></tr>
<tr class="separator:abe884a21a2f30af0be84acda83ceb2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e92e1b91d98d971a404810e47d676a0"><td class="memItemLeft" align="right" valign="top">vector&lt; Array2D&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a7e92e1b91d98d971a404810e47d676a0">HilltopFlowRouting</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Elevation, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Hilltop_ID, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Slope, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Aspect, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> HilltopCurv, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> PlanCurvature, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> StreamNetwork, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Basins, string Prefix, bool print_paths_switch, int thinning, string trace_path, bool basin_filter_switch, vector&lt; int &gt; Target_Basin_Vector)</td></tr>
<tr class="memdesc:a7e92e1b91d98d971a404810e47d676a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hilltop flow routing.  <a href="#a7e92e1b91d98d971a404810e47d676a0">More...</a><br/></td></tr>
<tr class="separator:a7e92e1b91d98d971a404810e47d676a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14222a4a6c9758138bf15ac810728dd1"><td class="memItemLeft" align="right" valign="top">vector&lt; Array2D&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a14222a4a6c9758138bf15ac810728dd1">HilltopFlowRouting_RAW</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Elevation, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Hilltops, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Slope, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> StreamNetwork, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> D_inf_Flowdir, string Prefix, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Basins, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> PlanCurvature, bool print_paths_switch, int thinning, string trace_path, bool basin_filter_switch, vector&lt; int &gt; Target_Basin_Vector)</td></tr>
<tr class="memdesc:a14222a4a6c9758138bf15ac810728dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hilltop flow routing which runs on unsmoothed topography.  <a href="#a14222a4a6c9758138bf15ac810728dd1">More...</a><br/></td></tr>
<tr class="separator:a14222a4a6c9758138bf15ac810728dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710c0f061cded13e2f213d357ea8f3d8"><td class="memItemLeft" align="right" valign="top">vector&lt; Array2D&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a710c0f061cded13e2f213d357ea8f3d8">HilltopFlowRouting_Profile</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Elevation, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Hilltops, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Slope, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> StreamNetwork, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> D_inf_Flowdir, string Prefix, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Basins, bool print_paths_switch, int thinning, string trace_path, bool basin_filter_switch, vector&lt; int &gt; Target_Basin_Vector)</td></tr>
<tr class="memdesc:a710c0f061cded13e2f213d357ea8f3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hilltop flow routing which generates elevation profiles.  <a href="#a710c0f061cded13e2f213d357ea8f3d8">More...</a><br/></td></tr>
<tr class="separator:a710c0f061cded13e2f213d357ea8f3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fb2b9ca2add1124e9b5b8d44ba6412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ab6fb2b9ca2add1124e9b5b8d44ba6412">find_cells_influenced_by_nodata</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Bordered_mask, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Topography)</td></tr>
<tr class="memdesc:ab6fb2b9ca2add1124e9b5b8d44ba6412"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a mask depicting all cells that are influenced by a pixel that is either on the edge of the DEM or adjacent to a NoData node.  <a href="#ab6fb2b9ca2add1124e9b5b8d44ba6412">More...</a><br/></td></tr>
<tr class="separator:ab6fb2b9ca2add1124e9b5b8d44ba6412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6150fa7629c6807e22a977f0993e65b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a6150fa7629c6807e22a977f0993e65b0">is_upstream_influenced_by_nodata</a> (int nodeindex, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;test_raster)</td></tr>
<tr class="memdesc:a6150fa7629c6807e22a977f0993e65b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function looks at all uplope nodes and sees if any are bordered by nodata.  <a href="#a6150fa7629c6807e22a977f0993e65b0">More...</a><br/></td></tr>
<tr class="separator:a6150fa7629c6807e22a977f0993e65b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274c347f40e69498ed9b1fa1fee94846"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a274c347f40e69498ed9b1fa1fee94846">basin_edge_extractor</a> (int outlet_node, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Topography)</td></tr>
<tr class="memdesc:a274c347f40e69498ed9b1fa1fee94846"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets nodes that are possibly on basin edge by removing those that do not border NoData. Intended to be passed to function for finding concave hull of basin.  <a href="#a274c347f40e69498ed9b1fa1fee94846">More...</a><br/></td></tr>
<tr class="separator:a274c347f40e69498ed9b1fa1fee94846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af27583a82895823233920d0d763e86"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a9af27583a82895823233920d0d763e86">get_raster_values_for_nodes</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Raster, vector&lt; int &gt; &amp;node_indices)</td></tr>
<tr class="memdesc:a9af27583a82895823233920d0d763e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns all the values from a raster for a corresponding input vector of node indices.  <a href="#a9af27583a82895823233920d0d763e86">More...</a><br/></td></tr>
<tr class="separator:a9af27583a82895823233920d0d763e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa616c161746e2268c634b42bce6f1985"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa616c161746e2268c634b42bce6f1985"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>D_Inf_single_trace_to_channel</b> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Elevation, int start_node, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> StreamNetwork, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> D_inf_Flowdir, vector&lt; vector&lt; float &gt; &gt; &amp;output_trace_coordinates, vector&lt; float &gt; &amp;output_trace_metrics, int &amp;output_channel_node, bool &amp;skip_trace)</td></tr>
<tr class="separator:aa616c161746e2268c634b42bce6f1985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21284bd44dbb045a66667138767a8246"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21284bd44dbb045a66667138767a8246"></a>
vector&lt; Array2D&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HilltopFlowRoutingBedrock</b> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Elevation, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Hilltops, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Slope, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> StreamNetwork, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Aspect, string Prefix, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Basins, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> PlanCurvature, bool print_paths_switch, int thinning, string trace_path, bool basin_filter_switch, vector&lt; int &gt; Target_Basin_Vector, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> RockExposure)</td></tr>
<tr class="separator:a21284bd44dbb045a66667138767a8246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68718a298107588c9c07704689595e5"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ac68718a298107588c9c07704689595e5">ProcessEndPointsToChannelHeads</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Ends)</td></tr>
<tr class="memdesc:ac68718a298107588c9c07704689595e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method removes end nodes which are not the uppermost extent of the channel network.  <a href="#ac68718a298107588c9c07704689595e5">More...</a><br/></td></tr>
<tr class="separator:ac68718a298107588c9c07704689595e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ed80044f10375040231117dced9cc5"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a08ed80044f10375040231117dced9cc5">RemoveSinglePxChannels</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> StreamNetwork, vector&lt; int &gt; Sources)</td></tr>
<tr class="memdesc:a08ed80044f10375040231117dced9cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method removes single pixel channels from a channel network.  <a href="#a08ed80044f10375040231117dced9cc5">More...</a><br/></td></tr>
<tr class="separator:a08ed80044f10375040231117dced9cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499767541c0ce235ee20f1a337ff816b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a499767541c0ce235ee20f1a337ff816b">get_downslope_node_after_fixed_visited_nodes</a> (int source_node, int outlet_node, int n_nodes_to_visit, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;VisitedRaster)</td></tr>
<tr class="memdesc:a499767541c0ce235ee20f1a337ff816b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts from a source and goes downstream until it either accumulates n_nodes_to_visit or hits a base level node.  <a href="#a499767541c0ce235ee20f1a337ff816b">More...</a><br/></td></tr>
<tr class="separator:a499767541c0ce235ee20f1a337ff816b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c09aa570076c5c069acf9cf1f50041e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a5c09aa570076c5c069acf9cf1f50041e">get_flow_length_between_nodes</a> (int UpstreamNode, int DownstreamNode)</td></tr>
<tr class="memdesc:a5c09aa570076c5c069acf9cf1f50041e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the flow distance between two nodes.  <a href="#a5c09aa570076c5c069acf9cf1f50041e">More...</a><br/></td></tr>
<tr class="separator:a5c09aa570076c5c069acf9cf1f50041e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064c9803a833a25def127c767c648222"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a064c9803a833a25def127c767c648222">get_slope_between_nodes</a> (int upslope_node, int downslope_node, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Elevation)</td></tr>
<tr class="memdesc:a064c9803a833a25def127c767c648222"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the slope between two nodes based on flow length.  <a href="#a064c9803a833a25def127c767c648222">More...</a><br/></td></tr>
<tr class="separator:a064c9803a833a25def127c767c648222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff2b0e84f83b3eb03ba9bc4797ae780"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#abff2b0e84f83b3eb03ba9bc4797ae780">get_Euclidian_distance</a> (int node_A, int node_B)</td></tr>
<tr class="memdesc:abff2b0e84f83b3eb03ba9bc4797ae780"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the Euclidian distance between two nodes.  <a href="#abff2b0e84f83b3eb03ba9bc4797ae780">More...</a><br/></td></tr>
<tr class="separator:abff2b0e84f83b3eb03ba9bc4797ae780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45758abb46e5fb335c0b624bc855a53a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a45758abb46e5fb335c0b624bc855a53a">snap_to_hilltop</a> (int a, int b, int search_radius, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Hilltops)</td></tr>
<tr class="memdesc:a45758abb46e5fb335c0b624bc855a53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to snap a point, given as raster coordinates, to a cell in a raster of hilltops.  <a href="#a45758abb46e5fb335c0b624bc855a53a">More...</a><br/></td></tr>
<tr class="separator:a45758abb46e5fb335c0b624bc855a53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32771fc62765c87b1e0de12ba2589d9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a32771fc62765c87b1e0de12ba2589d9a">snap_to_hilltops</a> (vector&lt; float &gt; x_locs, vector&lt; float &gt; y_locs, int search_radius, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Hilltops, vector&lt; int &gt; &amp;SnappedNodes, vector&lt; int &gt; &amp;Valid_node_IDs)</td></tr>
<tr class="memdesc:a32771fc62765c87b1e0de12ba2589d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around snap_to_hilltop function to process a collection of utm points.  <a href="#a32771fc62765c87b1e0de12ba2589d9a">More...</a><br/></td></tr>
<tr class="separator:a32771fc62765c87b1e0de12ba2589d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2d9b2d4192e42b41de6ff6da142acc82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d9b2d4192e42b41de6ff6da142acc82"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a2d9b2d4192e42b41de6ff6da142acc82">NRows</a></td></tr>
<tr class="memdesc:a2d9b2d4192e42b41de6ff6da142acc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows. <br/></td></tr>
<tr class="separator:a2d9b2d4192e42b41de6ff6da142acc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f1118cce6d036a4228df2bdde172e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05f1118cce6d036a4228df2bdde172e6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a05f1118cce6d036a4228df2bdde172e6">NCols</a></td></tr>
<tr class="memdesc:a05f1118cce6d036a4228df2bdde172e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns. <br/></td></tr>
<tr class="separator:a05f1118cce6d036a4228df2bdde172e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f24bdc8db1c2550fb201d554ddd0149"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f24bdc8db1c2550fb201d554ddd0149"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a4f24bdc8db1c2550fb201d554ddd0149">XMinimum</a></td></tr>
<tr class="memdesc:a4f24bdc8db1c2550fb201d554ddd0149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum X coordinate. <br/></td></tr>
<tr class="separator:a4f24bdc8db1c2550fb201d554ddd0149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9feabc95b0f32d60f39c5b6d14577f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e9feabc95b0f32d60f39c5b6d14577f"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a6e9feabc95b0f32d60f39c5b6d14577f">YMinimum</a></td></tr>
<tr class="memdesc:a6e9feabc95b0f32d60f39c5b6d14577f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum Y coordinate. <br/></td></tr>
<tr class="separator:a6e9feabc95b0f32d60f39c5b6d14577f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeebf8bc208ea7cdec4236a09f67673"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1eeebf8bc208ea7cdec4236a09f67673"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a1eeebf8bc208ea7cdec4236a09f67673">DataResolution</a></td></tr>
<tr class="memdesc:a1eeebf8bc208ea7cdec4236a09f67673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data resolution. <br/></td></tr>
<tr class="separator:a1eeebf8bc208ea7cdec4236a09f67673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3fa05d967eabb4aa7305d3ce7cd714"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc3fa05d967eabb4aa7305d3ce7cd714"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#adc3fa05d967eabb4aa7305d3ce7cd714">NoDataValue</a></td></tr>
<tr class="memdesc:adc3fa05d967eabb4aa7305d3ce7cd714"><td class="mdescLeft">&#160;</td><td class="mdescRight">No data value. <br/></td></tr>
<tr class="separator:adc3fa05d967eabb4aa7305d3ce7cd714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8e915407bd64d9d888cfe4d0c9789a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d8e915407bd64d9d888cfe4d0c9789a"></a>
map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a1d8e915407bd64d9d888cfe4d0c9789a">GeoReferencingStrings</a></td></tr>
<tr class="memdesc:a1d8e915407bd64d9d888cfe4d0c9789a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of strings for holding georeferencing information. <br/></td></tr>
<tr class="separator:a1d8e915407bd64d9d888cfe4d0c9789a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e489c88a5bf74b166a59776b9d9a31f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e489c88a5bf74b166a59776b9d9a31f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a1e489c88a5bf74b166a59776b9d9a31f">NDataNodes</a></td></tr>
<tr class="memdesc:a1e489c88a5bf74b166a59776b9d9a31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes in the raster that have data. <br/></td></tr>
<tr class="separator:a1e489c88a5bf74b166a59776b9d9a31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44416159b43371392411d4dafb589bfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44416159b43371392411d4dafb589bfe"></a>
Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a44416159b43371392411d4dafb589bfe">NodeIndex</a></td></tr>
<tr class="memdesc:a44416159b43371392411d4dafb589bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array that says what node number is at a given row and column. <br/></td></tr>
<tr class="separator:a44416159b43371392411d4dafb589bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6cabf14e70d61b378df8574c807ac9"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a4c6cabf14e70d61b378df8574c807ac9">FlowDirection</a></td></tr>
<tr class="memdesc:a4c6cabf14e70d61b378df8574c807ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A raster of flow direction information.  <a href="#a4c6cabf14e70d61b378df8574c807ac9">More...</a><br/></td></tr>
<tr class="separator:a4c6cabf14e70d61b378df8574c807ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d974596f3c1fc9d5320c8bfc791b792"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d974596f3c1fc9d5320c8bfc791b792"></a>
Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a6d974596f3c1fc9d5320c8bfc791b792">FlowLengthCode</a></td></tr>
<tr class="memdesc:a6d974596f3c1fc9d5320c8bfc791b792"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code to denote the flow length from the node to its reciever node. <b>Each node has one and only one receiver.</b> <br/>
<br/>
0 == no receiver/self receiver (base level) <br/>
1 == cardinal direction, flow length = DataResolution <br/>
2 == diagonal, flow length = DataResolution*(1/sqrt(2)) <br/>
. <br/></td></tr>
<tr class="separator:a6d974596f3c1fc9d5320c8bfc791b792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60f22caa392e4a6f6710ade131b258e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad60f22caa392e4a6f6710ade131b258e"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ad60f22caa392e4a6f6710ade131b258e">RowIndex</a></td></tr>
<tr class="memdesc:ad60f22caa392e4a6f6710ade131b258e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This stores the row of a node in the vectorized node index. It, combined with ColIndex, is the inverse of NodeIndex. <br/></td></tr>
<tr class="separator:ad60f22caa392e4a6f6710ade131b258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59f217811a24b3439723e167c23becc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad59f217811a24b3439723e167c23becc"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ad59f217811a24b3439723e167c23becc">ColIndex</a></td></tr>
<tr class="memdesc:ad59f217811a24b3439723e167c23becc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This stores the column of a node in the vectorized node index. It, combined with RowIndex, is the inverse of NodeIndex. <br/></td></tr>
<tr class="separator:ad59f217811a24b3439723e167c23becc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58243ee7dbef320547042b059fffffc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58243ee7dbef320547042b059fffffc3"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a58243ee7dbef320547042b059fffffc3">BaseLevelNodeList</a></td></tr>
<tr class="memdesc:a58243ee7dbef320547042b059fffffc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of base level nodes. <br/></td></tr>
<tr class="separator:a58243ee7dbef320547042b059fffffc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30126eb1dd75b90132e82333c8c1f9c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30126eb1dd75b90132e82333c8c1f9c0"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a30126eb1dd75b90132e82333c8c1f9c0">NDonorsVector</a></td></tr>
<tr class="memdesc:a30126eb1dd75b90132e82333c8c1f9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the number of donors to each node. <br/></td></tr>
<tr class="separator:a30126eb1dd75b90132e82333c8c1f9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe3996d9dc87e49db97db25bd753ee8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe3996d9dc87e49db97db25bd753ee8"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a8fe3996d9dc87e49db97db25bd753ee8">ReceiverVector</a></td></tr>
<tr class="memdesc:a8fe3996d9dc87e49db97db25bd753ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the node index of the receiving node. <br/></td></tr>
<tr class="separator:a8fe3996d9dc87e49db97db25bd753ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6d655fc87fbfa217c4945c8c3540df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e6d655fc87fbfa217c4945c8c3540df"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a5e6d655fc87fbfa217c4945c8c3540df">DeltaVector</a></td></tr>
<tr class="memdesc:a5e6d655fc87fbfa217c4945c8c3540df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the delta vector which is used to index into the donor stack and order contributing nodes. See Braun and Willett (2012). <br/></td></tr>
<tr class="separator:a5e6d655fc87fbfa217c4945c8c3540df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfae2eed1e1b0fd4357bc8eab15d9f6c"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#abfae2eed1e1b0fd4357bc8eab15d9f6c">DonorStackVector</a></td></tr>
<tr class="separator:abfae2eed1e1b0fd4357bc8eab15d9f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac542cd2fc62fdef8f855616d1641b36d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac542cd2fc62fdef8f855616d1641b36d"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ac542cd2fc62fdef8f855616d1641b36d">SVector</a></td></tr>
<tr class="memdesc:ac542cd2fc62fdef8f855616d1641b36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This vector is used to caluculate flow accumulation. For each base level node it progresses from a hilltop to a confluence and then jumps to the next hilltop so that by cascading down through the node indices in this list one can quickly calculate drainage area, discharge, sediment flux, etc. <br/></td></tr>
<tr class="separator:ac542cd2fc62fdef8f855616d1641b36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cc6ac60e26aa72acaa5ec1a36e0d0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00cc6ac60e26aa72acaa5ec1a36e0d0a"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a00cc6ac60e26aa72acaa5ec1a36e0d0a">BLBasinVector</a></td></tr>
<tr class="memdesc:a00cc6ac60e26aa72acaa5ec1a36e0d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This stores the base level node for all of the nodes in the DEM. <br/></td></tr>
<tr class="separator:a00cc6ac60e26aa72acaa5ec1a36e0d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda73fe76a23792891440e39eb6dd264"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acda73fe76a23792891440e39eb6dd264"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#acda73fe76a23792891440e39eb6dd264">SVectorIndex</a></td></tr>
<tr class="memdesc:acda73fe76a23792891440e39eb6dd264"><td class="mdescLeft">&#160;</td><td class="mdescRight">This points to the starting point in the S vector of each node. <br/></td></tr>
<tr class="separator:acda73fe76a23792891440e39eb6dd264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab535a2cc8ff47f19d03fdffe385fa986"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab535a2cc8ff47f19d03fdffe385fa986"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#ab535a2cc8ff47f19d03fdffe385fa986">NContributingNodes</a></td></tr>
<tr class="memdesc:ab535a2cc8ff47f19d03fdffe385fa986"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of contributing nodes <b>INCULDING SELF</b> to a current pixel. It is used in conjunction with the SVectorIndex to build basins upslope of any and all nodes in the node list. <br/></td></tr>
<tr class="separator:ab535a2cc8ff47f19d03fdffe385fa986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6d2a809055715812f57dc311363517"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#a7b6d2a809055715812f57dc311363517">BoundaryConditions</a></td></tr>
<tr class="memdesc:a7b6d2a809055715812f57dc311363517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boundary conditions stored in a vector of four strings. The conditions are North[0] East[1] South[2] West[3].  <a href="#a7b6d2a809055715812f57dc311363517">More...</a><br/></td></tr>
<tr class="separator:a7b6d2a809055715812f57dc311363517"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af16c6f2616a28bdf3cdf8a94b839cb41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af16c6f2616a28bdf3cdf8a94b839cb41"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_flow_info.html#af16c6f2616a28bdf3cdf8a94b839cb41">LSDJunctionNetwork</a></td></tr>
<tr class="memdesc:af16c6f2616a28bdf3cdf8a94b839cb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy of the <a class="el" href="class_l_s_d_junction_network.html" title="Object to create a channel network from an LSDFlowInfo object. ">LSDJunctionNetwork</a> description here when written. <br/></td></tr>
<tr class="separator:af16c6f2616a28bdf3cdf8a94b839cb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Object to perform flow routing. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a71de786a2041fff1691ff3690229c8a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDFlowInfo::LSDFlowInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The create function. This is default and throws an error. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a330498c7d149053891518b5ff2987aba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDFlowInfo::LSDFlowInfo </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a FlowInfo object from a binary flowinfo data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>String of the binary flowinfo data file to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a298a3e0a97ec15864f8368cb6f8a4a88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDFlowInfo::LSDFlowInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>TopoRaster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a FlowInfo object from a binary flowinfo data.  This assumes no flux boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TopoRaster</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object containing the topographic data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>3/07/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a9ff2067b00d2575c6e72d7740b59786d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDFlowInfo::LSDFlowInfo </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>BoundaryConditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>TopoRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a FlowInfo object from topography. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BoundaryConditions</td><td>Vector&lt;string&gt; of the boundary conditions at each edge of the DEM file. Boundary conditions can start with 'P' or 'p' for periodic, 'B' or 'b' for base level, or anything else for no flux. the vector shold have 4 elements, 0 is north, 1 is east, 2 is south and 3 is west </td></tr>
    <tr><td class="paramname">TopoRaster</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object containing the topographic data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a372a1cce7347b9d7b3a2ec8c59869d59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::add_to_stack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lm_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>j_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bl_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive add_to_stack routine, from Braun and Willett (2012) equations 12 and 13. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lm_index</td><td>Integer </td></tr>
    <tr><td class="paramname">j_index</td><td>Integer </td></tr>
    <tr><td class="paramname">bl_node</td><td>Integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a274c347f40e69498ed9b1fa1fee94846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::basin_edge_extractor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outlet_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Topography</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets nodes that are possibly on basin edge by removing those that do not border NoData. Intended to be passed to function for finding concave hull of basin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outlet</td><td>node The node of the outlet </td></tr>
    <tr><td class="paramname">Topography</td><td>this is the <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> containing topographic data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with the node indices of nodes that are adjacent to nodata within the basin </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25/04/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a56632f7ad39263926df9e7ee67250af3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDFlowInfo::calculate_d8_slope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Elevation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>calculates the slope measured in the d8 flow direction base level nodes have slope of 0; slope is measured from node to receiver </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>elevation raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raster of the d8 slope </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/09/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a6d4909d5d0ed03764813db71a243a02a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDFlowInfo::calculate_n_pixels_contributing_from_upslope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the contributing pixels. It can be converted to contributing area by multiplying by the DataResolution^2. In this function a pixel that has no donors has a contributing pixel value of 0. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of upslope contributing pixels. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a267d29c63a08cd9f0f7ba34fe333c39c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::calculate_upslope_reference_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This calculates area and makes an index into the s vector for efficient calculation of the basin upslope of a given node. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="ae34c62d09c74e2b06923cda4b7db8f56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LSDFlowInfo::check_if_point_is_in_raster </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>X_coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Y_coordinate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this check to see if a point is within the raster </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X_coordinate</td><td>the x location of the point </td></tr>
    <tr><td class="paramname">Y_coordinate</td><td>the y location of the point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is_in_raster a boolean telling if the point is in the raster </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/11/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ac42c90b98d47f315f000827bde55a9c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::D8_Trace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>StreamNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>receiver_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>receiver_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a downslope trace using D8 from a given point source (i,j). </p>
<p>Overwrites input parameters to return a raster of the path, the length of the trace and the final pixel coordinates of the trace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Row index of starting point for trace. </td></tr>
    <tr><td class="paramname">j</td><td>Column index of starting point for trace. </td></tr>
    <tr><td class="paramname">StreamNetwork</td><td>An <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the stream network. </td></tr>
    <tr><td class="paramname">length</td><td>Length of trace in spatial units. </td></tr>
    <tr><td class="paramname">receiver_row</td><td>Row index of ending point for trace. </td></tr>
    <tr><td class="paramname">receiver_col</td><td>Column index of ending point for trace. </td></tr>
    <tr><td class="paramname">Path</td><td>Empty raster to store the final trace path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/1/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a027e03d34a1b6f8bc703f545b999f9c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDFlowInfo::data_column_to_float </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, vector&lt; string &gt; &gt;&#160;</td>
          <td class="paramname"><em>data_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets a data column from the csv file, and converts it to a float vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_name</td><td>a string that holds the column name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of floats: this holds the data. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM (ported into FlowInfo FJC 23/03/17) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/02/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a48e122225b8d3ca1ae122ff7c5f5dad5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::data_column_to_int </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, vector&lt; string &gt; &gt;&#160;</td>
          <td class="paramname"><em>data_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets a data column from the csv file, and converts it to an int vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_name</td><td>a string that holds the column name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of ints: this holds the data. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM (ported into FlowInfo FJC 23/03/17) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/02/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a2f3f1240445168fc2d584a00f47d076e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDFlowInfo::distance_from_outlet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the distance from outlet of all the base level nodes. Distance is given in spatial units, not in pixels. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of the distance to the outlet for all baselevel nodes. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="ab6fb2b9ca2add1124e9b5b8d44ba6412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDFlowInfo::find_cells_influenced_by_nodata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Bordered_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Topography</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a mask depicting all cells that are influenced by a pixel that is either on the edge of the DEM or adjacent to a NoData node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Bordered_mask</td><td>and <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> that is created by the function find_cells_bordered_by_nodata() in <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> </td></tr>
    <tr><td class="paramname">Topography</td><td>this is the <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> containing topographic data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Influenced_mask the <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> that has values 1 where pixels are influenced by a pixel on the border or next to nodata. They have 0 otherwise </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>31/10/14 </dd></dl>

</div>
</div>
<a class="anchor" id="af9616964fcf461972b1fc2c6a38bd75e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::find_farthest_upslope_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>DistFromOutlet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns the node index of the pixel farthest upslope from the input node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node from which you want to find the farthest upslope pixel. </td></tr>
    <tr><td class="paramname">DistFromOutlet</td><td>an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> containing the distance from the outlet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This returns the node index of the pixel farthest upslope from the input node. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25/19/13 </dd></dl>

</div>
</div>
<a class="anchor" id="aabe40b37ac16464fd0360ba92f7b75f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDFlowInfo::get_BaseLevelNodeList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Vector of all base level nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a046c668ca53a462ba7cd828d6154f0b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; string &gt; LSDFlowInfo::get_data_column </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, vector&lt; string &gt; &gt;&#160;</td>
          <td class="paramname"><em>data_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets a data column from the csv file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_name</td><td>a string that holds the column name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings: this holds the data. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM (ported into FlowInfo FJC 23/03/17) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/02/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="ade2380e21eeebe616891c3bf283362aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDFlowInfo::get_DataResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Data resolution as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a20646aec698fe63841348af402752918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::get_donor_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function gets a list of the node indices of the donors to a particular node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>this is the nodeindex of the node for which you want to find the donors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of the donor nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/10/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="a5c420edac35799ae1eece2cee323751d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDFlowInfo::get_donorStack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>donor stack vector (depth first search sequence of nodes) </dd></dl>

</div>
</div>
<a class="anchor" id="a499767541c0ce235ee20f1a337ff816b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::get_downslope_node_after_fixed_visited_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outlet_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_nodes_to_visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>VisitedRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts from a source and goes downstream until it either accumulates n_nodes_to_visit or hits a base level node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_node</td><td>The starting node </td></tr>
    <tr><td class="paramname">outlet_node</td><td>A node that serves as an end to the channel before the base level. If this is set to a node not on the channel (e.g., -9999) then the node looks for accuulation or a base level node only </td></tr>
    <tr><td class="paramname">n_nodes_to_visit</td><td>the number of visited pixels the flow function will travese before it stops  A raster that has pixels indicating if they have been visited or not. A visited pixel is denoted by 1, non visted by 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>outlet_nde the node at the end of the flow path </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19/05/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a10adeea4cf404477ee2886ee7dab090c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDFlowInfo::get_DrainageArea_square_km </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>this_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the draiange area of a node in square km </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this_node</td><td>node of interest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>draiange area in square km </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>06/02/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a5d60a5c2f274755d478589f201b4286d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDFlowInfo::get_DrainageArea_square_m </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>this_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the draiange area of a node in square m </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this_node</td><td>node of interest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>draiange area in square km </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/05/18 </dd></dl>

</div>
</div>
<a class="anchor" id="abff2b0e84f83b3eb03ba9bc4797ae780"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDFlowInfo::get_Euclidian_distance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the Euclidian distance between two nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_A</td><td>the first node </td></tr>
    <tr><td class="paramname">node_B</td><td>the second node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>distance between the two nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/02/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a5c09aa570076c5c069acf9cf1f50041e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDFlowInfo::get_flow_length_between_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>UpstreamNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>DownstreamNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the flow distance between two nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UpstreamNode</td><td>the upstream node </td></tr>
    <tr><td class="paramname">Downstreamnode</td><td>the downstream node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>flow length between the nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/09/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a41ae185533c1891b793ed368d6afa714"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt;int&gt; LSDFlowInfo::get_FlowDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>FlowDirection values as a 2D Array. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a10ba47ff2ab7f532ea0cb3edff5970"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string,string&gt; LSDFlowInfo::get_GeoReferencingStrings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Georeferencing information </dd></dl>

</div>
</div>
<a class="anchor" id="abbdffcafa61f370cf32d5d6d14e251f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::get_lat_and_long_from_current_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>current_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>current_lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>current_long</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a>&#160;</td>
          <td class="paramname"><em>Converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the lat and longitude coordinates of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_node</td><td>Integer index of a given node. </td></tr>
    <tr><td class="paramname">current_lat</td><td>latitude. Will be replaced by function </td></tr>
    <tr><td class="paramname">current_long</td><td>longitude. Will be replaced by function </td></tr>
    <tr><td class="paramname">Converter</td><td>A coordinate converter object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/04/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a92d7a5547e984b5735adadc7eb4a4137"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::get_lat_and_long_locations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>longitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a>&#160;</td>
          <td class="paramname"><em>Converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function to get the lat and long of a node in the raster  Assumes WGS84 ellipsiod </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the node </td></tr>
    <tr><td class="paramname">col</td><td>the col of the node </td></tr>
    <tr><td class="paramname">lat</td><td>the latitude of the node (in decimal degrees, replaced by function) Note: this is a double, because a float does not have sufficient precision relative to a UTM location (which is in metres) </td></tr>
    <tr><td class="paramname">long</td><td>the longitude of the node (in decimal degrees, replaced by function) Note: this is a double, because a float does not have sufficient precision relative to a UTM location (which is in metres) </td></tr>
    <tr><td class="paramname">Converter</td><td>a converter object (from LSDShapeTools) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a026d9a23d364d47bb0f2da8f2bb50890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::get_lat_and_long_locations </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>longitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a>&#160;</td>
          <td class="paramname"><em>Converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function to get the lat and long of a location provided as northing and easting  Assumes WGS84 ellipsiod </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the Easting of the location </td></tr>
    <tr><td class="paramname">Y</td><td>the Northing of the location </td></tr>
    <tr><td class="paramname">lat</td><td>the latitude of the node (in decimal degrees, replaced by function) Note: this is a double, because a float does not have sufficient precision relative to a UTM location (which is in metres) </td></tr>
    <tr><td class="paramname">long</td><td>the longitude of the node (in decimal degrees, replaced by function) Note: this is a double, because a float does not have sufficient precision relative to a UTM location (which is in metres) </td></tr>
    <tr><td class="paramname">Converter</td><td>a converter object (from LSDShapeTools) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>MDH </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/7/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a73f6bb5feb4e2006d3b4be9d42d9a0cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::get_LocalFlowDirection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the FlowDirection of a row and column pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Integer of row index. </td></tr>
    <tr><td class="paramname">col</td><td>Integer of col index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer of the flow direction. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/02/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a1191a6fd02ae41143bfb91a72aa94a1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::get_NCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of columns as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a65a05debd93d95cb8cb304e244afc71a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::get_NDataNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of nodes with data as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f1b7cb15e5da5636e704e86add9314f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::get_NoDataValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>No Data Value as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ae55842b7824c2aaf0a0ab1836078e903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::get_node_index_of_coordinate_point </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>X_coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Y_coordinate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the node index for a point using its X and Y coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X_coordinate</td><td>X_coord of point </td></tr>
    <tr><td class="paramname">Y_coordinate</td><td>Y_coord of point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int with node index of point </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>11/02/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a6f358ea8483f2508d278fcc4e8c29855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::get_NodeIndex_from_row_col </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index from row/col. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>row/col of the nodeindex 2DArray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>BG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/12/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a0135fe6f5e735308a7fe52b98a16da3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::get_nodeindices_from_csv </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>csv_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>NIs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get vector of nodeindices from csv file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csv_filename</td><td>input csv file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;int&gt; with nodeindices. Ignores nodatavalues </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>14/02/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a2cf58c52d2770111f3e40a23328ed969"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::get_NRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of rows as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a9af27583a82895823233920d0d763e86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDFlowInfo::get_raster_values_for_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Raster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns all the values from a raster for a corresponding input vector of node indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">An</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> - must have same dimensions as the <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a> object </td></tr>
    <tr><td class="paramname">vector&lt;float&gt;</td><td>- the node indices for which you want the values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a064c9803a833a25def127c767c648222"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDFlowInfo::get_slope_between_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upslope_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>downslope_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Elevation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the slope between two nodes based on flow length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upslope_node</td><td>the upstream node </td></tr>
    <tr><td class="paramname">downslope_node</td><td>the downstream node </td></tr>
    <tr><td class="paramname">Elevation</td><td>elevation raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slope between the nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>04/05/18 </dd></dl>

</div>
</div>
<a class="anchor" id="a609f6ba59b5122df126b18fa7f957910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::get_sources_from_mapped_channel_heads </td>
          <td>(</td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a vector of source nodes based on the X and Y coordinates of mapped channel heads. Can be used if all the channel heads in a basin were mapped to get the stream network and calculate the drainage density. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X_coords</td><td>X coordinates of channel heads </td></tr>
    <tr><td class="paramname">Y_coords</td><td>Y coordinates of channel heads </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of source nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/02/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a047d37c69f9058164a80f7268bdc974a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::get_sources_index_threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowPixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A get sources version that uses the flow accumulation pixels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowPixels</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of flow accumulation in pixels. </td></tr>
    <tr><td class="paramname">threshold</td><td>Integer flow accumulation threshold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of source integers: these refer to the node indices of the sources. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a6342b2e3e65e15a4356e7fb130078c1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::get_sources_slope_area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>FlowPixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A get sources version that uses AS^2 (area and slope). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlowPixels</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of flow accumulation in pixels. </td></tr>
    <tr><td class="paramname">Slope</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of slope values </td></tr>
    <tr><td class="paramname">threshold</td><td>Integer AS^2 threshold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of source integers: these refer to the node indices of the sources. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>11/02/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a114056bfcda7a410b9ce51f569788d86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDFlowInfo::get_SVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the S vector, which is a sorted list of nodes (see Braun and Willett 2012) </dd></dl>

</div>
</div>
<a class="anchor" id="a2ec62a50b93c3fa21069461cc582adf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDFlowInfo::get_upslope_chi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the chi function for all the nodes upslope of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_node</td><td>Integer index of node to analyse upslope of. </td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">A_0</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of chi values. The node indices of these values are those that would be retured from get_uplope_nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/16/2012 </dd></dl>

</div>
</div>
<a class="anchor" id="a81f469457e6340a523394376ec1c5af5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDFlowInfo::get_upslope_chi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Discharge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the chi function for all the nodes upslope of a given node.  this version uses discharge rather than area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_node</td><td>Integer index of node to analyse upslope of. </td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">A_0</td><td>the referecen discharge </td></tr>
    <tr><td class="paramname">Discharge</td><td>a raster of the discharge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of chi values. The node indices of these values are those that would be retured from get_uplope_nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/10/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a4d03a0737d1e0d785f6e1fd6dc73615f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDFlowInfo::get_upslope_chi </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>upslope_pixel_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the chi function for a list of nodes it isn't really a standalone modules, but is only called from get_upslope_chi above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upslope_pixel_list</td><td>Vector of nodes to analyse. </td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">A_0</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of chi values. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/01/12 </dd></dl>

</div>
</div>
<a class="anchor" id="ae6b3c7734ba0d0fe9323197aa9756f1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; float &gt; LSDFlowInfo::get_upslope_chi </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>upslope_pixel_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Discharge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the chi function for a list of nodes it isn't really a standalone modules, but is only called from get_upslope_chi above  this version uses discharge rather than area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upslope_pixel_list</td><td>Vector of nodes to analyse. </td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">Discharge</td><td>and <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of the discharge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of chi values. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/10/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a81f73f0e3453d10a014ec589456607de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDFlowInfo::get_upslope_chi_from_all_baselevel_nodes </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>area_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the chi upslope of every base level node that is, it gets the chi values of the entire DEM, assuming all base level nodes have a chi of 0  because this assumes all base level nodes have a chi of 0, this function is probably only appropriate for numerical models. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m_over_n</td><td>the m/n ratio. Chi is quite sensitive to this </td></tr>
    <tr><td class="paramname">A_0</td><td>the reference drainage area. This is a but arbitrary. We usually use 1000 m^2. Willet et al(2014, Science) used 1m^2. As of 28 July 2014 we've not done any detailed sensitivity analysis on this parameter </td></tr>
    <tr><td class="paramname">area_threshold</td><td>the threshold area (in m^2) that sets the area above which chi is recorded in the chi raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this returns an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> for the chi values of the entire raster, with base level nodes assumed to have chi = 0 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>28/14/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="aeeadaaae6baa670269f308c97fe3d577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDFlowInfo::get_upslope_chi_from_all_baselevel_nodes </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Q_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>area_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Discharge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the chi upslope of every base level node that is, it gets the chi values of the entire DEM, assuming all base level nodes have a chi of 0  because this assumes all base level nodes have a chi of 0, this function is probably only appropriate for numerical models. This version of the function allows computation with a discharge raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m_over_n</td><td>the m/n ratio. Chi is quite sensitive to this </td></tr>
    <tr><td class="paramname">A_0</td><td>the reference discharge (same units as discharge. As of 28 July 2014 we've not done any detailed sensitivity analysis on this parameter </td></tr>
    <tr><td class="paramname">area_threshold</td><td>the threshold area (in m^2) that sets the area above which chi is recorded in the chi raster </td></tr>
    <tr><td class="paramname">Discharge</td><td>a raster of the discharge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this returns an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> for the chi values of the entire raster, with base level nodes assumed to have chi = 0 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/10/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a3f8baec90dbb9e5c6cfa43cf95909f65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDFlowInfo::get_upslope_chi_from_multiple_starting_nodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>area_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function takes a vector that contains the node indices of starting nodes, and then calculates chi upslope of these nodes to produce a chi map. A threshold drainage area can be used to only map chi where nodes have greater than the threshold drainage area </p>
<p>this function is meant to mimic the function of the Willett et al (2014) Science paper. You do need to extract the wanted node indices for your starting nodes from a node index map </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_nodes</td><td>an integer vector containing all the node indices of the node from which you want to start the chi analysis. All of these nodes will be considered to have a starting chi of 0 </td></tr>
    <tr><td class="paramname">m_over_n</td><td>the m/n ratio. Chi is quite sensitive to this </td></tr>
    <tr><td class="paramname">A_0</td><td>the reference drainage area. This is a but arbitrary. We usually use 1000 m^2. Willet et al(2014, Science) used 1m^2. As of 28 July 2014 we've not done any detailed sensitivity analysis on this parameter </td></tr>
    <tr><td class="paramname">area_threshold</td><td>the threshold area (in m^2) that sets the area above which chi is recorded in the chi raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this returns an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> for the chi values upslope of all of the nodes indicated in starting_nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>28/14/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ae3b466114b4b3e5bfba0aeb7d8fe4997"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDFlowInfo::get_upslope_chi_from_multiple_starting_nodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>area_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Discharge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function takes a vector that contains the node indices of starting nodes, and then calculates chi upslope of these nodes to produce a chi map. A threshold drainage area can be used to only map chi where nodes have greater than the threshold drainage area </p>
<p>this function is meant to mimic the function of the Willett et al (2014) Science paper. You do need to extract the wanted node indices for your starting nodes from a node index map This version allows computation with discharge </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_nodes</td><td>an integer vector containing all the node indices of the node from which you want to start the chi analysis. All of these nodes will be considered to have a starting chi of 0 </td></tr>
    <tr><td class="paramname">m_over_n</td><td>the m/n ratio. Chi is quite sensitive to this </td></tr>
    <tr><td class="paramname">A_0</td><td>the reference discharge. This is arbitrary. As of 28 July 2014 we've not done any detailed sensitivity analysis on this parameter </td></tr>
    <tr><td class="paramname">area_threshold</td><td>the threshold area (in m^2) that sets the area above which chi is recorded in the chi raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this returns an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> for the chi values upslope of all of the nodes indicated in starting_nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/10/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a069f0b2a7f9a6afe6d9a9333df3222f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; int, float &gt; LSDFlowInfo::get_upslope_chi_from_single_starting_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_pixels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This funtion gets all the upslope chi of a starting node (assuming chi at starting node is 0) and returns a map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_nodes</td><td>an integer containing the node index of the node from which you want to start the chi analysis. </td></tr>
    <tr><td class="paramname">m_over_n</td><td>the m/n ratio. Chi is quite sensitive to this </td></tr>
    <tr><td class="paramname">A_0</td><td>the reference discharge. </td></tr>
    <tr><td class="paramname">mimum_pixels</td><td>This minimum number of contributing pixels needed before chi is calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a map where the key is the node index and the value is chi </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/07/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a64f2ff3b2e4b8b53e5c14898a6bc6368"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; int, float &gt; LSDFlowInfo::get_upslope_chi_from_single_starting_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Discharge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This funtion gets all the upslope chi of a starting node (assuming chi at starting node is 0) and returns a map. </p>
<p>This version allows computation with discharge </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_nodes</td><td>an integer containing the node index of the node from which you want to start the chi analysis. </td></tr>
    <tr><td class="paramname">m_over_n</td><td>the m/n ratio. Chi is quite sensitive to this </td></tr>
    <tr><td class="paramname">A_0</td><td>the reference discharge. </td></tr>
    <tr><td class="paramname">mimum_pixels</td><td>This minimum number of contributing pixels needed before chi is calculated </td></tr>
    <tr><td class="paramname">Discharge</td><td>The discharge raster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a map where the key is the node index and the value is chi </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/07/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a4c2042aed7d976b065b27aae6367504c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; int, float &gt; LSDFlowInfo::get_upslope_chi_return_map </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>upslope_pixel_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_pixels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the chi function for a list of nodes it isn't really a standalone modules, but is only called from get_upslope_chi above. It returns a map, which is used to speed up computation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upslope_pixel_list</td><td>Vector of nodes to analyse. </td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">mimum_pixels</td><td>This minimum number of contributing pixels needed before chi is calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where the key is the node index and the value is chi </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/07/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a5a6b3288ff5844e73b687d20d49fa797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; int, float &gt; LSDFlowInfo::get_upslope_chi_return_map </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>upslope_pixel_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m_over_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>A_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum_pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Discharge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the chi function for a list of nodes it isn't really a standalone modules, but is only called from get_upslope_chi above. It returns a map, which is used to speed up computation  this version uses discharge rather than area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upslope_pixel_list</td><td>Vector of nodes to analyse. </td></tr>
    <tr><td class="paramname">m_over_n</td><td></td></tr>
    <tr><td class="paramname">A_0</td><td></td></tr>
    <tr><td class="paramname">mimum_pixels</td><td>This minimum number of contributing pixels needed before chi is calculated </td></tr>
    <tr><td class="paramname">Discharge</td><td>and <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of the discharge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where the key is the node index and the value is chi </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13/07/17 </dd></dl>

</div>
</div>
<a class="anchor" id="acc6d00123f3cf1516a11bab756349b56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDFlowInfo::get_upslope_node_mask </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>source_nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a list of sources and then creates a raster with nodata values where points are not upslope of the sources and 1.0 if they are upslope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_nodes</td><td>a vector of node indicies into the sources </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>11/11/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a362d53cadc85cee33b4b0759b7bf7481"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDFlowInfo::get_upslope_node_mask </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>source_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>node_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a list of sources and then creates a raster with nodata values where points are not upslope of the sources and node_values if they are upslope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_nodes</td><td>a vector of node indicies into the sources </td></tr>
    <tr><td class="paramname">node_values</td><td>a vector of the value of the nodes upslope of the sources this vector needs to be the same size as the source_nodes vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>12/11/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="ab66c3da828897cbcaf2c65e05e59ed0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::get_upslope_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_number_outlet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns an integer vector containing all the node indexes upslope of of the node with number node_number_outlet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_number_outlet</td><td>Integer of the target node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer vector of upslope node indexes. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a7aef49e633a7d74e8257c4a6567c05ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::get_UTM_information </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>UTM_zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>is_North</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function gets the UTM_zone and a boolean that is true if the map is in the northern hemisphere </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UTM_zone</td><td>the UTM zone. Replaced in function. </td></tr>
    <tr><td class="paramname">is_North</td><td>a boolean that is true if the DEM is in the northern hemisphere. replaced in function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a5dfd16c986996082a18f73b912f8eb1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::get_x_and_y_from_current_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>current_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>current_X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>current_Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the X and Y coordinates of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_node</td><td>Integer index of a given node. </td></tr>
    <tr><td class="paramname">current_X</td><td>Empty integer to be assigned the X coordinate of the given node. </td></tr>
    <tr><td class="paramname">current_Y</td><td>Empty integer to be assigned the Y coordinate of the given node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>BG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/02/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="aeb461de3f6735852a771fd386e14ef15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::get_x_and_y_locations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y_loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this gets the x and y location of a node at row and column </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the node </td></tr>
    <tr><td class="paramname">col</td><td>the column of the node </td></tr>
    <tr><td class="paramname">x_loc</td><td>the x location (Northing) of the node </td></tr>
    <tr><td class="paramname">y_loc</td><td>the y location (Easting) of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="afc5586d098c8e976b5e743a1a9b65fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::get_x_and_y_locations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>x_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>y_loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this gets the x and y location of a node at row and column </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the node </td></tr>
    <tr><td class="paramname">col</td><td>the column of the node </td></tr>
    <tr><td class="paramname">x_loc</td><td>the x location (Northing) of the node </td></tr>
    <tr><td class="paramname">y_loc</td><td>the y location (Easting) of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/12/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a1b5473119e763ddc3be2f09b0068fbc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDFlowInfo::get_XMinimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Minimum X coordinate as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a36063e3c4aefcd270645ff65a98874cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDFlowInfo::get_YMinimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Minimum Y coordinate as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e92e1b91d98d971a404810e47d676a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; Array2D&lt; float &gt; &gt; LSDFlowInfo::HilltopFlowRouting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Hilltop_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>HilltopCurv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>PlanCurvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>StreamNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>Basins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>Prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_paths_switch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thinning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>trace_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>basin_filter_switch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>Target_Basin_Vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hilltop flow routing. </p>
<p>Hilltop flow routing code built around original code from Martin Hurst. Based on Lea (1992), with improvements discussed by Tarboton (1997) and a solution to the problem of looping flow paths implemented.</p>
<p>This code is SLOW but robust, a refactored version may appear, but there may not be enough whisky in Scotland to support that endeavour.</p>
<p>The algorithm now checks for local uphill flows and in the case of identifying one, D8 flow path is used to push the flow into the centre of the steepest downslope cell, at which point the trace is restarted. The same technique is used to cope with self intersections of the flow path. These problems are not solved in the original paper and I think they are caused at least in part by the high resolution topogrpahy we are using.</p>
<p>The code is also now built to take a d infinity flow direction raster instead of an aspect raster. See Tarboton (1997) for discussions on why this is the best solution.</p>
<p>The Basins input raster is used to code each hilltop into a basin to allow basin averaging to take place.</p>
<p>The final 5 parameters are used to set up printing flow paths to files for visualisation, if this is not needed simply pass in false to the two boolean switches and empty variables for the others, and the code will run as normal.</p>
<p>The structure of the returned vector&lt; Array2D&lt;float&gt; &gt; is as follows: <br/>
<br/>
[0] Hilltop Network coded with stream ID <br/>
[1] Hillslope Lengths <br/>
[2] Slope <br/>
[3] Relief <br/>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Elevation</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of elevation values. </td></tr>
    <tr><td class="paramname">Slope</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of slope values. </td></tr>
    <tr><td class="paramname">Hilltops</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of hilltops. </td></tr>
    <tr><td class="paramname">StreamNetwork</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the stream network. </td></tr>
    <tr><td class="paramname">Aspect</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of Aspect. </td></tr>
    <tr><td class="paramname">Prefix</td><td>String Prefix for output data filename. </td></tr>
    <tr><td class="paramname">Basins</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of basin outlines. </td></tr>
    <tr><td class="paramname">PlanCurvature</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of planform curvature. </td></tr>
    <tr><td class="paramname">print_paths_switch</td><td>If true paths will be printed. </td></tr>
    <tr><td class="paramname">thinning</td><td>Thinning factor, value used to skip hilltops being printed, use 1 to print every hilltop. </td></tr>
    <tr><td class="paramname">trace_path</td><td>The file path to be used to write the path files to, must end with a slash. </td></tr>
    <tr><td class="paramname">basin_filter_switch</td><td>If this switch is true only basins in Target_Basin_Vector will have their paths printed. </td></tr>
    <tr><td class="paramname">Target_Basin_Vector</td><td>Vector of Basin IDs that the user wants to print traces for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of Array2D&lt;float&gt; containing hillslope metrics. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>12/2/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a710c0f061cded13e2f213d357ea8f3d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; Array2D&lt; float &gt; &gt; LSDFlowInfo::HilltopFlowRouting_Profile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Hilltops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>StreamNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>D_inf_Flowdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>Prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>Basins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_paths_switch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thinning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>trace_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>basin_filter_switch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>Target_Basin_Vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hilltop flow routing which generates elevation profiles. </p>
<p>Hilltop flow routing code built around original code from Martin Hurst. Based on Lea (1992), with improvements discussed by Tarboton (1997) and a solution to the problem of looping flow paths implemented.</p>
<p>THIS VERSION OF THE CODE RETAINS THE FLOODING METHOD TO ALLOW TRACES TO BE USED ON RAW TOPOGRPAHY TO GET EVENT SCALE HILLSLOPE LENGTHS WITH NO SMOOTHING. IN MOST CASES USE THE MAIN METHOD, TO ANALYSE SEDIMENT TRANSPORT OVER GEOMORPHIC TIME.</p>
<p>This code is SLOW but robust, a refactored version may appear, but there may not be enough whisky in Scotland to support that endeavour.</p>
<p>The algorithm now checks for local uphill flows and in the case of identifying one, D8 flow path is used to push the flow into the centre of the steepest downslope cell, at which point the trace is restarted. The same technique is used to cope with self intersections of the flow path. These problems are not solved in the original paper and I think they are caused at least in part by the high resolution topogrpahy we are using.</p>
<p>The code is also now built to take a d infinity flow direction raster instead of an aspect raster. See Tarboton (1997) for discussions on why this is the best solution.</p>
<p>The Basins input raster is used to code each hilltop into a basin to allow basin averaging to take place.</p>
<p>The final 5 parameters are used to set up printing flow paths to files for visualisation, if this is not needed simply pass in false to the two boolean switches and empty variables for the others, and the code will run as normal.</p>
<p>The structure of the returned vector&lt; Array2D&lt;float&gt; &gt; is as follows: <br/>
<br/>
[0] Hilltop Network coded with stream ID <br/>
[1] Hillslope Lengths <br/>
[2] Slope <br/>
[3] Relief <br/>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Elevation</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of elevation values. </td></tr>
    <tr><td class="paramname">Slope</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of slope values. </td></tr>
    <tr><td class="paramname">Hilltops</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of hilltops. </td></tr>
    <tr><td class="paramname">StreamNetwork</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the stream network. </td></tr>
    <tr><td class="paramname">D_inf_Flowdir</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of flow directions. </td></tr>
    <tr><td class="paramname">Prefix</td><td>String Prefix for output data filename. </td></tr>
    <tr><td class="paramname">Basins</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of basin outlines. </td></tr>
    <tr><td class="paramname">print_paths_switch</td><td>If true paths will be printed. </td></tr>
    <tr><td class="paramname">thinning</td><td>Thinning factor, value used to skip hilltops being printed, use 1 to print every hilltop. </td></tr>
    <tr><td class="paramname">trace_path</td><td>The file path to be used to write the path files to, must end with a slash. </td></tr>
    <tr><td class="paramname">basin_filter_switch</td><td>If this switch is true only basins in Target_Basin_Vector will have their paths printed. </td></tr>
    <tr><td class="paramname">Target_Basin_Vector</td><td>Vector of Basin IDs that the user wants to print traces for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of Array2D&lt;float&gt; containing hillslope metrics. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25/03/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a14222a4a6c9758138bf15ac810728dd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; Array2D&lt; float &gt; &gt; LSDFlowInfo::HilltopFlowRouting_RAW </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Hilltops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>Slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>StreamNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>D_inf_Flowdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>Prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>Basins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>PlanCurvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_paths_switch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thinning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>trace_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>basin_filter_switch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>Target_Basin_Vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hilltop flow routing which runs on unsmoothed topography. </p>
<p>Hilltop flow routing code built around original code from Martin Hurst. Based on Lea (1992), with improvements discussed by Tarboton (1997) and a solution to the problem of looping flow paths implemented.</p>
<p>THIS VERSION OF THE CODE RETAINS THE FLOODING METHOD TO ALLOW TRACES TO BE USED ON RAW TOPOGRPAHY TO GET EVENT SCALE HILLSLOPE LENGTHS WITH NO SMOOTHING. IN MOST CASES USE THE MAIN METHOD, TO ANALYSE SEDIMENT TRANSPORT OVER GEOMORPHIC TIME.</p>
<p>This code is SLOW but robust, a refactored version may appear, but there may not be enough whisky in Scotland to support that endeavour.</p>
<p>The algorithm now checks for local uphill flows and in the case of identifying one, D8 flow path is used to push the flow into the centre of the steepest downslope cell, at which point the trace is restarted. The same technique is used to cope with self intersections of the flow path. These problems are not solved in the original paper and I think they are caused at least in part by the high resolution topogrpahy we are using.</p>
<p>The code is also now built to take a d infinity flow direction raster instead of an aspect raster. See Tarboton (1997) for discussions on why this is the best solution.</p>
<p>The Basins input raster is used to code each hilltop into a basin to allow basin averaging to take place.</p>
<p>The final 5 parameters are used to set up printing flow paths to files for visualisation, if this is not needed simply pass in false to the two boolean switches and empty variables for the others, and the code will run as normal.</p>
<p>The structure of the returned vector&lt; Array2D&lt;float&gt; &gt; is as follows: <br/>
<br/>
[0] Hilltop Network coded with stream ID <br/>
[1] Hillslope Lengths <br/>
[2] Slope <br/>
[3] Relief <br/>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Elevation</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of elevation values. </td></tr>
    <tr><td class="paramname">Slope</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of slope values. </td></tr>
    <tr><td class="paramname">Hilltops</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of hilltops. </td></tr>
    <tr><td class="paramname">StreamNetwork</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the stream network. </td></tr>
    <tr><td class="paramname">D_inf_Flowdir</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of flow directions. </td></tr>
    <tr><td class="paramname">Prefix</td><td>String Prefix for output data filename. </td></tr>
    <tr><td class="paramname">Basins</td><td><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of basin outlines. </td></tr>
    <tr><td class="paramname">PlanCurvature</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of planform curvature. </td></tr>
    <tr><td class="paramname">print_paths_switch</td><td>If true paths will be printed. </td></tr>
    <tr><td class="paramname">thinning</td><td>Thinning factor, value used to skip hilltops being printed, use 1 to print every hilltop. </td></tr>
    <tr><td class="paramname">trace_path</td><td>The file path to be used to write the path files to, must end with a slash. </td></tr>
    <tr><td class="paramname">basin_filter_switch</td><td>If this switch is true only basins in Target_Basin_Vector will have their paths printed. </td></tr>
    <tr><td class="paramname">Target_Basin_Vector</td><td>Vector of Basin IDs that the user wants to print traces for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of Array2D&lt;float&gt; containing hillslope metrics. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>12/2/14 </dd></dl>

</div>
</div>
<a class="anchor" id="a01b8a4fe4f6f12b5ccbd367469536553"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::Ingest_Channel_Heads </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input_switch</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to ingest the channel heads raster generated using channel_heads_driver.cpp into a vector of source nodes so that an <a class="el" href="class_l_s_d_junction_network.html" title="Object to create a channel network from an LSDFlowInfo object. ">LSDJunctionNetwork</a> can be created easily from them. <b>UPDATE</b> if the extension is a csv file it reads the node indices directly <b>UPDATE, FJC 20/01/16 - changed default input switch to 2</b> </p>
<p>Assumes the FlowInfo object has the same dimensions as the channel heads raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>of the channel heads raster. </td></tr>
    <tr><td class="paramname">extension</td><td>of the channel heads raster. </td></tr>
    <tr><td class="paramname">(optional)</td><td>input_switch, ONLY NEEDED FOR LOADING .csv FILES! An integer to determine whether to use the node index (0 -&gt; default), row and column indices (1), or point coordinates from .csv file (2) to locate the channel heads </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of source nodes. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG updated SMM updated DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>6/6/14 Happy 3rd birthday Skye!! </dd></dl>

</div>
</div>
<a class="anchor" id="a2afdec6603e149c915375499e39aad1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::Ingest_Channel_Heads </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input_switch</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to ingest the channel heads raster generated using channel_heads_driver.cpp into a vector of source nodes so that an <a class="el" href="class_l_s_d_junction_network.html" title="Object to create a channel network from an LSDFlowInfo object. ">LSDJunctionNetwork</a> can be created easily from them. <b>UPDATE</b> if the extension is a csv file it reads the node indices directly <b>UPDATE, FJC 20/01/16 - changed default input switch to 2</b> ***********UPDATE - overloaded function to read in the column headers using the csv logic rather than assume that the columns have to be in a specific order. ONLY WORKS WITH CSV EXTENSIONS. FJC 23/03/17*************************. </p>
<p>Assumes the FlowInfo object has the same dimensions as the channel heads raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>of the channel heads raster. </td></tr>
    <tr><td class="paramname">extension</td><td>of the channel heads raster. </td></tr>
    <tr><td class="paramname">(optional)</td><td>input_switch, ONLY NEEDED FOR LOADING .csv FILES! An integer to determine whether to use the node index (0 -&gt; default), row and column indices (1), or point coordinates from .csv file (2) to locate the channel heads </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of source nodes. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG updated SMM updated DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>6/6/14 Happy 3rd birthday Skye!! </dd></dl>

</div>
</div>
<a class="anchor" id="a6c82a534553ee1e63342b36493a6d61f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::Ingest_Channel_Heads_OS </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>csv_filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to ingest sources from OS MasterMap Water Network Layer (csv) into a vector of source nodes so that an <a class="el" href="class_l_s_d_junction_network.html" title="Object to create a channel network from an LSDFlowInfo object. ">LSDJunctionNetwork</a> can be easily created from them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csv_filename</td><td>CSV file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of source nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>28/11/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a2a90480af6e0f8d8efdeb068dcb61c7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::is_node_base_level </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether a node is a base level node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int which is 1 if node is base level, 0 if not </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>26/08/15 </dd></dl>

</div>
</div>
<a class="anchor" id="acf9e0af9de771adad45f0492dd14ce61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::is_node_upstream </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>current_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>test_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether one node is upstream of another node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_node</td><td></td></tr>
    <tr><td class="paramname">test_node</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean indicating whether node is upstream or not </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>08/10/13 </dd></dl>

</div>
</div>
<a class="anchor" id="a6150fa7629c6807e22a977f0993e65b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LSDFlowInfo::is_upstream_influenced_by_nodata </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>test_raster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function looks at all uplope nodes and sees if any are bordered by nodata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeindex</td><td>The node index of the node in question </td></tr>
    <tr><td class="paramname">test_raster</td><td>and <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> that is to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node is influenced by nodata </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/05/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="ac68f441180adede8c274d26b47a4623b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, vector&lt; string &gt; &gt; LSDFlowInfo::load_csv_data </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This loads a csv file, putting the data into a data map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the csv file including path and extension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM (ported into FlowInfo FJC 23/03/17) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>16/02/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a6f31d6e8f6f7bb27f0374cd6363b164b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::MoveChannelHeadDown </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>Sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>MoveDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>DownslopeSources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>FinalHeads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the location of the channel head downslope by a user defined distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Sources</td><td>a vector of node indexes of the channel heads to be moved. </td></tr>
    <tr><td class="paramname">MoveDist</td><td>The distance in spatial units the head is to be moved. </td></tr>
    <tr><td class="paramname">DownslopeSources</td><td>A vector used to contain the node indexes of the moved channel heads. </td></tr>
    <tr><td class="paramname">FinalHeads</td><td>A vector containing a subset of the original channel heads which corresponds to the moved heads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/11/15 </dd></dl>

</div>
</div>
<a class="anchor" id="ad2ede99c078aa517d85d51edd3645958"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::MoveChannelHeadUp </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>Sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>MoveDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td>
          <td class="paramname"><em>DEM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>UpslopeSources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>FinalHeads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the location of the channel head upslope by a user defined distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Sources</td><td>a vector of node indexes of the channel heads to be moved. </td></tr>
    <tr><td class="paramname">MoveDist</td><td>The distance in spatial units the head is to be moved. </td></tr>
    <tr><td class="paramname">DEM</td><td>the elevation data. </td></tr>
    <tr><td class="paramname">UpslopeSources</td><td>A vector used to contain the node indexes of the moved channel heads. </td></tr>
    <tr><td class="paramname">FinalHeads</td><td>A vector containing a subset of the original channel heads which corresponds to the moved heads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>27/11/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a1f89d3dc520d1a032719e13b713e15de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::pickle </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pickles flow information data from a binary file. </p>
<p>WARNING!!! This creates HUGE files (sometimes 10x bigger than original file). Testing indicates reading this file takes almost as long as recalculating the flowinfo object so is probably not worth doing </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>String of the binary file to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="ae2f2ee60233cfa2bb585a702a6da27c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::print_flow_info_vectors </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the flow information to file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>String of the output file to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a3ce3c7b126c3dac582ebb1e1beee3397"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::print_vector_of_nodeindices_to_csv_file </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeindex_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>outfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a vector of node indices and prints a csv file that can be read by arcmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeindex</td><td>vec is a vector of nodeindices (which are ints) </td></tr>
    <tr><td class="paramname">outfilename</td><td>is a string of the filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>03/06/14 </dd></dl>

</div>
</div>
<a class="anchor" id="ab17ed5d38d330441e41466c9702b4ae2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::print_vector_of_nodeindices_to_csv_file_Unique </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeindex_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>outfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a vector of node indices and prints a csv file that can be read by arcmap, adding in a unique id to each row, independent of the nodeindex. </p>
<p>The unique ID is used to tie triplets of channel heads together for hollow analysis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeindex</td><td>vec is a vector of nodeindices (which are ints) </td></tr>
    <tr><td class="paramname">outfilename</td><td>is a string of the filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG after SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2/2/16 </dd></dl>

</div>
</div>
<a class="anchor" id="a643c1a70fa907faeace7036da258ab67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::print_vector_of_nodeindices_to_csv_file_with_latlong </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeindex_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>outfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a vector of node indices and prints a csv file that can be read by arcmap: similar to above but also prints lat and long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeindex</td><td>vec is a vector of nodeindices (which are ints) </td></tr>
    <tr><td class="paramname">outfilename</td><td>is a string of the filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/05/16 </dd></dl>

</div>
</div>
<a class="anchor" id="ac68718a298107588c9c07704689595e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::ProcessEndPointsToChannelHeads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>Ends</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method removes end nodes which are not the uppermost extent of the channel network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ends</td><td>an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the end points to be processed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of source nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23/7/15 </dd></dl>

</div>
</div>
<a class="anchor" id="a08ed80044f10375040231117dced9cc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::RemoveSinglePxChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td>
          <td class="paramname"><em>StreamNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>Sources</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method removes single pixel channels from a channel network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StreamNetwork</td><td>an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of the channel network generated from Sources. </td></tr>
    <tr><td class="paramname">Sources</td><td>a vetcor of integer node indices which need cleaned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of source nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23/7/15 </dd></dl>

</div>
</div>
<a class="anchor" id="ac05f910c1f72f83a250f3fd4a1a781a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::retrieve_base_level_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets the base level node for any given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the starting node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base level node </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/12/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="acdd9e9a21df1d7208eac74f06d533b2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::retrieve_contributing_pixels_of_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of pixels flowing into a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Integer of node index value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer of the number of contributing pixels. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a884cde464cdf104cf3e07599e9b65c07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::retrieve_current_row_and_col </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>current_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>curr_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>curr_col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the row and column indices of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_node</td><td>Integer index of a given node. </td></tr>
    <tr><td class="paramname">curr_row</td><td>Empty integer to be assigned the row index of the given node. </td></tr>
    <tr><td class="paramname">curr_col</td><td>Empty integer to be assigned the column index of the given node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="ab8edd8c062c1072cc945ca47c6dfed02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::retrieve_donors_to_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>current_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets a vector of all the donors to a given node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_node</td><td>the node index from which to get n donors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing all the donors to this node </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19/9/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a22c42ddee889181abed5b38d988e24a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::retrieve_flow_length_code_of_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the FlowLengthCode of a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Integer of node index value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer of the FlowLengthCode. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="ac20d9bdf9de01bdb642b7990b1d66480"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::retrieve_largest_base_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the base level node with the greatest drainage area. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer node index. </dd></dl>

</div>
</div>
<a class="anchor" id="a149ba017a2fab24c073377c571ebf791"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::retrieve_ndonors_to_node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>current_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the number of donors to a given node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_node</td><td>the node index from which to get n donors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of donors to this cell </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19/9/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a9a3d603727e9cee20d6a24d65bbc611e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::retrieve_node_from_row_and_column </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the node for a cell at a given row and column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>index </td></tr>
    <tr><td class="paramname">column</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node index </dd></dl>
<dl class="section author"><dt>Author</dt><dd>DTM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>08/11/2013 </dd></dl>

</div>
</div>
<a class="anchor" id="ac40b12a6ea3966fb36a7979a2330c1aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::retrieve_receiver_information </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>current_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>reveiver_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>receiver_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>receiver_col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the reciever information for a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_node</td><td>Integer </td></tr>
    <tr><td class="paramname">reveiver_node</td><td>Empty integer to be assigned the index of the reciever node. </td></tr>
    <tr><td class="paramname">receiver_row</td><td>Empty integer to be assigned the row index of the reciever node. </td></tr>
    <tr><td class="paramname">receiver_col</td><td>Empty integer to be assigned the column index of the reciever node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a9f889dd60be2c63aa6c1638edd8146cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::retrieve_receiver_information </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>current_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>reveiver_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the reciever information for a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_node</td><td>Integer </td></tr>
    <tr><td class="paramname">reveiver_node</td><td>Empty integer to be assigned the index of the reciever node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>BG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>06/01/2018 </dd></dl>

</div>
</div>
<a class="anchor" id="af4599121dbcf3d3514b0225bbceb17d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDFlowInfo::snap_RasterData_to_Node </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>InputRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to return the closest value of a raster to a specified node index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NodeIndex</td><td>of interest </td></tr>
    <tr><td class="paramname">InputRaster</td><td>raster to return value of </td></tr>
    <tr><td class="paramname">search_radius</td><td>rectangular window to search for, in n_pixels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float value of raster closest to the node index </dd></dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>08/02/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a45758abb46e5fb335c0b624bc855a53a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LSDFlowInfo::snap_to_hilltop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Hilltops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to snap a point, given as raster coordinates, to a cell in a raster of hilltops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Integer row index. </td></tr>
    <tr><td class="paramname">b</td><td>Integer row index. </td></tr>
    <tr><td class="paramname">search_radius</td><td>The radius of the search window in pixels. </td></tr>
    <tr><td class="paramname">Hilltops</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of the hilltops to be snapped to. @ return The nodeindex of the snapped point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23/1/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a32771fc62765c87b1e0de12ba2589d9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::snap_to_hilltops </td>
          <td>(</td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>x_locs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>y_locs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>search_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Hilltops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>SnappedNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Valid_node_IDs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around snap_to_hilltop function to process a collection of utm points. </p>
<p>Writes the the nodeindex of each snapped point to SnappedNodes and the coordinate count (first coordinate pair is 0, second is 1 and so on) is written to Valid_node_IDs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_locs</td><td>UTM x coordinates. </td></tr>
    <tr><td class="paramname">y_locs</td><td>UTM y coordinates. </td></tr>
    <tr><td class="paramname">search_radius</td><td>The radius of the search window in pixels. </td></tr>
    <tr><td class="paramname">Hilltops</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> of the hilltops to be snapped to. </td></tr>
    <tr><td class="paramname">SnappedNodes</td><td>Empty vector where the snapped nodeindexes are written. </td></tr>
    <tr><td class="paramname">Valid_node_IDs</td><td>Empty vector where the coordinate count is written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SWDG </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23/1/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a6e172357f7b6b0fb9ecf16124097ffb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::sort_node_list_based_on_raster </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>node_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>SortingRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes a list of nodes and sorts them according to a sorting raster (it could be anything) fin ascending order nodes are then reordered to reflect the sorting of the raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_vec</td><td>A vector of nodes </td></tr>
    <tr><td class="paramname">SortingRaster</td><td>a raster that contains some values that will be used to sort the nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sorted_nodes a vector containing the sorted nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/05/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="ac3e6526a07ab30e3e65d5ceb4653ca81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; LSDFlowInfo::sort_node_list_based_on_raster </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>node_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>SortingRaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes a list of nodes and sorts them according to a sorting raster (it could be anything) fin ascending order nodes are then reordered to reflect the sorting of the raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_vec</td><td>A vector of nodes </td></tr>
    <tr><td class="paramname">SortingRaster</td><td>a raster that contains some values that will be used to sort the nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sorted_nodes a vector containing the sorted nodes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/05/2016 </dd></dl>

</div>
</div>
<a class="anchor" id="a97c992c1866e409f496d7b26b3c39177"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDFlowInfo::unpickle </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpickles flow information data from a binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>String of the binary file to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="af8e5bfcc36a8ade88c7a8d75b1420c14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDFlowInfo::upslope_variable_accumulator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>accum_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function accumulates some variable from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> The most probably use is to accumulate precipitation in order to get a discharge raster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>raster that contains the variable to be accumulated (e.g., precipitation) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raster containing the accumulated variable: NOTE the accumulation does not include the node itself </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>09/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ae98aa863276380f5db58005d40567e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDFlowInfo::write_DrainageArea_to_LSDRaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Fiona Clubb </dd></dl>
<dl class="section date"><dt>Date</dt><dd>15/11/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a49b8861234730afcb147ce6a3f151694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDFlowInfo::write_FlowDirection_to_LSDIndexRaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write FlowDirection to an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of flow directions. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="aba659a392678c0eef0d15003bac101f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDFlowInfo::write_FlowDirection_to_LSDIndexRaster_Arcformat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes flow directions to an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>. Flow direction in arcmap format is: <br/>
<br/>
 32 64 128 <br/>
 16 0 1 <br/>
 8 4 2 <br/>
. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of flow directions in arcgis format. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a705e1cf7741aeee7174accbc8521c8c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDFlowInfo::write_FlowLengthCode_to_LSDIndexRaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write FlowLengthCode to an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of flow lengths. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a830bffe6b748db4f141a650e4b068e80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDFlowInfo::write_NContributingNodes_to_LSDIndexRaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write NContributingNodes to an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of number of contributing nodes for each cell. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="ad8387d52c91360001a8f8ec91a734133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDFlowInfo::write_NodeIndex_to_LSDIndexRaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write NodeIndex to an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of node index data. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="aa4105e2de5868f3ff8586366df15137c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDFlowInfo::write_NodeIndexVector_to_LSDIndexRaster </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeindexvec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes and <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> containing the location of nodes in the nodeindexvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeindexvec</td><td>a vector containing node indices one use is to export the <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of pixels that are in the node index vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of pixels that are in the node index vector. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/016/12 </dd></dl>

</div>
</div>
<a class="anchor" id="a5208624568ee6286a6d5c491b07b194c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> LSDFlowInfo::write_NodeIndexVector_to_LSDIndexRaster_Unique </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeindexvec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes an LSDIndesxRaster given a list of node indices, and give every pixel its nodeindex value, which is unique. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeindexvec</td><td>a vector containing node indices one use is to export the <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of pixels that are in the node index vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> of pixels that are in the node index vector. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SWDG after SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2/2/16 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7b6d2a809055715812f57dc311363517"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;string&gt; LSDFlowInfo::BoundaryConditions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boundary conditions stored in a vector of four strings. The conditions are North[0] East[1] South[2] West[3]. </p>
<p>There are 3 kinds of edge boundaries: no flux, base level and periodic.</p>
<p>The strings can be any length, as long as the first letter corresponds to the first letter of the boundary condition. It is not case sensitive. </p>

</div>
</div>
<a class="anchor" id="abfae2eed1e1b0fd4357bc8eab15d9f6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; LSDFlowInfo::DonorStackVector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a vector that stores the donor nodes of of the nodes and is indexed by the DeltaVector. </p>

</div>
</div>
<a class="anchor" id="a4c6cabf14e70d61b378df8574c807ac9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt;int&gt; LSDFlowInfo::FlowDirection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A raster of flow direction information. </p>
<p>In the format:</p>
<p>7 0 1 <br/>
6 -1 2 <br/>
5 4 3 <br/>
 Nodes with flow direction of -1 drain to themselvs and are base level/sink nodes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_l_s_d_flow_info_8hpp_source.html">LSDFlowInfo.hpp</a></li>
<li>src/LSDFlowInfo.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
