<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LSDTopoTools2: LSDRasterModel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LSDTopoTools2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_l_s_d_raster_model-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LSDRasterModel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Create model objects to use <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> methods on synthetic landscapes.  
 <a href="class_l_s_d_raster_model.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_l_s_d_raster_model_8hpp_source.html">LSDRasterModel.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LSDRasterModel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_l_s_d_raster_model.png" usemap="#LSDRasterModel_map" alt=""/>
  <map id="LSDRasterModel_map" name="LSDRasterModel_map">
<area href="class_l_s_d_raster_spectral.html" title="This object performs spectral analysis. " alt="LSDRasterSpectral" shape="rect" coords="0,56,119,80"/>
<area href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. " alt="LSDRaster" shape="rect" coords="0,0,119,24"/>
<area href="class_l_s_d_model_driver.html" title="This is a class to manage running LSDTopoTools. It parses a parameter file and then manages running o..." alt="LSDModelDriver" shape="rect" coords="0,168,119,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1de3c183b5f2f8f96d8a62b2c8109932"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a1de3c183b5f2f8f96d8a62b2c8109932">LSDRasterModel</a> ()</td></tr>
<tr class="memdesc:a1de3c183b5f2f8f96d8a62b2c8109932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Create a deafult <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> (100x100)  <a href="#a1de3c183b5f2f8f96d8a62b2c8109932">More...</a><br/></td></tr>
<tr class="separator:a1de3c183b5f2f8f96d8a62b2c8109932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433a0754ab4048d2a88c55ec8d389ce2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a433a0754ab4048d2a88c55ec8d389ce2">LSDRasterModel</a> (string master_param)</td></tr>
<tr class="memdesc:a433a0754ab4048d2a88c55ec8d389ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Create a <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> from a parameter file.  <a href="#a433a0754ab4048d2a88c55ec8d389ce2">More...</a><br/></td></tr>
<tr class="separator:a433a0754ab4048d2a88c55ec8d389ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801fb83a5f478d8432929a1f44b1a919"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a801fb83a5f478d8432929a1f44b1a919">LSDRasterModel</a> (string filename, string extension)</td></tr>
<tr class="memdesc:a801fb83a5f478d8432929a1f44b1a919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Create an <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> from a file. Uses a filename and file extension.  <a href="#a801fb83a5f478d8432929a1f44b1a919">More...</a><br/></td></tr>
<tr class="separator:a801fb83a5f478d8432929a1f44b1a919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa26f19c8094cfced7b2cc943310d270"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aaa26f19c8094cfced7b2cc943310d270">LSDRasterModel</a> (int nrows, int ncols, float xmin, float ymin, float cellsize, float ndv, Array2D&lt; float &gt; data)</td></tr>
<tr class="memdesc:aaa26f19c8094cfced7b2cc943310d270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Create an <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> from memory.  <a href="#aaa26f19c8094cfced7b2cc943310d270">More...</a><br/></td></tr>
<tr class="separator:aaa26f19c8094cfced7b2cc943310d270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59955d7470346fc100360687221387a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a59955d7470346fc100360687221387a1">LSDRasterModel</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;An_LSDRaster)</td></tr>
<tr class="memdesc:a59955d7470346fc100360687221387a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Create an <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>.  <a href="#a59955d7470346fc100360687221387a1">More...</a><br/></td></tr>
<tr class="separator:a59955d7470346fc100360687221387a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d7382c826d36af69e17fb0fba7e306"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a13d7382c826d36af69e17fb0fba7e306">LSDRasterModel</a> (int <a class="el" href="class_l_s_d_raster.html#ac88ec4e856cb32a69f58b7da5bfc24c0">NRows</a>, int <a class="el" href="class_l_s_d_raster.html#a5835c070514b4bfc39b730e117a3abb7">NCols</a>)</td></tr>
<tr class="memdesc:a13d7382c826d36af69e17fb0fba7e306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Create a blank raster nodel.  <a href="#a13d7382c826d36af69e17fb0fba7e306">More...</a><br/></td></tr>
<tr class="separator:a13d7382c826d36af69e17fb0fba7e306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cffce1da8e8396f0cd620634773f1cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cffce1da8e8396f0cd620634773f1cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a3cffce1da8e8396f0cd620634773f1cd">~LSDRasterModel</a> (void)</td></tr>
<tr class="memdesc:a3cffce1da8e8396f0cd620634773f1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destructor. <br/></td></tr>
<tr class="separator:a3cffce1da8e8396f0cd620634773f1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06bc9a50c5a1cf2265f933435221173"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae06bc9a50c5a1cf2265f933435221173"></a>
<a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae06bc9a50c5a1cf2265f933435221173">operator=</a> (const <a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a> &amp;LSDR)</td></tr>
<tr class="memdesc:ae06bc9a50c5a1cf2265f933435221173"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator assignment <br/></td></tr>
<tr class="separator:ae06bc9a50c5a1cf2265f933435221173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e951371b5111ef5bb175371bd9f9a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a59e951371b5111ef5bb175371bd9f9a1">return_as_raster</a> ()</td></tr>
<tr class="memdesc:a59e951371b5111ef5bb175371bd9f9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This just returns the raster model object data as a raster.  <a href="#a59e951371b5111ef5bb175371bd9f9a1">More...</a><br/></td></tr>
<tr class="separator:a59e951371b5111ef5bb175371bd9f9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fde41177c389a908bb2c3359f48bc67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fde41177c389a908bb2c3359f48bc67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a0fde41177c389a908bb2c3359f48bc67">initialize_model</a> (string &amp;parameter_file, string &amp;run_name, float &amp;dt, float &amp;EndTime, float &amp;PrintInterval, float &amp;k_w, float &amp;b, float &amp;<a class="el" href="class_l_s_d_raster_model.html#ab3cae56faea604d33f3404c96551d415">m</a>, float &amp;<a class="el" href="class_l_s_d_raster_model.html#a6fa1e522fb52b5e39e556321e5862134">n</a>, float &amp;K, float &amp;ErosionThreshold, float &amp;K_nl, float &amp;<a class="el" href="class_l_s_d_raster_model.html#ab70f615261aa7a7907be28009858e1c4">S_c</a>, float &amp;UpliftRate, float &amp;PrecipitationRate, float &amp;NorthBoundaryElevation, float &amp;SouthBoundaryElevation, Array2D&lt; float &gt; &amp;PrecipitationFlux, Array2D&lt; float &gt; &amp;SlopesBetweenRows, Array2D&lt; float &gt; &amp;SlopesBetweenColumns, Array2D&lt; float &gt; &amp;ErosionRate)</td></tr>
<tr class="memdesc:a0fde41177c389a908bb2c3359f48bc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">this initialises the model by directly #ting the data members <br/></td></tr>
<tr class="separator:a0fde41177c389a908bb2c3359f48bc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4494efe08b81f45eb0abc2284f1ddb13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a4494efe08b81f45eb0abc2284f1ddb13">initialize_model</a> (string parameter_file)</td></tr>
<tr class="memdesc:a4494efe08b81f45eb0abc2284f1ddb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module initialises the model runs, calling the required function from the initial topography and loads the parameters from the parameter file.  <a href="#a4494efe08b81f45eb0abc2284f1ddb13">More...</a><br/></td></tr>
<tr class="separator:a4494efe08b81f45eb0abc2284f1ddb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b1bd91533cb93bd103ee761e9147cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a24b1bd91533cb93bd103ee761e9147cc">initialise_model</a> ()</td></tr>
<tr class="memdesc:a24b1bd91533cb93bd103ee761e9147cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module initialises the model using the maps that have been read in from the parameter file via the param file parser function.  <a href="#a24b1bd91533cb93bd103ee761e9147cc">More...</a><br/></td></tr>
<tr class="separator:a24b1bd91533cb93bd103ee761e9147cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af015d79ae4fd62a026ff3e2ed32d9bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#af015d79ae4fd62a026ff3e2ed32d9bce">append_run_name</a> (string append_name)</td></tr>
<tr class="memdesc:af015d79ae4fd62a026ff3e2ed32d9bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">this appends a string to the run name  can be used to append parameters to run names  <a href="#af015d79ae4fd62a026ff3e2ed32d9bce">More...</a><br/></td></tr>
<tr class="separator:af015d79ae4fd62a026ff3e2ed32d9bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a78a12257641af8735520ddaa53d5f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a6a78a12257641af8735520ddaa53d5f6">random_surface_noise</a> (float min, float max)</td></tr>
<tr class="memdesc:a6a78a12257641af8735520ddaa53d5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds random noise to each pixel in range [min, max].  <a href="#a6a78a12257641af8735520ddaa53d5f6">More...</a><br/></td></tr>
<tr class="separator:a6a78a12257641af8735520ddaa53d5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37bd5d8b4f32bffe118b7ac13a5eea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae37bd5d8b4f32bffe118b7ac13a5eea1">random_surface_noise</a> ()</td></tr>
<tr class="memdesc:ae37bd5d8b4f32bffe118b7ac13a5eea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds random noise to each pixel using the noise data member.  <a href="#ae37bd5d8b4f32bffe118b7ac13a5eea1">More...</a><br/></td></tr>
<tr class="separator:ae37bd5d8b4f32bffe118b7ac13a5eea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fa78695df7f24b2693437f6d2cf8a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a49fa78695df7f24b2693437f6d2cf8a9">initialise_parabolic_surface</a> (float peak_elev, float edge_offset)</td></tr>
<tr class="memdesc:a49fa78695df7f24b2693437f6d2cf8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This resets the RasterData array to have a parabolic shape, with 0 elevation at the N and S boundaries. It also adds some random noise to the topography. The amplitude of this noise is set by the data member 'noise'. The default noise is 1mm.  <a href="#a49fa78695df7f24b2693437f6d2cf8a9">More...</a><br/></td></tr>
<tr class="separator:a49fa78695df7f24b2693437f6d2cf8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1feebac96fced4fb559886f70e60dbb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a1feebac96fced4fb559886f70e60dbb1">superimpose_parabolic_surface</a> (float peak_elev)</td></tr>
<tr class="memdesc:a1feebac96fced4fb559886f70e60dbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a parabolic surface to the DEM. Used to try and avoid ;arge areas of fill from the fractal initiation steps.  <a href="#a1feebac96fced4fb559886f70e60dbb1">More...</a><br/></td></tr>
<tr class="separator:a1feebac96fced4fb559886f70e60dbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7861c2f0425f312ec0c3f3c7ad6b18f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a7861c2f0425f312ec0c3f3c7ad6b18f9">intialise_fourier_fractal_surface</a> (float fractal_D)</td></tr>
<tr class="memdesc:a7861c2f0425f312ec0c3f3c7ad6b18f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This initialises the raster model to a square model domain with a fractal surface using the algorithm from Saupe (1987d)  <a href="#a7861c2f0425f312ec0c3f3c7ad6b18f9">More...</a><br/></td></tr>
<tr class="separator:a7861c2f0425f312ec0c3f3c7ad6b18f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3180c87b4d3b8e6a5304cc70c0e38cf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a3180c87b4d3b8e6a5304cc70c0e38cf2">intialise_fourier_fractal_surface_v2</a> (float beta, float desired_relief)</td></tr>
<tr class="memdesc:a3180c87b4d3b8e6a5304cc70c0e38cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This initialises the raster model to a square model domain with a fractal surface using the algorithm from the <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a>.  <a href="#a3180c87b4d3b8e6a5304cc70c0e38cf2">More...</a><br/></td></tr>
<tr class="separator:a3180c87b4d3b8e6a5304cc70c0e38cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa477acdd27d860cf0fa597d30e9a4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a1aa477acdd27d860cf0fa597d30e9a4f">intialise_diamond_square_fractal_surface</a> (int feature_order, float desired_relief)</td></tr>
<tr class="memdesc:a1aa477acdd27d860cf0fa597d30e9a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This initialises the raster model to a fractal surface using the diamond square algorithm.  <a href="#a1aa477acdd27d860cf0fa597d30e9a4f">More...</a><br/></td></tr>
<tr class="separator:a1aa477acdd27d860cf0fa597d30e9a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e815867c696c09bd5fc8b333f949edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a6e815867c696c09bd5fc8b333f949edc">initialise_taper_edges_and_raise_raster</a> (int rows_to_taper)</td></tr>
<tr class="memdesc:a6e815867c696c09bd5fc8b333f949edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This takes a raster and tapers the edges to zero elevation. Its purpose is to remove edge artefacts.  <a href="#a6e815867c696c09bd5fc8b333f949edc">More...</a><br/></td></tr>
<tr class="separator:a6e815867c696c09bd5fc8b333f949edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de63c7016fdbf627f0ceaaa229751c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a5de63c7016fdbf627f0ceaaa229751c1">raise_and_fill_raster</a> ()</td></tr>
<tr class="memdesc:a5de63c7016fdbf627f0ceaaa229751c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">this raises the raster so the lowest point is zero and also fills the raster  <a href="#a5de63c7016fdbf627f0ceaaa229751c1">More...</a><br/></td></tr>
<tr class="separator:a5de63c7016fdbf627f0ceaaa229751c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10126e1d9ff1ad8cd2ef2fd941fd323"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad10126e1d9ff1ad8cd2ef2fd941fd323"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>raise_and_fill_raster</b> (float min_slope_for_fill)</td></tr>
<tr class="separator:ad10126e1d9ff1ad8cd2ef2fd941fd323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8678095d20dbc0f105607d73b1f5ce3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae8678095d20dbc0f105607d73b1f5ce3">normal_fault_part_of_raster</a> (int throw_amt, int throw_type)</td></tr>
<tr class="memdesc:ae8678095d20dbc0f105607d73b1f5ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a normal fault horizontally across the raster.  <a href="#ae8678095d20dbc0f105607d73b1f5ce3">More...</a><br/></td></tr>
<tr class="separator:ae8678095d20dbc0f105607d73b1f5ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e109544d223f9a3981b0dd9b2cb1da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a36e109544d223f9a3981b0dd9b2cb1da">base_level_fall</a> (int uplift_amt)</td></tr>
<tr class="memdesc:a36e109544d223f9a3981b0dd9b2cb1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">simulate instantaneous base level fall  <a href="#a36e109544d223f9a3981b0dd9b2cb1da">More...</a><br/></td></tr>
<tr class="separator:a36e109544d223f9a3981b0dd9b2cb1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fdbd1f5deb2e7efe222e06966602a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a62fdbd1f5deb2e7efe222e06966602a1">initialise_nonlinear_SS</a> (float U)</td></tr>
<tr class="memdesc:a62fdbd1f5deb2e7efe222e06966602a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This initialises a surface with a hillslope that is the solution to the nonlinear sediment flux equation. It overwrites RasterData.  <a href="#a62fdbd1f5deb2e7efe222e06966602a1">More...</a><br/></td></tr>
<tr class="separator:a62fdbd1f5deb2e7efe222e06966602a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad405276214c6ada09faa9aa08dc4d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#abad405276214c6ada09faa9aa08dc4d7">resize_and_reset</a> (int new_rows, int new_cols)</td></tr>
<tr class="memdesc:abad405276214c6ada09faa9aa08dc4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This resizes the <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a>, resetting some flags in the process, as well as setting many of the Array2D data members to be empty arrays The raster data in the end is a random surface (determined by the noise data member)  <a href="#abad405276214c6ada09faa9aa08dc4d7">More...</a><br/></td></tr>
<tr class="separator:abad405276214c6ada09faa9aa08dc4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c069763e573b623816e253a560184be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a0c069763e573b623816e253a560184be">resize_and_reset</a> (int new_rows, int new_cols, float new_resolution)</td></tr>
<tr class="memdesc:a0c069763e573b623816e253a560184be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This resizes the <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a>, resetting some flags in the process, as well as setting many of the Array2D data members to be empty arrays The raster data in the end is a random surface (determined by the noise data member) This overloaded version also changes the data resolution.  <a href="#a0c069763e573b623816e253a560184be">More...</a><br/></td></tr>
<tr class="separator:a0c069763e573b623816e253a560184be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687c77476e57a4b0217a82f8354bdbfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a687c77476e57a4b0217a82f8354bdbfe">add_path_to_names</a> (string pathname)</td></tr>
<tr class="memdesc:a687c77476e57a4b0217a82f8354bdbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">this ads a pathname to the default names  <a href="#a687c77476e57a4b0217a82f8354bdbfe">More...</a><br/></td></tr>
<tr class="separator:a687c77476e57a4b0217a82f8354bdbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fb915d3eb2fb31f57292c72cc27e68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a32fb915d3eb2fb31f57292c72cc27e68">check_steady_state</a> (void)</td></tr>
<tr class="memdesc:a32fb915d3eb2fb31f57292c72cc27e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks to see if the model has achieved steady state. The nature of steady state checked is set by the cycle_steady_check flag If this is false, it checks if there is simple steady state (the surface elevations do not change in time) If the cycle_steady_check is true, it check if steady state has been achieved from one cycle to another.  <a href="#a32fb915d3eb2fb31f57292c72cc27e68">More...</a><br/></td></tr>
<tr class="separator:a32fb915d3eb2fb31f57292c72cc27e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5c246aa026d9a5292cca13c6aad189"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a5c5c246aa026d9a5292cca13c6aad189">check_recording</a> (void)</td></tr>
<tr class="memdesc:a5c5c246aa026d9a5292cca13c6aad189"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks to see if the model should record results If initial steady state has not been reached, recording is set to false: that is, the model does not record information on the build up to steady state.  <a href="#a5c5c246aa026d9a5292cca13c6aad189">More...</a><br/></td></tr>
<tr class="separator:a5c5c246aa026d9a5292cca13c6aad189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62048b6dcd9553b03d1c6950e617cdb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a62048b6dcd9553b03d1c6950e617cdb1">check_end_condition</a> (void)</td></tr>
<tr class="memdesc:a62048b6dcd9553b03d1c6950e617cdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This checks on the ending condition of the model run endTime_mode: 1 == The end time is just some fixed time after initial steady state 2 == The end time is after a fixed number of cycles 3 == The time is after steady state, but waits for a fixed number of cycles before ending.  <a href="#a62048b6dcd9553b03d1c6950e617cdb1">More...</a><br/></td></tr>
<tr class="separator:a62048b6dcd9553b03d1c6950e617cdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15760c528df4d411b4cc5a5ed1decaab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a15760c528df4d411b4cc5a5ed1decaab">check_periodicity_switch</a> (void)</td></tr>
<tr class="memdesc:a15760c528df4d411b4cc5a5ed1decaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks to see if this is a periodic run. If it is, it sets the times to align with the period Note this only realy comes into play if period mode == 2 or 4 period_mode means 1 (default) one periodicity used without 2 Two periodicities that switch at a given interval 3 Two periodicities used as a compound sin wave 4 Same as three, but weightings switch at a given interval (as in 2)  <a href="#a15760c528df4d411b4cc5a5ed1decaab">More...</a><br/></td></tr>
<tr class="separator:a15760c528df4d411b4cc5a5ed1decaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb5171ffe6b680cd8d66f5b28e01b50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a7fb5171ffe6b680cd8d66f5b28e01b50">check_if_hung</a> (void)</td></tr>
<tr class="memdesc:a7fb5171ffe6b680cd8d66f5b28e01b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the periodic model cycles over 100 times this returns true.  <a href="#a7fb5171ffe6b680cd8d66f5b28e01b50">More...</a><br/></td></tr>
<tr class="separator:a7fb5171ffe6b680cd8d66f5b28e01b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c5ee678da5236c286b412f45476e88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a09c5ee678da5236c286b412f45476e88">reset_model</a> (void)</td></tr>
<tr class="memdesc:a09c5ee678da5236c286b412f45476e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset model - reset erosion values to 0 after a complete model run.  <a href="#a09c5ee678da5236c286b412f45476e88">More...</a><br/></td></tr>
<tr class="separator:a09c5ee678da5236c286b412f45476e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a85312bf014b46b8944197f33d4cf94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a0a85312bf014b46b8944197f33d4cf94">create_buffered_surf</a> (int b_type)</td></tr>
<tr class="memdesc:a0a85312bf014b46b8944197f33d4cf94"><td class="mdescLeft">&#160;</td><td class="mdescRight">This first function is used as a simple way to implement boundary conditions, particularly no flux and periodic boundary conditions. The buffered surface has NRows+2 rows and NCols+2 columns. The integer b_type sets the type of boundary conditions, but currently there is only one implementation: no flux across N and S; periodic for E and W.  <a href="#a0a85312bf014b46b8944197f33d4cf94">More...</a><br/></td></tr>
<tr class="separator:a0a85312bf014b46b8944197f33d4cf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff77cd0beee7155ae1e247b5ce8432df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aff77cd0beee7155ae1e247b5ce8432df">create_buffered_surf</a> (float South_boundary_elevation, float North_boundary_elevation)</td></tr>
<tr class="memdesc:aff77cd0beee7155ae1e247b5ce8432df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This second version has periodic boundaries at E and W boundaries, and Neumann boundary conditions (prescribed elevations) at the N and S boundaries.  <a href="#aff77cd0beee7155ae1e247b5ce8432df">More...</a><br/></td></tr>
<tr class="separator:aff77cd0beee7155ae1e247b5ce8432df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36b5aaeced6fb4cc49e9ab7a069f3b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab36b5aaeced6fb4cc49e9ab7a069f3b1">is_base_level</a> (int i, int j)</td></tr>
<tr class="memdesc:ab36b5aaeced6fb4cc49e9ab7a069f3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether current node is a base level node.  <a href="#ab36b5aaeced6fb4cc49e9ab7a069f3b1">More...</a><br/></td></tr>
<tr class="separator:ab36b5aaeced6fb4cc49e9ab7a069f3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579106546ee77a5edf3fcf9ee01623fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a579106546ee77a5edf3fcf9ee01623fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a579106546ee77a5edf3fcf9ee01623fc">interpret_boundary</a> (short &amp;dimension, bool &amp;periodic, int &amp;size)</td></tr>
<tr class="memdesc:a579106546ee77a5edf3fcf9ee01623fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">not sure what this does yet (SMM) <br/></td></tr>
<tr class="separator:a579106546ee77a5edf3fcf9ee01623fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bed30e73f0ee13a334ac1df002ce143"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a4bed30e73f0ee13a334ac1df002ce143">find_max_boundary</a> (int boundary_number)</td></tr>
<tr class="memdesc:a4bed30e73f0ee13a334ac1df002ce143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maxium elevation along a boundary.  <a href="#a4bed30e73f0ee13a334ac1df002ce143">More...</a><br/></td></tr>
<tr class="separator:a4bed30e73f0ee13a334ac1df002ce143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627e0ea53705582a8767c84fa969370e"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a627e0ea53705582a8767c84fa969370e">calculate_erosion_rates</a> (void)</td></tr>
<tr class="memdesc:a627e0ea53705582a8767c84fa969370e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function that creates an array with the erosion rates for a given timestep. It doesn't do anything with NoData cells, and for cells with data it calls the get_erosion_at_cell member function updated to catch instances when zeta_old has not been calculated.  <a href="#a627e0ea53705582a8767c84fa969370e">More...</a><br/></td></tr>
<tr class="separator:a627e0ea53705582a8767c84fa969370e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af318687f4e7536aaf9973730ce9fec37"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#af318687f4e7536aaf9973730ce9fec37">get_erosion_at_cell</a> (int row, int col)</td></tr>
<tr class="memdesc:af318687f4e7536aaf9973730ce9fec37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This calculates the erosion rate for individual cells. Currently it assumes that the zeta_old data member is from the previous timestep.  <a href="#af318687f4e7536aaf9973730ce9fec37">More...</a><br/></td></tr>
<tr class="separator:af318687f4e7536aaf9973730ce9fec37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb5db4f45eb5196f8c9bfa3e0ae33e9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#acbb5db4f45eb5196f8c9bfa3e0ae33e9">get_total_erosion_rate_over_timestep</a> ()</td></tr>
<tr class="memdesc:acbb5db4f45eb5196f8c9bfa3e0ae33e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">this calcualtes the total erosion over a timester  <a href="#acbb5db4f45eb5196f8c9bfa3e0ae33e9">More...</a><br/></td></tr>
<tr class="separator:acbb5db4f45eb5196f8c9bfa3e0ae33e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4d5defd202390cc09b90f3a0780040"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ada4d5defd202390cc09b90f3a0780040">precip_array_from_precip_rate</a> (float precip_rate)</td></tr>
<tr class="separator:ada4d5defd202390cc09b90f3a0780040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0ad45b0d6732993705b433e63ee115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a6e0ad45b0d6732993705b433e63ee115">get_slopes</a> (Array2D&lt; float &gt; &amp;SlopesBetweenRows, Array2D&lt; float &gt; &amp;SlopesBetweenCols)</td></tr>
<tr class="separator:a6e0ad45b0d6732993705b433e63ee115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ead96b3085ca24da4f812bf0114aa93"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a9ead96b3085ca24da4f812bf0114aa93">get_topographic_divergence</a> ()</td></tr>
<tr class="separator:a9ead96b3085ca24da4f812bf0114aa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155a4a6203f9aeac25bf40df0505223c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a155a4a6203f9aeac25bf40df0505223c">calculate_channel_width_wolman</a> (float Q_w, float k_w, float b)</td></tr>
<tr class="separator:a155a4a6203f9aeac25bf40df0505223c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084a2206ec53c4e95eca7943cd818b58"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a084a2206ec53c4e95eca7943cd818b58">array_channel_width_wolman</a> (Array2D&lt; float &gt; &amp;Q_w, float &amp;k_w, float &amp;b)</td></tr>
<tr class="separator:a084a2206ec53c4e95eca7943cd818b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad56ab74937d94b3cb5e59ba58980674"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aad56ab74937d94b3cb5e59ba58980674">calculate_fluvial_erosion_rate</a> (Array2D&lt; float &gt; ChannelWidth, Array2D&lt; float &gt; Q_w, Array2D&lt; float &gt; TopoDivergence, float K, float <a class="el" href="class_l_s_d_raster_model.html#a6fa1e522fb52b5e39e556321e5862134">n</a>, float <a class="el" href="class_l_s_d_raster_model.html#ab3cae56faea604d33f3404c96551d415">m</a>, float eros_thresh)</td></tr>
<tr class="separator:aad56ab74937d94b3cb5e59ba58980674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac1dd92d9e6b156c6c9277174f13322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a7ac1dd92d9e6b156c6c9277174f13322">calculate_k_values_for_assembly_matrix</a> (int <a class="el" href="class_l_s_d_raster.html#ac88ec4e856cb32a69f58b7da5bfc24c0">NRows</a>, int <a class="el" href="class_l_s_d_raster.html#a5835c070514b4bfc39b730e117a3abb7">NCols</a>, vector&lt; int &gt; &amp;k_value_i_j, vector&lt; int &gt; &amp;k_value_ip1_j, vector&lt; int &gt; &amp;k_value_im1_j, vector&lt; int &gt; &amp;k_value_i_jp1, vector&lt; int &gt; &amp;k_value_i_jm1)</td></tr>
<tr class="separator:a7ac1dd92d9e6b156c6c9277174f13322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284c8449248f9acc471259d6084bf056"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a284c8449248f9acc471259d6084bf056"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a284c8449248f9acc471259d6084bf056">mtl_initiate_assembler_matrix</a> (int &amp;<a class="el" href="class_l_s_d_raster_model.html#a17f55f1d6b3de5fbd571b2de0b97d645">problem_dimension</a>, float &amp;<a class="el" href="class_l_s_d_raster_model.html#a08fc62895116d37317da49819e493304">inv_dx_S_c_squared</a>, float &amp;inv_dy_S_c_squared, float &amp;<a class="el" href="class_l_s_d_raster_model.html#a553293dfd932797c936fbbc6e1e8ffd8">dx_front_term</a>, float &amp;dy_front_term, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#aad44dfbe1614a2dd5ad6543b2025a4d7">vec_k_value_i_j</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#acc92df89fce060f64b8b05f43fdddbe1">vec_k_value_ip1_j</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#aee8f8923535a6499c63fceb976762f63">vec_k_value_im1_j</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#aaec069ee9cce959702cfbf75d7627907">vec_k_value_i_jp1</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#a985cef4e6e9a6990c13442a3c13beb9e">vec_k_value_i_jm1</a>)</td></tr>
<tr class="memdesc:a284c8449248f9acc471259d6084bf056"><td class="mdescLeft">&#160;</td><td class="mdescRight">mtl_initiate_assembler_matrix <br/></td></tr>
<tr class="separator:a284c8449248f9acc471259d6084bf056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6de596e422be98a58b48ce1975ef0c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ac6de596e422be98a58b48ce1975ef0c4">mtl_assemble_matrix</a> (Array2D&lt; float &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#a2542a14b8ddb80758117f48c039a5949">zeta_last_iter</a>, Array2D&lt; float &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#a8820ba2924b494b5c97ed7db321be8dd">zeta_last_timestep</a>, Array2D&lt; float &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#a6dbe122474888dd4f7c4a2e3ea373bc8">zeta_this_iter</a>, Array2D&lt; float &gt; &amp;uplift_rate, Array2D&lt; float &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#abea4c2a6f4958b9c92a0905a5adad6a4">fluvial_erosion_rate</a>, mtl::compressed2D&lt; float &gt; &amp;mtl_Assembly_matrix, mtl::dense_vector&lt; float &gt; &amp;mtl_b_vector, float dt, int <a class="el" href="class_l_s_d_raster_model.html#a17f55f1d6b3de5fbd571b2de0b97d645">problem_dimension</a>, float <a class="el" href="class_l_s_d_raster_model.html#a08fc62895116d37317da49819e493304">inv_dx_S_c_squared</a>, float inv_dy_S_c_squared, float <a class="el" href="class_l_s_d_raster_model.html#a553293dfd932797c936fbbc6e1e8ffd8">dx_front_term</a>, float dy_front_term, float South_boundary_elevation, float North_boundary_elevation, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#aad44dfbe1614a2dd5ad6543b2025a4d7">vec_k_value_i_j</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#acc92df89fce060f64b8b05f43fdddbe1">vec_k_value_ip1_j</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#aee8f8923535a6499c63fceb976762f63">vec_k_value_im1_j</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#aaec069ee9cce959702cfbf75d7627907">vec_k_value_i_jp1</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#a985cef4e6e9a6990c13442a3c13beb9e">vec_k_value_i_jm1</a>)</td></tr>
<tr class="separator:ac6de596e422be98a58b48ce1975ef0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f3238ea9fb47a3cf468108b6b2501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a915f3238ea9fb47a3cf468108b6b2501">mtl_solve_assembler_matrix</a> (Array2D&lt; float &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#a2542a14b8ddb80758117f48c039a5949">zeta_last_iter</a>, Array2D&lt; float &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#a8820ba2924b494b5c97ed7db321be8dd">zeta_last_timestep</a>, Array2D&lt; float &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#a6dbe122474888dd4f7c4a2e3ea373bc8">zeta_this_iter</a>, Array2D&lt; float &gt; &amp;uplift_rate, Array2D&lt; float &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#abea4c2a6f4958b9c92a0905a5adad6a4">fluvial_erosion_rate</a>, float dt, int <a class="el" href="class_l_s_d_raster_model.html#a17f55f1d6b3de5fbd571b2de0b97d645">problem_dimension</a>, float <a class="el" href="class_l_s_d_raster_model.html#a08fc62895116d37317da49819e493304">inv_dx_S_c_squared</a>, float inv_dy_S_c_squared, float <a class="el" href="class_l_s_d_raster_model.html#a553293dfd932797c936fbbc6e1e8ffd8">dx_front_term</a>, float dy_front_term, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#aad44dfbe1614a2dd5ad6543b2025a4d7">vec_k_value_i_j</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#acc92df89fce060f64b8b05f43fdddbe1">vec_k_value_ip1_j</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#aee8f8923535a6499c63fceb976762f63">vec_k_value_im1_j</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#aaec069ee9cce959702cfbf75d7627907">vec_k_value_i_jp1</a>, std::vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#a985cef4e6e9a6990c13442a3c13beb9e">vec_k_value_i_jm1</a>, float South_boundary_elevation, float North_boundary_elevation)</td></tr>
<tr class="separator:a915f3238ea9fb47a3cf468108b6b2501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c8da854b7b44a9a90c962d6fb9e3e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ad7c8da854b7b44a9a90c962d6fb9e3e1">nonlinear_creep_timestep</a> (Array2D&lt; float &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#abea4c2a6f4958b9c92a0905a5adad6a4">fluvial_erosion_rate</a>, float iteration_tolerance, int <a class="el" href="class_l_s_d_raster_model.html#a17f55f1d6b3de5fbd571b2de0b97d645">problem_dimension</a>, float <a class="el" href="class_l_s_d_raster_model.html#a08fc62895116d37317da49819e493304">inv_dx_S_c_squared</a>, float inv_dy_S_c_squared, float <a class="el" href="class_l_s_d_raster_model.html#a553293dfd932797c936fbbc6e1e8ffd8">dx_front_term</a>, float dy_front_term, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#aad44dfbe1614a2dd5ad6543b2025a4d7">vec_k_value_i_j</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#acc92df89fce060f64b8b05f43fdddbe1">vec_k_value_ip1_j</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#aee8f8923535a6499c63fceb976762f63">vec_k_value_im1_j</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#aaec069ee9cce959702cfbf75d7627907">vec_k_value_i_jp1</a>, vector&lt; int &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#a985cef4e6e9a6990c13442a3c13beb9e">vec_k_value_i_jm1</a>, float South_boundary_elevation, float North_boundary_elevation)</td></tr>
<tr class="separator:ad7c8da854b7b44a9a90c962d6fb9e3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba8678df60e842632cbd1a6df29d06f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a4ba8678df60e842632cbd1a6df29d06f">soil_diffusion_fv</a> (void)</td></tr>
<tr class="separator:a4ba8678df60e842632cbd1a6df29d06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af817b9d03df68bc3f8b3f09dda921093"><td class="memItemLeft" align="right" valign="top">mtl::compressed2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#af817b9d03df68bc3f8b3f09dda921093">generate_fd_matrix</a> (int dimension, int size, bool periodic)</td></tr>
<tr class="separator:af817b9d03df68bc3f8b3f09dda921093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2de0afdfc25113b92d493033afc0aed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2de0afdfc25113b92d493033afc0aed"></a>
mtl::dense_vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>build_fd_vector</b> (int dimension, int size)</td></tr>
<tr class="separator:ab2de0afdfc25113b92d493033afc0aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f15d8cb219f335fda932eac7d544277"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f15d8cb219f335fda932eac7d544277"></a>
mtl::compressed2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_fv_matrix</b> (int dimension, int size, bool periodic)</td></tr>
<tr class="separator:a2f15d8cb219f335fda932eac7d544277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192eba481fa3a4e75154a76a07fa369f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a192eba481fa3a4e75154a76a07fa369f"></a>
mtl::dense_vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>build_fv_vector</b> (int dimension, int size)</td></tr>
<tr class="separator:a192eba481fa3a4e75154a76a07fa369f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d8a6e17f3322f036f4f99b7c5e6075"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49d8a6e17f3322f036f4f99b7c5e6075"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>repack_vector</b> (mtl::dense_vector&lt; float &gt; &amp;data_vector, int dimension)</td></tr>
<tr class="separator:a49d8a6e17f3322f036f4f99b7c5e6075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eabd21a489fa58012c10a1338123c1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a8eabd21a489fa58012c10a1338123c1f">soil_diffusion_fd_linear</a> (void)</td></tr>
<tr class="separator:a8eabd21a489fa58012c10a1338123c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebd50417b038edbc0de560da8bd7f83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ebd50417b038edbc0de560da8bd7f83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>soil_diffusion_fv_nonlinear</b> (void)</td></tr>
<tr class="separator:a8ebd50417b038edbc0de560da8bd7f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8072cbbec5bc2c811c9bc62cffccc6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab8072cbbec5bc2c811c9bc62cffccc6a">run_model_implicit_hillslope_and_fluvial</a> (string param_file)</td></tr>
<tr class="separator:ab8072cbbec5bc2c811c9bc62cffccc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f91ca83a51a91e5f8518261ede061ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a0f91ca83a51a91e5f8518261ede061ab">run_model</a> (void)</td></tr>
<tr class="memdesc:a0f91ca83a51a91e5f8518261ede061ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This wrapper just calls the run_components method. Parameters used are those stored as data members.  <a href="#a0f91ca83a51a91e5f8518261ede061ab">More...</a><br/></td></tr>
<tr class="separator:a0f91ca83a51a91e5f8518261ede061ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadcfe595fad8bfb23f2b2d90b9af96f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#afadcfe595fad8bfb23f2b2d90b9af96f">run_model_from_steady_state</a> (void)</td></tr>
<tr class="memdesc:afadcfe595fad8bfb23f2b2d90b9af96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This loads a steady state raster from the data members so that a model can be run repeatedly from the same steady state condition.  <a href="#afadcfe595fad8bfb23f2b2d90b9af96f">More...</a><br/></td></tr>
<tr class="separator:afadcfe595fad8bfb23f2b2d90b9af96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07fe62578a9754af53f2d01dfb165f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab07fe62578a9754af53f2d01dfb165f5">run_components</a> (void)</td></tr>
<tr class="memdesc:ab07fe62578a9754af53f2d01dfb165f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This wrapper just calls the run_components method. Parameters used are those stored as data members. This one actually calls the erosion laws.  <a href="#ab07fe62578a9754af53f2d01dfb165f5">More...</a><br/></td></tr>
<tr class="separator:ab07fe62578a9754af53f2d01dfb165f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a896652bfa268fe3e84ceb2a30bbf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae4a896652bfa268fe3e84ceb2a30bbf1">run_components_combined</a> (void)</td></tr>
<tr class="memdesc:ae4a896652bfa268fe3e84ceb2a30bbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a wrapper similar to run_components but sends the fluvial and uplfit fields to the nonlinear solver.  <a href="#ae4a896652bfa268fe3e84ceb2a30bbf1">More...</a><br/></td></tr>
<tr class="separator:ae4a896652bfa268fe3e84ceb2a30bbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2a4c25bf2772e3108da8f349d686fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a5d2a4c25bf2772e3108da8f349d686fb">run_components_combined</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;URaster, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;KRaster, bool use_adaptive_timestep)</td></tr>
<tr class="memdesc:a5d2a4c25bf2772e3108da8f349d686fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a wrapper similar to run_components but sends the fluvial and uplfit fields to the nonlinear solver.  Variable U and K rasters can be used.  <a href="#a5d2a4c25bf2772e3108da8f349d686fb">More...</a><br/></td></tr>
<tr class="separator:a5d2a4c25bf2772e3108da8f349d686fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bc5cf26e557dd1e94be0a847bcf091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ac8bc5cf26e557dd1e94be0a847bcf091">run_components_combined_cell_tracker</a> (vector&lt; <a class="el" href="class_l_s_d_particle_column.html">LSDParticleColumn</a> &gt; &amp;CRNColumns, vector&lt; <a class="el" href="class_l_s_d_particle_column.html">LSDParticleColumn</a> &gt; &amp;eroded_cells, int startType, double startDepth, double particle_spacing, <a class="el" href="class_l_s_d_c_r_n_parameters.html">LSDCRNParameters</a> &amp;CRNParam)</td></tr>
<tr class="memdesc:ac8bc5cf26e557dd1e94be0a847bcf091"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a wrapper that runs the model but includes CRN columns fluvial and uplfit fields to the nonlinear solver.  <a href="#ac8bc5cf26e557dd1e94be0a847bcf091">More...</a><br/></td></tr>
<tr class="separator:ac8bc5cf26e557dd1e94be0a847bcf091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba0fb6ea4c89a5376cf44bc5ed06e76"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_l_s_d_particle_column.html">LSDParticleColumn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a2ba0fb6ea4c89a5376cf44bc5ed06e76">initiate_steady_CRN_columns</a> (int column_spacing, vector&lt; int &gt; &amp;CRNcol_rows, vector&lt; int &gt; &amp;CRNcol_cols, double rho_r, double this_U, int startType, double startDepth, double particle_spacing, <a class="el" href="class_l_s_d_c_r_n_parameters.html">LSDCRNParameters</a> &amp;CRNParam)</td></tr>
<tr class="memdesc:a2ba0fb6ea4c89a5376cf44bc5ed06e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This initiates a vector of CRN columns that sit under the model.  <a href="#a2ba0fb6ea4c89a5376cf44bc5ed06e76">More...</a><br/></td></tr>
<tr class="separator:a2ba0fb6ea4c89a5376cf44bc5ed06e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6794287484c8c2683c72d38bb40fe9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ad6794287484c8c2683c72d38bb40fe9e">reach_steady_state</a> (void)</td></tr>
<tr class="memdesc:ad6794287484c8c2683c72d38bb40fe9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method forces the landscape into its steady state profile, by using periodic forcing. This is much more efficient than using static forcing (as in run model), but doesn't give a nice animation of an evolving landscape Swings and roundabouts.  <a href="#ad6794287484c8c2683c72d38bb40fe9e">More...</a><br/></td></tr>
<tr class="separator:ad6794287484c8c2683c72d38bb40fe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3934e2c1fa1658d8be464d4aeea1e011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a3934e2c1fa1658d8be464d4aeea1e011">fluvial_snap_to_steady_state</a> (float U)</td></tr>
<tr class="memdesc:a3934e2c1fa1658d8be464d4aeea1e011"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method creates a steady landscape that assumes everywhere obeys the stream power law. It is based on equation 4a from Mudd et al 2014 JGR-ES  There is no return but the underlying raster data will reflect the analytical steady topography for the uplift rate.  <a href="#a3934e2c1fa1658d8be464d4aeea1e011">More...</a><br/></td></tr>
<tr class="separator:a3934e2c1fa1658d8be464d4aeea1e011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd92e0cd0cc8bb73d91ac4a7ff93b3f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aacd92e0cd0cc8bb73d91ac4a7ff93b3f">fluvial_snap_to_steady_state_tune_K_for_relief</a> (float U, float desired_relief)</td></tr>
<tr class="memdesc:aacd92e0cd0cc8bb73d91ac4a7ff93b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method creates a steady landscape that assumes everywhere obeys the stream power law. It is based on equation 4a from Mudd et al 2014 JGR-ES. The function is given a target relief and the K value is adjusted to match this target relief at the maximum chi value.  In addition to the return, the underlying raster data will reflect the analytical steady topography for the uplift rate.  <a href="#aacd92e0cd0cc8bb73d91ac4a7ff93b3f">More...</a><br/></td></tr>
<tr class="separator:aacd92e0cd0cc8bb73d91ac4a7ff93b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d40257c1cc4f409c663488d7a514b2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a94d40257c1cc4f409c663488d7a514b2">fluvial_calculate_K_for_steady_state_relief</a> (float U, float desired_relief)</td></tr>
<tr class="memdesc:a94d40257c1cc4f409c663488d7a514b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method calcualtes the fluvial K required to generate the desired relief at steady state for the farthest upstream chi. It is based on equation 4a from Mudd et al 2014 JGR-ES.  This does not update aything in the model, but simply returns the desired K.  <a href="#a94d40257c1cc4f409c663488d7a514b2">More...</a><br/></td></tr>
<tr class="separator:a94d40257c1cc4f409c663488d7a514b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2a8455c460b4ce906d7b883179bab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#acc2a8455c460b4ce906d7b883179bab7">fluvial_incision</a> (void)</td></tr>
<tr class="memdesc:acc2a8455c460b4ce906d7b883179bab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fastscape, implicit finite difference solver for stream power equations O(n) Method takes its paramaters from the model data members and solves the stream power equation at a future timestep in linear time.  <a href="#acc2a8455c460b4ce906d7b883179bab7">More...</a><br/></td></tr>
<tr class="separator:acc2a8455c460b4ce906d7b883179bab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3204a5d3d4acdb70043c242f5ade271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ad3204a5d3d4acdb70043c242f5ade271">fluvial_incision_with_uplift</a> (void)</td></tr>
<tr class="memdesc:ad3204a5d3d4acdb70043c242f5ade271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fastscape, implicit finite difference solver for stream power equations O(n) Method takes its paramaters from the model data members and solves the stream power equation at a future timestep in linear time This version includes the current uplift, so you do not need to call uplift after this has finished.  <a href="#ad3204a5d3d4acdb70043c242f5ade271">More...</a><br/></td></tr>
<tr class="separator:ad3204a5d3d4acdb70043c242f5ade271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9bf0ae3332f1389f13da2a9836c03a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aef9bf0ae3332f1389f13da2a9836c03a">fluvial_incision_with_uplift_and_variable_K</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;K_raster)</td></tr>
<tr class="memdesc:aef9bf0ae3332f1389f13da2a9836c03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fastscape, implicit finite difference solver for stream power equations O(n) Method takes the K value from a raster fed to it and solves the stream power equation at a future timestep in linear time This version includes the current uplift, so you do not need to call uplift after this has finished.  <a href="#aef9bf0ae3332f1389f13da2a9836c03a">More...</a><br/></td></tr>
<tr class="separator:aef9bf0ae3332f1389f13da2a9836c03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12316bca2ffb8a31451430fdabf9694b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a12316bca2ffb8a31451430fdabf9694b">fluvial_incision_with_variable_uplift_and_variable_K</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Uplift_rate, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;K_raster)</td></tr>
<tr class="memdesc:a12316bca2ffb8a31451430fdabf9694b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fastscape, implicit finite difference solver for stream power equations O(n) Method takes the K value from a raster fed to it and also take a raster of the uplift rates and solves the stream power equation at a future timestep in linear time This version includes the current uplift, so you do not need to call uplift after this has finished.  <a href="#a12316bca2ffb8a31451430fdabf9694b">More...</a><br/></td></tr>
<tr class="separator:a12316bca2ffb8a31451430fdabf9694b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa779dbfb7214661088d9157b1af22f0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aa779dbfb7214661088d9157b1af22f0b">fluvial_incision_with_variable_uplift_and_variable_K_adaptive_timestep</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Uplift_rate, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;K_raster)</td></tr>
<tr class="memdesc:aa779dbfb7214661088d9157b1af22f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fastscape, implicit finite difference solver for stream power equations O(n) Method takes the K value from a raster fed to it and also take a raster of the uplift rates and solves the stream power equation at a future timestep in linear time This version includes the current uplift, so you do not need to call uplift after this has finished. Uses an adaptive timestep.  <a href="#aa779dbfb7214661088d9157b1af22f0b">More...</a><br/></td></tr>
<tr class="separator:aa779dbfb7214661088d9157b1af22f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4c2a6f4958b9c92a0905a5adad6a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#abea4c2a6f4958b9c92a0905a5adad6a4">fluvial_erosion_rate</a> (float timestep, float K, float <a class="el" href="class_l_s_d_raster_model.html#ab3cae56faea604d33f3404c96551d415">m</a>, float <a class="el" href="class_l_s_d_raster_model.html#a6fa1e522fb52b5e39e556321e5862134">n</a>, vector&lt; string &gt; boundary)</td></tr>
<tr class="memdesc:abea4c2a6f4958b9c92a0905a5adad6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is more or less identical to fluvial_incision above, but it Returns a raster with the erosion rate and takes arguments rather than reading from data members.  <a href="#abea4c2a6f4958b9c92a0905a5adad6a4">More...</a><br/></td></tr>
<tr class="separator:abea4c2a6f4958b9c92a0905a5adad6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615b8c5b500a525282921d313d12a7fe"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a615b8c5b500a525282921d313d12a7fe">fluvial_erosion_rate</a> (void)</td></tr>
<tr class="memdesc:a615b8c5b500a525282921d313d12a7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is more or less identical to fluvial_incision above, but it Returns an array and takes arguments rather reads from data members.  <a href="#a615b8c5b500a525282921d313d12a7fe">More...</a><br/></td></tr>
<tr class="separator:a615b8c5b500a525282921d313d12a7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88771b6e458a3c323233491586075c25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a88771b6e458a3c323233491586075c25">wash_out</a> (void)</td></tr>
<tr class="memdesc:a88771b6e458a3c323233491586075c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This assumes that all sediment transported from rivers into channels is removed. It checks the raster to see where the channels are which at this point is determined by a threshold drainage area, and then removes all the sediment to those pixels.  <a href="#a88771b6e458a3c323233491586075c25">More...</a><br/></td></tr>
<tr class="separator:a88771b6e458a3c323233491586075c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c81479ad710ae501e19226ffc9b7db1"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a1c81479ad710ae501e19226ffc9b7db1">generate_uplift_field</a> (int mode, float <a class="el" href="class_l_s_d_raster_model.html#ad021a48fc8bdf0b6d47a97cb2b1aaeff">max_uplift</a>)</td></tr>
<tr class="memdesc:a1c81479ad710ae501e19226ffc9b7db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates uplift field from a set of templates.  <a href="#a1c81479ad710ae501e19226ffc9b7db1">More...</a><br/></td></tr>
<tr class="separator:a1c81479ad710ae501e19226ffc9b7db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5da6c2938dc2467b21d1c4025c27652"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab5da6c2938dc2467b21d1c4025c27652">generate_uplift_field</a> (void)</td></tr>
<tr class="memdesc:ab5da6c2938dc2467b21d1c4025c27652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates uplift field from a set of templates, parameters are taken from data members.  <a href="#ab5da6c2938dc2467b21d1c4025c27652">More...</a><br/></td></tr>
<tr class="separator:ab5da6c2938dc2467b21d1c4025c27652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691069a8cafbaee11223e2c16b3e749b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a691069a8cafbaee11223e2c16b3e749b">get_uplift_at_cell</a> (int i, int j)</td></tr>
<tr class="memdesc:a691069a8cafbaee11223e2c16b3e749b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the uplift value at a given cell this method is implemented as a memory saving measure, rather than storing the uplift field in memory Some methods still implemented still use this uplift field It's advisable this is changed, otherwise the size of rasters that can be modelled will be severely reduced.  <a href="#a691069a8cafbaee11223e2c16b3e749b">More...</a><br/></td></tr>
<tr class="separator:a691069a8cafbaee11223e2c16b3e749b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4461aa99a0b538a96d8a3ee9220c04e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae4461aa99a0b538a96d8a3ee9220c04e">get_uplift_rate_at_cell</a> (int i, int j)</td></tr>
<tr class="memdesc:ae4461aa99a0b538a96d8a3ee9220c04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the uplift rate at a given cell this method is implemented as a memory saving measure, rather than storing the uplift field in memory Some methods still implemented still use this uplift field It's advisable this is changed, otherwise the size of rasters that can be modelled will be severely reduced.  <a href="#ae4461aa99a0b538a96d8a3ee9220c04e">More...</a><br/></td></tr>
<tr class="separator:ae4461aa99a0b538a96d8a3ee9220c04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf2fbe1fa282b7897eafd8ac3ab5552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a3cf2fbe1fa282b7897eafd8ac3ab5552">check_and_correct_uplift_field</a> ()</td></tr>
<tr class="memdesc:a3cf2fbe1fa282b7897eafd8ac3ab5552"><td class="mdescLeft">&#160;</td><td class="mdescRight">This checks to see if the uplift field is consistent with the raster dimensions. If not it corrects the dimensions of the uplift field.  <a href="#a3cf2fbe1fa282b7897eafd8ac3ab5552">More...</a><br/></td></tr>
<tr class="separator:a3cf2fbe1fa282b7897eafd8ac3ab5552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa1f9ef398ae753f04bfefbfc9f8155"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a1fa1f9ef398ae753f04bfefbfc9f8155">get_average_upflit_rate_last_timestep</a> ()</td></tr>
<tr class="memdesc:a1fa1f9ef398ae753f04bfefbfc9f8155"><td class="mdescLeft">&#160;</td><td class="mdescRight">this calcualtes the average uplfit rate over the entire model domain, excluding the N and S boundaries  <a href="#a1fa1f9ef398ae753f04bfefbfc9f8155">More...</a><br/></td></tr>
<tr class="separator:a1fa1f9ef398ae753f04bfefbfc9f8155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c9c22122b23eb77693775e07413b81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a35c9c22122b23eb77693775e07413b81">uplift_surface</a> (float UpliftRate, float dt)</td></tr>
<tr class="memdesc:a35c9c22122b23eb77693775e07413b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply uplift field to the raster. Overloaded function so that the first simply considers uniform uplift, the second allows user to use a prescribed uplift fields of greater complexity, for example taking account of fault geometry.  <a href="#a35c9c22122b23eb77693775e07413b81">More...</a><br/></td></tr>
<tr class="separator:a35c9c22122b23eb77693775e07413b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59c1ff57be88a8070b16c73514da8ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#af59c1ff57be88a8070b16c73514da8ef">uplift_surface</a> (Array2D&lt; float &gt; UpliftRate, float dt)</td></tr>
<tr class="memdesc:af59c1ff57be88a8070b16c73514da8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uplift surface using specified uplift field uplift field should be specified as an array with the same dimensions as the elevation raster, permitting non-uniform uplift fields to be applied in the model.  <a href="#af59c1ff57be88a8070b16c73514da8ef">More...</a><br/></td></tr>
<tr class="separator:af59c1ff57be88a8070b16c73514da8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a0471dd4661057fdb1320e62e1ea4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a71a0471dd4661057fdb1320e62e1ea4a">uplift_surface</a> (void)</td></tr>
<tr class="memdesc:a71a0471dd4661057fdb1320e62e1ea4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic method of uplifting the Raster Uplift field attribute is incremented onto RasterData itself There are no parameters, but rather it simply passes upflift to the get upflift at cell function.  <a href="#a71a0471dd4661057fdb1320e62e1ea4a">More...</a><br/></td></tr>
<tr class="separator:a71a0471dd4661057fdb1320e62e1ea4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd709b90c70728620958372af75b264a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#acd709b90c70728620958372af75b264a">get_max_uplift</a> (void)</td></tr>
<tr class="memdesc:acd709b90c70728620958372af75b264a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This just returns the max_uplift data member NOTE; while this is currently a very trivial, and arguably unecessary method, it should be used and developed if someone wants to integrate some sort of changing uplift field.  <a href="#acd709b90c70728620958372af75b264a">More...</a><br/></td></tr>
<tr class="separator:acd709b90c70728620958372af75b264a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec2f15d2a759abd8e65b5f843efe8a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a7ec2f15d2a759abd8e65b5f843efe8a9">set_uplift_field_to_block_uplift</a> (float uplift_rate)</td></tr>
<tr class="memdesc:a7ec2f15d2a759abd8e65b5f843efe8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the uplift_field data member as bolck uplift with a rate of uplift_rate.  <a href="#a7ec2f15d2a759abd8e65b5f843efe8a9">More...</a><br/></td></tr>
<tr class="separator:a7ec2f15d2a759abd8e65b5f843efe8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6285eea4a82b23f6d52e8c69aea0e10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aa6285eea4a82b23f6d52e8c69aea0e10">run_isostatic_correction</a> (void)</td></tr>
<tr class="separator:aa6285eea4a82b23f6d52e8c69aea0e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f60042d6b0f13a2951a7637069d663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a04f60042d6b0f13a2951a7637069d663">Airy_isostasy</a> (void)</td></tr>
<tr class="separator:a04f60042d6b0f13a2951a7637069d663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60d05732f02edfb229c9a827b67e411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae60d05732f02edfb229c9a827b67e411">flexural_isostasy</a> (float alpha)</td></tr>
<tr class="separator:ae60d05732f02edfb229c9a827b67e411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49afd12b23e7ebb5c3075bdb5c3d407"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac49afd12b23e7ebb5c3075bdb5c3d407"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>flexural_isostasy_alt</b> (void)</td></tr>
<tr class="separator:ac49afd12b23e7ebb5c3075bdb5c3d407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b729369d29d86b97b42c8d03d8647a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b729369d29d86b97b42c8d03d8647a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write_root</b> (string <a class="el" href="class_l_s_d_raster_model.html#a9471043d3cb80318abe82e383b2ddb4c">name</a>, string ext)</td></tr>
<tr class="separator:a8b729369d29d86b97b42c8d03d8647a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77632533c5f622cf4ea5e675435e3850"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a77632533c5f622cf4ea5e675435e3850">calculate_root</a> (void)</td></tr>
<tr class="separator:a77632533c5f622cf4ea5e675435e3850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7396f0ecd611ed0a77b3334cf8bcebd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7396f0ecd611ed0a77b3334cf8bcebd5"></a>
Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_airy</b> (void)</td></tr>
<tr class="separator:a7396f0ecd611ed0a77b3334cf8bcebd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86963ab309ceb28a8357ecd15a98b785"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86963ab309ceb28a8357ecd15a98b785"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a86963ab309ceb28a8357ecd15a98b785">set_boundary_conditions</a> (vector&lt; string &gt; bc)</td></tr>
<tr class="memdesc:a86963ab309ceb28a8357ecd15a98b785"><td class="mdescLeft">&#160;</td><td class="mdescRight">this sets the boundary conditions <br/></td></tr>
<tr class="separator:a86963ab309ceb28a8357ecd15a98b785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a38e7e7d822e4a4fd737317e6f8e968"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a38e7e7d822e4a4fd737317e6f8e968"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_boundary_conditions_to_screen</b> ()</td></tr>
<tr class="separator:a3a38e7e7d822e4a4fd737317e6f8e968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ffa2f30177e7bb54b8f2d03ef794af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68ffa2f30177e7bb54b8f2d03ef794af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a68ffa2f30177e7bb54b8f2d03ef794af">set_timeStep</a> (float dt)</td></tr>
<tr class="memdesc:a68ffa2f30177e7bb54b8f2d03ef794af"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the time step <br/></td></tr>
<tr class="separator:a68ffa2f30177e7bb54b8f2d03ef794af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2b53ecd979cb870fb5d0496b3097f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f2b53ecd979cb870fb5d0496b3097f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a2f2b53ecd979cb870fb5d0496b3097f7">set_maxtimeStep</a> (float max_dt)</td></tr>
<tr class="memdesc:a2f2b53ecd979cb870fb5d0496b3097f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the maximum time step <br/></td></tr>
<tr class="separator:a2f2b53ecd979cb870fb5d0496b3097f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac63bae1428d7a0b4116b66370b6d416"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac63bae1428d7a0b4116b66370b6d416"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aac63bae1428d7a0b4116b66370b6d416">set_endTime</a> (float time)</td></tr>
<tr class="memdesc:aac63bae1428d7a0b4116b66370b6d416"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the ending time <br/></td></tr>
<tr class="separator:aac63bae1428d7a0b4116b66370b6d416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef987154f56bbcb3cbf16b2d43b9d41f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef987154f56bbcb3cbf16b2d43b9d41f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aef987154f56bbcb3cbf16b2d43b9d41f">set_num_runs</a> (int num)</td></tr>
<tr class="memdesc:aef987154f56bbcb3cbf16b2d43b9d41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the number of runs. Used for running multiple simulations from the same starting conditions <br/></td></tr>
<tr class="separator:aef987154f56bbcb3cbf16b2d43b9d41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f804e6e9efcc0b822d9cd32720936e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f804e6e9efcc0b822d9cd32720936e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a0f804e6e9efcc0b822d9cd32720936e0">set_uplift_mode</a> (int new_uplift_mode)</td></tr>
<tr class="memdesc:a0f804e6e9efcc0b822d9cd32720936e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the uplift mode <br/></td></tr>
<tr class="separator:a0f804e6e9efcc0b822d9cd32720936e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844a11d680d20327803328a7fbf9e644"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a844a11d680d20327803328a7fbf9e644"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a844a11d680d20327803328a7fbf9e644">set_uplift</a> (Array2D&lt; float &gt; uplift)</td></tr>
<tr class="memdesc:a844a11d680d20327803328a7fbf9e644"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded function, set the array of uplift <br/></td></tr>
<tr class="separator:a844a11d680d20327803328a7fbf9e644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44812ac46570c72a866c9ff198ef28eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a44812ac46570c72a866c9ff198ef28eb">set_uplift</a> (int mode, float max_rate)</td></tr>
<tr class="memdesc:a44812ac46570c72a866c9ff198ef28eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded function, set the array of uplift, but using the uplift mode  <a href="#a44812ac46570c72a866c9ff198ef28eb">More...</a><br/></td></tr>
<tr class="separator:a44812ac46570c72a866c9ff198ef28eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5734944a18644ed5b2129ec717e18e8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5734944a18644ed5b2129ec717e18e8c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a5734944a18644ed5b2129ec717e18e8c">set_periodic_uplift</a> (double uplift_amplitude_fraction)</td></tr>
<tr class="memdesc:a5734944a18644ed5b2129ec717e18e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This adjusts the uplift mode. <br/></td></tr>
<tr class="separator:a5734944a18644ed5b2129ec717e18e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef64af77d20b6c72e34854d60e28306"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acef64af77d20b6c72e34854d60e28306"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#acef64af77d20b6c72e34854d60e28306">set_uplift_amplitude</a> (double uplift_amplitude_fraction)</td></tr>
<tr class="memdesc:acef64af77d20b6c72e34854d60e28306"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets the uplift amplitude as a fraction of the uplift. <br/></td></tr>
<tr class="separator:acef64af77d20b6c72e34854d60e28306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a4a5c99f584e0ee078a8f5e2f23063"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0a4a5c99f584e0ee078a8f5e2f23063"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae0a4a5c99f584e0ee078a8f5e2f23063">set_baseline_uplift</a> (float new_rate)</td></tr>
<tr class="memdesc:ae0a4a5c99f584e0ee078a8f5e2f23063"><td class="mdescLeft">&#160;</td><td class="mdescRight">this sets the baseline uplift rate for the tilt block <br/></td></tr>
<tr class="separator:ae0a4a5c99f584e0ee078a8f5e2f23063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82f326a67ba69b5c1c90edfd680ef99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae82f326a67ba69b5c1c90edfd680ef99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae82f326a67ba69b5c1c90edfd680ef99">set_steady_state_tolerance</a> (float tol)</td></tr>
<tr class="memdesc:ae82f326a67ba69b5c1c90edfd680ef99"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the tolerance for determining steady state <br/></td></tr>
<tr class="separator:ae82f326a67ba69b5c1c90edfd680ef99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6d4517dc57e1b65b981396df51fbf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c6d4517dc57e1b65b981396df51fbf6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a0c6d4517dc57e1b65b981396df51fbf6">set_noise</a> (float noise_amp)</td></tr>
<tr class="memdesc:a0c6d4517dc57e1b65b981396df51fbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the amplitude of random noise <br/></td></tr>
<tr class="separator:a0c6d4517dc57e1b65b981396df51fbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb55aadc9b29f382ff794eac36db18c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bb55aadc9b29f382ff794eac36db18c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a3bb55aadc9b29f382ff794eac36db18c">set_K</a> (float K)</td></tr>
<tr class="memdesc:a3bb55aadc9b29f382ff794eac36db18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets fluvial erodibility <br/></td></tr>
<tr class="separator:a3bb55aadc9b29f382ff794eac36db18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851b6dfb3383adb36f0758088db0b8fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a851b6dfb3383adb36f0758088db0b8fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a851b6dfb3383adb36f0758088db0b8fb">set_D</a> (float D)</td></tr>
<tr class="memdesc:a851b6dfb3383adb36f0758088db0b8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the hillslope diffusivity <br/></td></tr>
<tr class="separator:a851b6dfb3383adb36f0758088db0b8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21bbb567fb133b4712cadc884f62b99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae21bbb567fb133b4712cadc884f62b99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae21bbb567fb133b4712cadc884f62b99">set_rigidity</a> (float D)</td></tr>
<tr class="memdesc:ae21bbb567fb133b4712cadc884f62b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the flexural rigidity <br/></td></tr>
<tr class="separator:ae21bbb567fb133b4712cadc884f62b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb737bafbc3f2cb7ebbe38c01818912"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeb737bafbc3f2cb7ebbe38c01818912"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#adeb737bafbc3f2cb7ebbe38c01818912">set_m</a> (float <a class="el" href="class_l_s_d_raster_model.html#ab3cae56faea604d33f3404c96551d415">m</a>)</td></tr>
<tr class="memdesc:adeb737bafbc3f2cb7ebbe38c01818912"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the Area exponent in the SPIM <br/></td></tr>
<tr class="separator:adeb737bafbc3f2cb7ebbe38c01818912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf9d1be6b5bc0d40733c3420c93094a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdf9d1be6b5bc0d40733c3420c93094a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#acdf9d1be6b5bc0d40733c3420c93094a">set_n</a> (float <a class="el" href="class_l_s_d_raster_model.html#a6fa1e522fb52b5e39e556321e5862134">n</a>)</td></tr>
<tr class="memdesc:acdf9d1be6b5bc0d40733c3420c93094a"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the slope exponent in the SPIM <br/></td></tr>
<tr class="separator:acdf9d1be6b5bc0d40733c3420c93094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd6bfc361d0742deb3cd11cf3016aa5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addd6bfc361d0742deb3cd11cf3016aa5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#addd6bfc361d0742deb3cd11cf3016aa5">set_threshold_drainage</a> (float area)</td></tr>
<tr class="memdesc:addd6bfc361d0742deb3cd11cf3016aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the critical drainage area for channels <br/></td></tr>
<tr class="separator:addd6bfc361d0742deb3cd11cf3016aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9094031b602f9c18f7a01191a651e159"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9094031b602f9c18f7a01191a651e159"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a9094031b602f9c18f7a01191a651e159">set_S_c</a> (float Sc_new)</td></tr>
<tr class="memdesc:a9094031b602f9c18f7a01191a651e159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the critical slope. <br/></td></tr>
<tr class="separator:a9094031b602f9c18f7a01191a651e159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fb05889e4edfb125544ab69c68cf65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68fb05889e4edfb125544ab69c68cf65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a68fb05889e4edfb125544ab69c68cf65">set_periodicity</a> (float time)</td></tr>
<tr class="memdesc:a68fb05889e4edfb125544ab69c68cf65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the periodicity in years. <br/></td></tr>
<tr class="separator:a68fb05889e4edfb125544ab69c68cf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ae376c3a4571f4b417f33ab650576d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3ae376c3a4571f4b417f33ab650576d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#af3ae376c3a4571f4b417f33ab650576d">set_periodicity_2</a> (float time)</td></tr>
<tr class="memdesc:af3ae376c3a4571f4b417f33ab650576d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 2nd periodicity in years. <br/></td></tr>
<tr class="separator:af3ae376c3a4571f4b417f33ab650576d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff553771bd5e6b42f8c44110d9eb46b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acff553771bd5e6b42f8c44110d9eb46b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#acff553771bd5e6b42f8c44110d9eb46b">snap_periodicity</a> (void)</td></tr>
<tr class="memdesc:acff553771bd5e6b42f8c44110d9eb46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">this snaps the periodicity to the timestep to ensure the max and min values of a varying parameter are reached <br/></td></tr>
<tr class="separator:acff553771bd5e6b42f8c44110d9eb46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142d6daada660c6513fbaf5b9104bff4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a142d6daada660c6513fbaf5b9104bff4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a142d6daada660c6513fbaf5b9104bff4">set_print_interval</a> (int num_steps)</td></tr>
<tr class="memdesc:a142d6daada660c6513fbaf5b9104bff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the print interval <br/></td></tr>
<tr class="separator:a142d6daada660c6513fbaf5b9104bff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293799cc7ab7bf64710aa9761a68be8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a293799cc7ab7bf64710aa9761a68be8f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a293799cc7ab7bf64710aa9761a68be8f">set_float_print_interval</a> (float float_dt_print)</td></tr>
<tr class="memdesc:a293799cc7ab7bf64710aa9761a68be8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the float print interval <br/></td></tr>
<tr class="separator:a293799cc7ab7bf64710aa9761a68be8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5789c89d0e5140ba40d332b7ecc2082"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5789c89d0e5140ba40d332b7ecc2082"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#af5789c89d0e5140ba40d332b7ecc2082">set_next_printing_time</a> (float next_float_dt_print)</td></tr>
<tr class="memdesc:af5789c89d0e5140ba40d332b7ecc2082"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the float print interval <br/></td></tr>
<tr class="separator:af5789c89d0e5140ba40d332b7ecc2082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa84e64c2f193e1f2bacc3f405ebbfa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#afa84e64c2f193e1f2bacc3f405ebbfa4">set_K_mode</a> (short mode)</td></tr>
<tr class="memdesc:afa84e64c2f193e1f2bacc3f405ebbfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">this sets the K mode  <a href="#afa84e64c2f193e1f2bacc3f405ebbfa4">More...</a><br/></td></tr>
<tr class="separator:afa84e64c2f193e1f2bacc3f405ebbfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc836f381a720b218ca55bc6b028cf84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#afc836f381a720b218ca55bc6b028cf84">set_D_mode</a> (short mode)</td></tr>
<tr class="memdesc:afc836f381a720b218ca55bc6b028cf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">this sets the D mode  <a href="#afc836f381a720b218ca55bc6b028cf84">More...</a><br/></td></tr>
<tr class="separator:afc836f381a720b218ca55bc6b028cf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5020e8dcf05355ccf765df1a69f1303d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a5020e8dcf05355ccf765df1a69f1303d">set_period_mode</a> (short mode)</td></tr>
<tr class="memdesc:a5020e8dcf05355ccf765df1a69f1303d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets the way the periodicity is calculated.  <a href="#a5020e8dcf05355ccf765df1a69f1303d">More...</a><br/></td></tr>
<tr class="separator:a5020e8dcf05355ccf765df1a69f1303d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb61a855237116da9123c8cc0f4ee035"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb61a855237116da9123c8cc0f4ee035"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#acb61a855237116da9123c8cc0f4ee035">set_name</a> (string <a class="el" href="class_l_s_d_raster_model.html#a9471043d3cb80318abe82e383b2ddb4c">name</a>)</td></tr>
<tr class="memdesc:acb61a855237116da9123c8cc0f4ee035"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the name of the model run <br/></td></tr>
<tr class="separator:acb61a855237116da9123c8cc0f4ee035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fc9453b6d25dc3d591c80b94527d25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94fc9453b6d25dc3d591c80b94527d25"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a94fc9453b6d25dc3d591c80b94527d25">set_report_name</a> (string <a class="el" href="class_l_s_d_raster_model.html#a9471043d3cb80318abe82e383b2ddb4c">name</a>)</td></tr>
<tr class="memdesc:a94fc9453b6d25dc3d591c80b94527d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the name of the report <br/></td></tr>
<tr class="separator:a94fc9453b6d25dc3d591c80b94527d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b724dbcc4c72449d29a00aa3cbd8c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69b724dbcc4c72449d29a00aa3cbd8c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a69b724dbcc4c72449d29a00aa3cbd8c2">set_current_frame</a> (int new_frame)</td></tr>
<tr class="memdesc:a69b724dbcc4c72449d29a00aa3cbd8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">set current frame, this is used for printing <br/></td></tr>
<tr class="separator:a69b724dbcc4c72449d29a00aa3cbd8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c868786f69ddd623fed2eef3f7be2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45c868786f69ddd623fed2eef3f7be2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a45c868786f69ddd623fed2eef3f7be2f">force_initial_steady_state</a> ()</td></tr>
<tr class="memdesc:a45c868786f69ddd623fed2eef3f7be2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">this just sets the initial steady state to true so that the periodic functions can be run from a starting DEM It also forces the time delay ans switch delay so periodic functions start straight away <br/></td></tr>
<tr class="separator:a45c868786f69ddd623fed2eef3f7be2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337eae43f827a0319aecbfd8fcf6e400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a337eae43f827a0319aecbfd8fcf6e400">set_fluvial</a> (bool on_status)</td></tr>
<tr class="memdesc:a337eae43f827a0319aecbfd8fcf6e400"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the fluvial switch  <a href="#a337eae43f827a0319aecbfd8fcf6e400">More...</a><br/></td></tr>
<tr class="separator:a337eae43f827a0319aecbfd8fcf6e400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46569ec3e4fcca5cea926599be43e212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a46569ec3e4fcca5cea926599be43e212">set_hillslope</a> (bool on_status)</td></tr>
<tr class="memdesc:a46569ec3e4fcca5cea926599be43e212"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the hillslop switch  <a href="#a46569ec3e4fcca5cea926599be43e212">More...</a><br/></td></tr>
<tr class="separator:a46569ec3e4fcca5cea926599be43e212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffe213ca2f8d0b9b58a0cff9ff44dba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aeffe213ca2f8d0b9b58a0cff9ff44dba">set_nonlinear</a> (bool on_status)</td></tr>
<tr class="memdesc:aeffe213ca2f8d0b9b58a0cff9ff44dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the hillslop linear or nonlinear switch  <a href="#aeffe213ca2f8d0b9b58a0cff9ff44dba">More...</a><br/></td></tr>
<tr class="separator:aeffe213ca2f8d0b9b58a0cff9ff44dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fac7642cb3346c3df7cde4c548be1bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a2fac7642cb3346c3df7cde4c548be1bf">set_isostasy</a> (bool on_status)</td></tr>
<tr class="memdesc:a2fac7642cb3346c3df7cde4c548be1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the isostacy switch  <a href="#a2fac7642cb3346c3df7cde4c548be1bf">More...</a><br/></td></tr>
<tr class="separator:a2fac7642cb3346c3df7cde4c548be1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b50dbd1d9c07eee0910bd67124df67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a23b50dbd1d9c07eee0910bd67124df67">set_flexure</a> (bool on_status)</td></tr>
<tr class="memdesc:a23b50dbd1d9c07eee0910bd67124df67"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the flexure switch  <a href="#a23b50dbd1d9c07eee0910bd67124df67">More...</a><br/></td></tr>
<tr class="separator:a23b50dbd1d9c07eee0910bd67124df67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759863062a5daffab113ca1d00b5128f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a759863062a5daffab113ca1d00b5128f">set_quiet</a> (bool on_status)</td></tr>
<tr class="memdesc:a759863062a5daffab113ca1d00b5128f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the quiet switch  <a href="#a759863062a5daffab113ca1d00b5128f">More...</a><br/></td></tr>
<tr class="separator:a759863062a5daffab113ca1d00b5128f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ebb0cb0164765c5e9333951968c425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a39ebb0cb0164765c5e9333951968c425">set_print_elevation</a> (bool do_I_print_elevation)</td></tr>
<tr class="memdesc:a39ebb0cb0164765c5e9333951968c425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the print elevation.  <a href="#a39ebb0cb0164765c5e9333951968c425">More...</a><br/></td></tr>
<tr class="separator:a39ebb0cb0164765c5e9333951968c425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26f5466015d345dbf5b6e1fb12974aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aa26f5466015d345dbf5b6e1fb12974aa">set_print_hillshade</a> (bool do_I_print_hillshade)</td></tr>
<tr class="memdesc:aa26f5466015d345dbf5b6e1fb12974aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the print hillshade.  <a href="#aa26f5466015d345dbf5b6e1fb12974aa">More...</a><br/></td></tr>
<tr class="separator:aa26f5466015d345dbf5b6e1fb12974aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299fadc81b5955f203422370fed44fcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a299fadc81b5955f203422370fed44fcd">set_print_erosion</a> (bool do_I_print_erosion)</td></tr>
<tr class="memdesc:a299fadc81b5955f203422370fed44fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the print erosion.  <a href="#a299fadc81b5955f203422370fed44fcd">More...</a><br/></td></tr>
<tr class="separator:a299fadc81b5955f203422370fed44fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfae5bb8d844157a604d3a384886542"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a2cfae5bb8d844157a604d3a384886542">get_name</a> (void)</td></tr>
<tr class="memdesc:a2cfae5bb8d844157a604d3a384886542"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the name of the model run from the data members  <a href="#a2cfae5bb8d844157a604d3a384886542">More...</a><br/></td></tr>
<tr class="separator:a2cfae5bb8d844157a604d3a384886542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb071b3d18b9f814a7b86dcef0509ab0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#abb071b3d18b9f814a7b86dcef0509ab0">get_K</a> (void)</td></tr>
<tr class="memdesc:abb071b3d18b9f814a7b86dcef0509ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the fluvial erodability. It has a number of switches that determine how K is calcualted. K_mode == 1 sine wave K_mode == 2 square wave K_mode == 3 read from file K_mode: default is constant value.  <a href="#abb071b3d18b9f814a7b86dcef0509ab0">More...</a><br/></td></tr>
<tr class="separator:abb071b3d18b9f814a7b86dcef0509ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028144c488e456bedc8431f4b9370a47"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a028144c488e456bedc8431f4b9370a47">get_D</a> (void)</td></tr>
<tr class="memdesc:a028144c488e456bedc8431f4b9370a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the soil transport coefficient erodability. It has a number of switches that determine how D is calculated. D_mode == 1 sine wave D_mode == 2 square wave D_mode == 3 read from file D_mode: default is constant value.  <a href="#a028144c488e456bedc8431f4b9370a47">More...</a><br/></td></tr>
<tr class="separator:a028144c488e456bedc8431f4b9370a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567605b74fe84a36e1de90a350faefd0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a567605b74fe84a36e1de90a350faefd0">get_m</a> (void)</td></tr>
<tr class="memdesc:a567605b74fe84a36e1de90a350faefd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area exponent.  <a href="#a567605b74fe84a36e1de90a350faefd0">More...</a><br/></td></tr>
<tr class="separator:a567605b74fe84a36e1de90a350faefd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f1a0645a4f6e1df36208084e657731"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a80f1a0645a4f6e1df36208084e657731">get_n</a> (void)</td></tr>
<tr class="memdesc:a80f1a0645a4f6e1df36208084e657731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the slope exponent.  <a href="#a80f1a0645a4f6e1df36208084e657731">More...</a><br/></td></tr>
<tr class="separator:a80f1a0645a4f6e1df36208084e657731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa7de8e8637f04fc9b853bdc76dca76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fa7de8e8637f04fc9b853bdc76dca76"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a6fa7de8e8637f04fc9b853bdc76dca76">get_current_time</a> (void)</td></tr>
<tr class="memdesc:a6fa7de8e8637f04fc9b853bdc76dca76"><td class="mdescLeft">&#160;</td><td class="mdescRight">this gets the current_time <br/></td></tr>
<tr class="separator:a6fa7de8e8637f04fc9b853bdc76dca76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39769153df7f3bb278c58c29ff80e09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa39769153df7f3bb278c58c29ff80e09"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aa39769153df7f3bb278c58c29ff80e09">get_endTime</a> (void)</td></tr>
<tr class="memdesc:aa39769153df7f3bb278c58c29ff80e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">this gets the endTime <br/></td></tr>
<tr class="separator:aa39769153df7f3bb278c58c29ff80e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15992e61d9877dd43109b16dbae37ab4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15992e61d9877dd43109b16dbae37ab4"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a15992e61d9877dd43109b16dbae37ab4">get_timeStep</a> (void)</td></tr>
<tr class="memdesc:a15992e61d9877dd43109b16dbae37ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the timestep. <br/></td></tr>
<tr class="separator:a15992e61d9877dd43109b16dbae37ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93053935c79242a09611e5bde93c7ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad93053935c79242a09611e5bde93c7ed"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ad93053935c79242a09611e5bde93c7ed">get_maxtimeStep</a> (void)</td></tr>
<tr class="memdesc:ad93053935c79242a09611e5bde93c7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum timestep. <br/></td></tr>
<tr class="separator:ad93053935c79242a09611e5bde93c7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70e96d475c323f643b554c43b31f552"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab70e96d475c323f643b554c43b31f552"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab70e96d475c323f643b554c43b31f552">get_current_frame</a> (void)</td></tr>
<tr class="memdesc:ab70e96d475c323f643b554c43b31f552"><td class="mdescLeft">&#160;</td><td class="mdescRight">this gets the current frame for printing <br/></td></tr>
<tr class="separator:ab70e96d475c323f643b554c43b31f552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759bce699461c52906531bf363bd2dc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a759bce699461c52906531bf363bd2dc9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a759bce699461c52906531bf363bd2dc9">get_uplift_mode</a> (void)</td></tr>
<tr class="memdesc:a759bce699461c52906531bf363bd2dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the uplift mode <br/></td></tr>
<tr class="separator:a759bce699461c52906531bf363bd2dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4477dc73fd3b0b50d241133f2b3bd227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a4477dc73fd3b0b50d241133f2b3bd227">write_report</a> (void)</td></tr>
<tr class="memdesc:a4477dc73fd3b0b50d241133f2b3bd227"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method calculates some features of the landscape at set times. The frequency of the reports are set by the data member report_delay One of the things it does is calculates erosion rates, and stores this as a data member.  <a href="#a4477dc73fd3b0b50d241133f2b3bd227">More...</a><br/></td></tr>
<tr class="separator:a4477dc73fd3b0b50d241133f2b3bd227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790599317823cfe42e59e51ddd7798c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a790599317823cfe42e59e51ddd7798c7">print_parameters</a> (void)</td></tr>
<tr class="memdesc:a790599317823cfe42e59e51ddd7798c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">this prints parameters to screen  <a href="#a790599317823cfe42e59e51ddd7798c7">More...</a><br/></td></tr>
<tr class="separator:a790599317823cfe42e59e51ddd7798c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab735eebfabfe689f7d6bb24f1ea4bcbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab735eebfabfe689f7d6bb24f1ea4bcbc">cycle_report</a> (float, float, float)</td></tr>
<tr class="memdesc:ab735eebfabfe689f7d6bb24f1ea4bcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">this prints a file about what has happened over a cycle  <a href="#ab735eebfabfe689f7d6bb24f1ea4bcbc">More...</a><br/></td></tr>
<tr class="separator:ab735eebfabfe689f7d6bb24f1ea4bcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad3ae2130aeecb5b593de765adb14f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a3ad3ae2130aeecb5b593de765adb14f7">final_report</a> (void)</td></tr>
<tr class="memdesc:a3ad3ae2130aeecb5b593de765adb14f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">this prints a final report (SMML not sure what is in the final report)  <a href="#a3ad3ae2130aeecb5b593de765adb14f7">More...</a><br/></td></tr>
<tr class="separator:a3ad3ae2130aeecb5b593de765adb14f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d98f6e0c5a3f4404165e0ea1990d188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a0d98f6e0c5a3f4404165e0ea1990d188">print_rasters</a> (int frame_num)</td></tr>
<tr class="memdesc:a0d98f6e0c5a3f4404165e0ea1990d188"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints a series of rasters. The rasters printed depend on the switches print_elevation, print_erosion, print_erosion_cycle, print_hillshade; and print_slope_area The filename inculdes the frame_num.  <a href="#a0d98f6e0c5a3f4404165e0ea1990d188">More...</a><br/></td></tr>
<tr class="separator:a0d98f6e0c5a3f4404165e0ea1990d188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d55cc1fa59b93d3c54490631605e58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ac8d55cc1fa59b93d3c54490631605e58">print_rasters_and_csv</a> (int frame)</td></tr>
<tr class="memdesc:ac8d55cc1fa59b93d3c54490631605e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints a series of rasters. The rasters printed depend on the switches print_elevation, print_erosion, print_erosion_cycle, print_hillshade; and print_slope_area The filename inculdes the frame_num It also prints a csv of the model info which can be ingested by pandas for visualisation.  <a href="#ac8d55cc1fa59b93d3c54490631605e58">More...</a><br/></td></tr>
<tr class="separator:ac8d55cc1fa59b93d3c54490631605e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af428a8244abd07a47f07927d6b1ca82e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#af428a8244abd07a47f07927d6b1ca82e">print_average_erosion_and_apparent_erosion</a> (int frame, vector&lt; <a class="el" href="class_l_s_d_particle_column.html">LSDParticleColumn</a> &gt; &amp;CRNColumns, <a class="el" href="class_l_s_d_c_r_n_parameters.html">LSDCRNParameters</a> &amp;CRNParams)</td></tr>
<tr class="memdesc:af428a8244abd07a47f07927d6b1ca82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the apparent cosmogenic rates from a collection of <a class="el" href="class_l_s_d_particle.html" title="This is a class for a particle that can be tracked through simulations and retains data about positio...">LSDParticle</a> Columns  This function opens a file if none exists.  <a href="#af428a8244abd07a47f07927d6b1ca82e">More...</a><br/></td></tr>
<tr class="separator:af428a8244abd07a47f07927d6b1ca82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f65004ec63ad9b41a35f110e8fe67c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a85f65004ec63ad9b41a35f110e8fe67c">print_column_erosion_and_apparent_erosion</a> (int frame, vector&lt; <a class="el" href="class_l_s_d_particle_column.html">LSDParticleColumn</a> &gt; &amp;CRNColumns, <a class="el" href="class_l_s_d_c_r_n_parameters.html">LSDCRNParameters</a> &amp;CRNParams)</td></tr>
<tr class="memdesc:a85f65004ec63ad9b41a35f110e8fe67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the apparent cosmogenic rates from individual <a class="el" href="class_l_s_d_particle.html" title="This is a class for a particle that can be tracked through simulations and retains data about positio...">LSDParticle</a> Columns  This function opens a file if none exists.  <a href="#a85f65004ec63ad9b41a35f110e8fe67c">More...</a><br/></td></tr>
<tr class="separator:a85f65004ec63ad9b41a35f110e8fe67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa354efe4967bbbcd2f5d5870586ded8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aa354efe4967bbbcd2f5d5870586ded8a">close_static_outfiles</a> ()</td></tr>
<tr class="memdesc:aa354efe4967bbbcd2f5d5870586ded8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function closes some static outfiles used for printing.  <a href="#aa354efe4967bbbcd2f5d5870586ded8a">More...</a><br/></td></tr>
<tr class="separator:aa354efe4967bbbcd2f5d5870586ded8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23e1f841dc90f503e0947368f58ae6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aa23e1f841dc90f503e0947368f58ae6b">slope_area_data</a> (string <a class="el" href="class_l_s_d_raster_model.html#a9471043d3cb80318abe82e383b2ddb4c">name</a>)</td></tr>
<tr class="memdesc:aa23e1f841dc90f503e0947368f58ae6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print slope area data Probably fits better into <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>, but requires <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a>.  <a href="#aa23e1f841dc90f503e0947368f58ae6b">More...</a><br/></td></tr>
<tr class="separator:aa23e1f841dc90f503e0947368f58ae6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650308748f24f78ebbee77858ddcf192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a650308748f24f78ebbee77858ddcf192">slope_area_data</a> (string <a class="el" href="class_l_s_d_raster_model.html#a9471043d3cb80318abe82e383b2ddb4c">name</a>, int slope_flag, int area_flag)</td></tr>
<tr class="memdesc:a650308748f24f78ebbee77858ddcf192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print slope area data This is an overloaded function that calcualtes slope area data based on flags. There are two flag, one for the slope calculation and one for the area calculation.  <a href="#a650308748f24f78ebbee77858ddcf192">More...</a><br/></td></tr>
<tr class="separator:a650308748f24f78ebbee77858ddcf192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4e51173669b002d3a63467810401d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a7d4e51173669b002d3a63467810401d1">make_template_param_file</a> (string filename)</td></tr>
<tr class="memdesc:a7d4e51173669b002d3a63467810401d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a template of a parameter file to be supplied to the model.  <a href="#a7d4e51173669b002d3a63467810401d1">More...</a><br/></td></tr>
<tr class="separator:a7d4e51173669b002d3a63467810401d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af0ea7133d7af8a3e4fc45b797e409b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a9af0ea7133d7af8a3e4fc45b797e409b">MuddPILE_initiate_assembler_matrix</a> (void)</td></tr>
<tr class="memdesc:a9af0ea7133d7af8a3e4fc45b797e409b"><td class="mdescLeft">&#160;</td><td class="mdescRight">this initiates some parameters for the assembler matrix it is required before running any further calculations for the nonlinear solver  <a href="#a9af0ea7133d7af8a3e4fc45b797e409b">More...</a><br/></td></tr>
<tr class="separator:a9af0ea7133d7af8a3e4fc45b797e409b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b66e5a49f91f618ebfd2403f09e94b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a9b66e5a49f91f618ebfd2403f09e94b5">MuddPILE_calculate_k_values_for_assembly_matrix</a> (void)</td></tr>
<tr class="memdesc:a9b66e5a49f91f618ebfd2403f09e94b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">this initiates some parameters for the assembler matrix it is required before running any further calculations for the nonlinear solver  <a href="#a9b66e5a49f91f618ebfd2403f09e94b5">More...</a><br/></td></tr>
<tr class="separator:a9b66e5a49f91f618ebfd2403f09e94b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c9b142f87ccf133fa8fb9b3676b41a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a09c9b142f87ccf133fa8fb9b3676b41a">MuddPILE_assemble_matrix</a> (Array2D&lt; float &gt; &amp;uplift_rate, Array2D&lt; float &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#abea4c2a6f4958b9c92a0905a5adad6a4">fluvial_erosion_rate</a>, mtl::compressed2D&lt; float &gt; &amp;mtl_Assembly_matrix, mtl::dense_vector&lt; float &gt; &amp;mtl_b_vector)</td></tr>
<tr class="memdesc:a09c9b142f87ccf133fa8fb9b3676b41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">this assembles the sparse matrix that must then be solved to get the next iteration of the hillslope elevations  <a href="#a09c9b142f87ccf133fa8fb9b3676b41a">More...</a><br/></td></tr>
<tr class="separator:a09c9b142f87ccf133fa8fb9b3676b41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a6a08dd4cb9e4525f61fa42975566d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab0a6a08dd4cb9e4525f61fa42975566d">MuddPILE_solve_assembler_matrix</a> (Array2D&lt; float &gt; &amp;uplift_rate, Array2D&lt; float &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#abea4c2a6f4958b9c92a0905a5adad6a4">fluvial_erosion_rate</a>)</td></tr>
<tr class="memdesc:ab0a6a08dd4cb9e4525f61fa42975566d"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function solves the assembled matrix for the nonlinear hillslope sediment flux law. The implementation calls MuddPILE_assemble_matrix.  <a href="#ab0a6a08dd4cb9e4525f61fa42975566d">More...</a><br/></td></tr>
<tr class="separator:ab0a6a08dd4cb9e4525f61fa42975566d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0869cf030684a1021c2214e523aebd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a5c0869cf030684a1021c2214e523aebd">MuddPILE_nonlinear_creep_timestep</a> (Array2D&lt; float &gt; &amp;uplift_rate, Array2D&lt; float &gt; &amp;<a class="el" href="class_l_s_d_raster_model.html#abea4c2a6f4958b9c92a0905a5adad6a4">fluvial_erosion_rate</a>, float iteration_tolerance)</td></tr>
<tr class="memdesc:a5c0869cf030684a1021c2214e523aebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This runs one timestep of the nonlinear sediment flux law It replaces the data in RasterData.  <a href="#a5c0869cf030684a1021c2214e523aebd">More...</a><br/></td></tr>
<tr class="separator:a5c0869cf030684a1021c2214e523aebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3d08a706de097ca698272835f2c687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a3f3d08a706de097ca698272835f2c687">MuddPILE_nl_soil_diffusion_nouplift</a> ()</td></tr>
<tr class="memdesc:a3f3d08a706de097ca698272835f2c687"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of the MuddPILE nonlinear solver does not include uplift and uses a default iteration tolerance of 1e-7. It is built to integrate with JAJ's 'run_components' module.  <a href="#a3f3d08a706de097ca698272835f2c687">More...</a><br/></td></tr>
<tr class="separator:a3f3d08a706de097ca698272835f2c687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b305ebdc386eb856ee32990e405c04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a14b305ebdc386eb856ee32990e405c04">get_NRows</a> () const </td></tr>
<tr class="separator:a14b305ebdc386eb856ee32990e405c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b247191f214206be56ed7f03697c505"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a6b247191f214206be56ed7f03697c505">get_NCols</a> () const </td></tr>
<tr class="separator:a6b247191f214206be56ed7f03697c505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_l_s_d_raster_spectral"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_l_s_d_raster_spectral')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_l_s_d_raster_spectral.html">LSDRasterSpectral</a></td></tr>
<tr class="memitem:a9782138d8ad64347e4656fef612a1fb7 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a9782138d8ad64347e4656fef612a1fb7">LSDRasterSpectral</a> (string filename, string extension)</td></tr>
<tr class="memdesc:a9782138d8ad64347e4656fef612a1fb7 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_l_s_d_raster_spectral.html" title="This object performs spectral analysis. ">LSDRasterSpectral</a> from a file. Uses a filename and file extension.  <a href="#a9782138d8ad64347e4656fef612a1fb7">More...</a><br/></td></tr>
<tr class="separator:a9782138d8ad64347e4656fef612a1fb7 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae881c1b69db683f506298eedee4330f4 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#ae881c1b69db683f506298eedee4330f4">LSDRasterSpectral</a> (int nrows, int ncols, float xmin, float ymin, float cellsize, float ndv, Array2D&lt; float &gt; data)</td></tr>
<tr class="memdesc:ae881c1b69db683f506298eedee4330f4 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_l_s_d_raster_spectral.html" title="This object performs spectral analysis. ">LSDRasterSpectral</a> from memory.  <a href="#ae881c1b69db683f506298eedee4330f4">More...</a><br/></td></tr>
<tr class="separator:ae881c1b69db683f506298eedee4330f4 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f22d9175496e09d8ea2d44b63758ea inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a74f22d9175496e09d8ea2d44b63758ea">LSDRasterSpectral</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;An_LSDRaster)</td></tr>
<tr class="memdesc:a74f22d9175496e09d8ea2d44b63758ea inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_l_s_d_raster_spectral.html" title="This object performs spectral analysis. ">LSDRasterSpectral</a> from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object.  <a href="#a74f22d9175496e09d8ea2d44b63758ea">More...</a><br/></td></tr>
<tr class="separator:a74f22d9175496e09d8ea2d44b63758ea inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1cd441a633b36e3580560ff481260d inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#aef1cd441a633b36e3580560ff481260d">LSDRasterSpectral</a> (int raster_order, float cellsize, float ndv)</td></tr>
<tr class="memdesc:aef1cd441a633b36e3580560ff481260d inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_l_s_d_raster_spectral.html" title="This object performs spectral analysis. ">LSDRasterSpectral</a> object that has dimensions 2^raster_order.  <a href="#aef1cd441a633b36e3580560ff481260d">More...</a><br/></td></tr>
<tr class="separator:aef1cd441a633b36e3580560ff481260d inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1387f0c971f227e0ad546606046c07 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c1387f0c971f227e0ad546606046c07"></a>
<a class="el" href="class_l_s_d_raster_spectral.html">LSDRasterSpectral</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a2c1387f0c971f227e0ad546606046c07">operator=</a> (const <a class="el" href="class_l_s_d_raster_spectral.html">LSDRasterSpectral</a> &amp;LSDR)</td></tr>
<tr class="memdesc:a2c1387f0c971f227e0ad546606046c07 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr class="separator:a2c1387f0c971f227e0ad546606046c07 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f31998663185a5a529abef6ba9fc34 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a26f31998663185a5a529abef6ba9fc34">get_row_direction_frequencies_unshifted</a> ()</td></tr>
<tr class="memdesc:a26f31998663185a5a529abef6ba9fc34 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the frequency values of an UNSHIFTED DFT along the rows.  <a href="#a26f31998663185a5a529abef6ba9fc34">More...</a><br/></td></tr>
<tr class="separator:a26f31998663185a5a529abef6ba9fc34 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644439e82d5c9cf38f51ec55442ac70a inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a644439e82d5c9cf38f51ec55442ac70a">get_col_direction_frequencies_unshifted</a> ()</td></tr>
<tr class="memdesc:a644439e82d5c9cf38f51ec55442ac70a inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the frequency values of an UNSHIFTED DFT along the columns.  <a href="#a644439e82d5c9cf38f51ec55442ac70a">More...</a><br/></td></tr>
<tr class="separator:a644439e82d5c9cf38f51ec55442ac70a inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7c348705e7807fe73bc475043d4692 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#abf7c348705e7807fe73bc475043d4692">get_frequency_scaling_array</a> (float beta)</td></tr>
<tr class="memdesc:abf7c348705e7807fe73bc475043d4692 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">This calucaltes a scaling array for scaling an unshifted DFT by the factor 1/f^beta.  <a href="#abf7c348705e7807fe73bc475043d4692">More...</a><br/></td></tr>
<tr class="separator:abf7c348705e7807fe73bc475043d4692 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5407be6979072cef68b8c359a2be7801 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a5407be6979072cef68b8c359a2be7801">generate_fractal_surface_spectral_method</a> (float beta)</td></tr>
<tr class="memdesc:a5407be6979072cef68b8c359a2be7801 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">This creates a fractal surface using the spectral method.  <a href="#a5407be6979072cef68b8c359a2be7801">More...</a><br/></td></tr>
<tr class="separator:a5407be6979072cef68b8c359a2be7801 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3aeeb6d0d009cf164038456c735f59 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a4a3aeeb6d0d009cf164038456c735f59">generate_fractal_surface_spectral_method</a> (float beta, float desired_relief)</td></tr>
<tr class="memdesc:a4a3aeeb6d0d009cf164038456c735f59 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">This creates a fractal surface using the spectral method.  <a href="#a4a3aeeb6d0d009cf164038456c735f59">More...</a><br/></td></tr>
<tr class="separator:a4a3aeeb6d0d009cf164038456c735f59 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb56404116ccd02bd6711129ad063b2c inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#abb56404116ccd02bd6711129ad063b2c">find_rollover_frequency</a> (float &amp;rollover_frequency, float &amp;rollover_beta, float &amp;sub_rollover_beta, float log_bin_width)</td></tr>
<tr class="memdesc:abb56404116ccd02bd6711129ad063b2c inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">FINDS ROLLOVER FREQUENCY.  <a href="#abb56404116ccd02bd6711129ad063b2c">More...</a><br/></td></tr>
<tr class="separator:abb56404116ccd02bd6711129ad063b2c inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0b7dd8087b85bc251c9add0ae96ed5 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a7e0b7dd8087b85bc251c9add0ae96ed5">calculate_background_spectrum</a> (float rollover_frequency, float beta, float log_bin_width, int N_iterations, int window_option=0)</td></tr>
<tr class="memdesc:a7e0b7dd8087b85bc251c9add0ae96ed5 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">CALCULATE BACKGROUND SPECTRUM.  <a href="#a7e0b7dd8087b85bc251c9add0ae96ed5">More...</a><br/></td></tr>
<tr class="separator:a7e0b7dd8087b85bc251c9add0ae96ed5 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6668fb74e205e8d6f99e06081995a661 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a6668fb74e205e8d6f99e06081995a661">dfftw2D_fwd</a> (Array2D&lt; float &gt; &amp;InputArray, Array2D&lt; float &gt; &amp;OutputArrayReal, Array2D&lt; float &gt; &amp;OutputArrayImaginary, int transform_direction)</td></tr>
<tr class="memdesc:a6668fb74e205e8d6f99e06081995a661 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the forward fast fourier transform of a 2D discrete dataset.  <a href="#a6668fb74e205e8d6f99e06081995a661">More...</a><br/></td></tr>
<tr class="separator:a6668fb74e205e8d6f99e06081995a661 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8334a5ea8f97e2586c06b8131ac54b7 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#ae8334a5ea8f97e2586c06b8131ac54b7">dfftw2D_inv</a> (Array2D&lt; float &gt; &amp;InputArrayReal, Array2D&lt; float &gt; &amp;InputArrayImaginary, Array2D&lt; float &gt; &amp;OutputArray, int transform_direction)</td></tr>
<tr class="memdesc:ae8334a5ea8f97e2586c06b8131ac54b7 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse fast fourier transform of a 2D discrete dataset.  <a href="#ae8334a5ea8f97e2586c06b8131ac54b7">More...</a><br/></td></tr>
<tr class="separator:ae8334a5ea8f97e2586c06b8131ac54b7 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7699d7310643c07bbcb8d2a7ab236ca7 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a7699d7310643c07bbcb8d2a7ab236ca7">dfftw2D_inv_complex</a> (Array2D&lt; complex&lt; float &gt; &gt; &amp;InputArrayComplex, Array2D&lt; float &gt; &amp;OutputArray, int transform_direction)</td></tr>
<tr class="memdesc:a7699d7310643c07bbcb8d2a7ab236ca7 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse fast fourier transform of a 2D discrete dataset.  <a href="#a7699d7310643c07bbcb8d2a7ab236ca7">More...</a><br/></td></tr>
<tr class="separator:a7699d7310643c07bbcb8d2a7ab236ca7 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f67805ff0686c6df15f08cc8e3e747 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#ae0f67805ff0686c6df15f08cc8e3e747">detrend2D</a> (Array2D&lt; float &gt; &amp;zeta, Array2D&lt; float &gt; &amp;zeta_detrend, Array2D&lt; float &gt; &amp;trend_plane)</td></tr>
<tr class="memdesc:ae0f67805ff0686c6df15f08cc8e3e747 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detrend Data.  <a href="#ae0f67805ff0686c6df15f08cc8e3e747">More...</a><br/></td></tr>
<tr class="separator:ae0f67805ff0686c6df15f08cc8e3e747 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7e32943af07444d6146439254e3495 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#aaf7e32943af07444d6146439254e3495">window_data_Hann2D</a> (Array2D&lt; float &gt; &amp;zeta_detrend, Array2D&lt; float &gt; &amp;zeta_Hann2D, Array2D&lt; float &gt; &amp;Hann2D)</td></tr>
<tr class="memdesc:aaf7e32943af07444d6146439254e3495 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hann Window Module.  <a href="#aaf7e32943af07444d6146439254e3495">More...</a><br/></td></tr>
<tr class="separator:aaf7e32943af07444d6146439254e3495 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdca205246b55819d43fc6255e7e689a inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#abdca205246b55819d43fc6255e7e689a">window_data_Hamming2D</a> (Array2D&lt; float &gt; &amp;zeta_detrend, Array2D&lt; float &gt; &amp;zeta_Hamming2D, Array2D&lt; float &gt; &amp;Hamming2D)</td></tr>
<tr class="memdesc:abdca205246b55819d43fc6255e7e689a inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hamming Window Module.  <a href="#abdca205246b55819d43fc6255e7e689a">More...</a><br/></td></tr>
<tr class="separator:abdca205246b55819d43fc6255e7e689a inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6233b3200a14ec775ac832a700d20c inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a9d6233b3200a14ec775ac832a700d20c">window_data</a> (Array2D&lt; float &gt; &amp;input, Array2D&lt; float &gt; &amp;output, Array2D&lt; float &gt; &amp;window, int window_option=0)</td></tr>
<tr class="memdesc:a9d6233b3200a14ec775ac832a700d20c inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=REDUNDANT=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-  <a href="#a9d6233b3200a14ec775ac832a700d20c">More...</a><br/></td></tr>
<tr class="separator:a9d6233b3200a14ec775ac832a700d20c inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4ec2de75b1a2c5070e655290a04330 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a0c4ec2de75b1a2c5070e655290a04330">shift_spectrum</a> (Array2D&lt; float &gt; &amp;spectrum_real, Array2D&lt; float &gt; &amp;spectrum_imaginary, Array2D&lt; float &gt; &amp;spectrum_real_shift, Array2D&lt; float &gt; &amp;spectrum_imaginary_shift)</td></tr>
<tr class="memdesc:a0c4ec2de75b1a2c5070e655290a04330 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHIFT ORIGIN OF SPECTRUM IN FOURIER DOMAIN.  <a href="#a0c4ec2de75b1a2c5070e655290a04330">More...</a><br/></td></tr>
<tr class="separator:a0c4ec2de75b1a2c5070e655290a04330 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4747e6e8ee463c89b9762c4ce7a016dc inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a4747e6e8ee463c89b9762c4ce7a016dc">shift_spectrum</a> (Array2D&lt; float &gt; &amp;spectrum_real, Array2D&lt; float &gt; &amp;spectrum_imaginary)</td></tr>
<tr class="memdesc:a4747e6e8ee463c89b9762c4ce7a016dc inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHIFT ORIGIN OF SPECTRUM IN FOURIER DOMAIN.  <a href="#a4747e6e8ee463c89b9762c4ce7a016dc">More...</a><br/></td></tr>
<tr class="separator:a4747e6e8ee463c89b9762c4ce7a016dc inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51475419e7eeb95c3bacbab7d162d879 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a51475419e7eeb95c3bacbab7d162d879">shift_spectrum_inv</a> (Array2D&lt; float &gt; &amp;FilteredSpectrumReal, Array2D&lt; float &gt; &amp;FilteredSpectrumImaginary, Array2D&lt; float &gt; &amp;FilteredSpectrumReal_deshift, Array2D&lt; float &gt; &amp;FilteredSpectrumImaginary_deshift)</td></tr>
<tr class="memdesc:a51475419e7eeb95c3bacbab7d162d879 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">DE-SHIFT ORIGIN OF SPECTRUM.  <a href="#a51475419e7eeb95c3bacbab7d162d879">More...</a><br/></td></tr>
<tr class="separator:a51475419e7eeb95c3bacbab7d162d879 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a403bbe5c81b98d67f409e4bfa1a91 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a47a403bbe5c81b98d67f409e4bfa1a91">shift_spectrum_inv</a> (Array2D&lt; float &gt; &amp;spectrum_real, Array2D&lt; float &gt; &amp;spectrum_imaginary)</td></tr>
<tr class="memdesc:a47a403bbe5c81b98d67f409e4bfa1a91 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">DE-SHIFT ORIGIN OF SPECTRUM.  <a href="#a47a403bbe5c81b98d67f409e4bfa1a91">More...</a><br/></td></tr>
<tr class="separator:a47a403bbe5c81b98d67f409e4bfa1a91 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd648ed3b8896f6c02b9a07fbdb6b60 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a4fd648ed3b8896f6c02b9a07fbdb6b60">calculate_2D_PSD</a> (Array2D&lt; float &gt; &amp;spectrum_real_shift, Array2D&lt; float &gt; &amp;spectrum_imaginary_shift)</td></tr>
<tr class="memdesc:a4fd648ed3b8896f6c02b9a07fbdb6b60 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">CALCULATE THE DFT PERIODOGRAM.  <a href="#a4fd648ed3b8896f6c02b9a07fbdb6b60">More...</a><br/></td></tr>
<tr class="separator:a4fd648ed3b8896f6c02b9a07fbdb6b60 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ceb58ecb4053c16d7668cbb00300c1 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#ae6ceb58ecb4053c16d7668cbb00300c1">scale_spectrum</a> (Array2D&lt; float &gt; SpectrumReal, Array2D&lt; float &gt; SpectrumIm, float beta)</td></tr>
<tr class="memdesc:ae6ceb58ecb4053c16d7668cbb00300c1 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCALE SPECTRUM.  <a href="#ae6ceb58ecb4053c16d7668cbb00300c1">More...</a><br/></td></tr>
<tr class="separator:ae6ceb58ecb4053c16d7668cbb00300c1 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce4635ee5fbc27fe0a23c22afa0c557 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a4ce4635ee5fbc27fe0a23c22afa0c557">calculate_radial_PSD</a> ()</td></tr>
<tr class="memdesc:a4ce4635ee5fbc27fe0a23c22afa0c557 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">GET RADIAL POWER SPECTRUM.  <a href="#a4ce4635ee5fbc27fe0a23c22afa0c557">More...</a><br/></td></tr>
<tr class="separator:a4ce4635ee5fbc27fe0a23c22afa0c557 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefca49bbf118cbb045871e8cf105c935 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#aefca49bbf118cbb045871e8cf105c935">fftw2D_spectral_analysis</a> (char *file_id, float LogBinWidth)</td></tr>
<tr class="memdesc:aefca49bbf118cbb045871e8cf105c935 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">COMPUTE DISCRETE FAST FOURIER TRANSFORM OF A REAL, 2-DIMENSIONAL DATASET.  <a href="#aefca49bbf118cbb045871e8cf105c935">More...</a><br/></td></tr>
<tr class="separator:aefca49bbf118cbb045871e8cf105c935 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c72e77b3fd32c7871e2c962b80b5bf8 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a2c72e77b3fd32c7871e2c962b80b5bf8">full_spectral_analysis</a> (float log_bin_width, int N_iterations, int window_option=0)</td></tr>
<tr class="memdesc:a2c72e77b3fd32c7871e2c962b80b5bf8 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">FULL SPECTRAL ANALYSIS.  <a href="#a2c72e77b3fd32c7871e2c962b80b5bf8">More...</a><br/></td></tr>
<tr class="separator:a2c72e77b3fd32c7871e2c962b80b5bf8 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb20aaf48027861742eea4d62c3374ae inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#afb20aaf48027861742eea4d62c3374ae">bandpass_filter</a> (Array2D&lt; float &gt; &amp;RawSpectrumReal, Array2D&lt; float &gt; &amp;RawSpectrumImaginary, Array2D&lt; float &gt; &amp;FilteredSpectrumReal, Array2D&lt; float &gt; &amp;FilteredSpectrumImaginary, float f1, float f2)</td></tr>
<tr class="memdesc:afb20aaf48027861742eea4d62c3374ae inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">BANDPASS FILTER.  <a href="#afb20aaf48027861742eea4d62c3374ae">More...</a><br/></td></tr>
<tr class="separator:afb20aaf48027861742eea4d62c3374ae inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6888a07672d6646a17165f746ea837fb inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a6888a07672d6646a17165f746ea837fb">lowpass_filter</a> (Array2D&lt; float &gt; &amp;RawSpectrumReal, Array2D&lt; float &gt; &amp;RawSpectrumImaginary, Array2D&lt; float &gt; &amp;FilteredSpectrumReal, Array2D&lt; float &gt; &amp;FilteredSpectrumImaginary, float f1, float f2)</td></tr>
<tr class="memdesc:a6888a07672d6646a17165f746ea837fb inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">LOWPASS FILTER.  <a href="#a6888a07672d6646a17165f746ea837fb">More...</a><br/></td></tr>
<tr class="separator:a6888a07672d6646a17165f746ea837fb inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0bc84072e79b7eafec68a8991c709c inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#aae0bc84072e79b7eafec68a8991c709c">lowpass_filter_remainder</a> (Array2D&lt; float &gt; &amp;RawSpectrumReal, Array2D&lt; float &gt; &amp;RawSpectrumImaginary, Array2D&lt; float &gt; &amp;FilteredSpectrumReal, Array2D&lt; float &gt; &amp;FilteredSpectrumImaginary, float f1, float f2)</td></tr>
<tr class="memdesc:aae0bc84072e79b7eafec68a8991c709c inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">LOWPASS FILTER REMAINDER.  <a href="#aae0bc84072e79b7eafec68a8991c709c">More...</a><br/></td></tr>
<tr class="separator:aae0bc84072e79b7eafec68a8991c709c inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a09ab61c74643e19070a2ff6fd6a0a inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#ae4a09ab61c74643e19070a2ff6fd6a0a">highpass_filter</a> (Array2D&lt; float &gt; &amp;RawSpectrumReal, Array2D&lt; float &gt; &amp;RawSpectrumImaginary, Array2D&lt; float &gt; &amp;FilteredSpectrumReal, Array2D&lt; float &gt; &amp;FilteredSpectrumImaginary, float f1, float f2)</td></tr>
<tr class="memdesc:ae4a09ab61c74643e19070a2ff6fd6a0a inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">HIGHPASS FILTER.  <a href="#ae4a09ab61c74643e19070a2ff6fd6a0a">More...</a><br/></td></tr>
<tr class="separator:ae4a09ab61c74643e19070a2ff6fd6a0a inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbc3da3935600b1650dd3ae45c9666d inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#aedbc3da3935600b1650dd3ae45c9666d">highpass_filter_remainder</a> (Array2D&lt; float &gt; &amp;RawSpectrumReal, Array2D&lt; float &gt; &amp;RawSpectrumImaginary, Array2D&lt; float &gt; &amp;FilteredSpectrumReal, Array2D&lt; float &gt; &amp;FilteredSpectrumImaginary, float f1, float f2)</td></tr>
<tr class="memdesc:aedbc3da3935600b1650dd3ae45c9666d inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">HIGHPASS FILTER REMAINDER.  <a href="#aedbc3da3935600b1650dd3ae45c9666d">More...</a><br/></td></tr>
<tr class="separator:aedbc3da3935600b1650dd3ae45c9666d inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74cb8c0344ae4dfa65174a9835160d2 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#ae74cb8c0344ae4dfa65174a9835160d2">wiener_filter</a> (Array2D&lt; float &gt; &amp;RawSpectrumReal, Array2D&lt; float &gt; &amp;RawSpectrumImaginary, Array2D&lt; float &gt; &amp;FilteredSpectrumReal, Array2D&lt; float &gt; &amp;FilteredSpectrumImaginary)</td></tr>
<tr class="memdesc:ae74cb8c0344ae4dfa65174a9835160d2 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">WIENER FILTER.  <a href="#ae74cb8c0344ae4dfa65174a9835160d2">More...</a><br/></td></tr>
<tr class="separator:ae74cb8c0344ae4dfa65174a9835160d2 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d10b56b771dc300e02969d8389f846f inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a4d10b56b771dc300e02969d8389f846f">fftw2D_filter</a> (int FilterType, float FLow, float FHigh)</td></tr>
<tr class="memdesc:a4d10b56b771dc300e02969d8389f846f inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">FAST FOURIER TRANSFORM FILTER FOR A REAL, 2-DIMENSIONAL DATASET.  <a href="#a4d10b56b771dc300e02969d8389f846f">More...</a><br/></td></tr>
<tr class="separator:a4d10b56b771dc300e02969d8389f846f inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6dfb03cc0f0e37bcfb081f0a6fff06 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#a4b6dfb03cc0f0e37bcfb081f0a6fff06">fftw2D_wiener</a> ()</td></tr>
<tr class="memdesc:a4b6dfb03cc0f0e37bcfb081f0a6fff06 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">WIENER FILTER FOR A REAL, 2-DIMENSIONAL DATASET.  <a href="#a4b6dfb03cc0f0e37bcfb081f0a6fff06">More...</a><br/></td></tr>
<tr class="separator:a4b6dfb03cc0f0e37bcfb081f0a6fff06 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1b753cf3cbdeed7b58b6ee30298b4d inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d1b753cf3cbdeed7b58b6ee30298b4d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_radial_spectrum</b> (string file_id)</td></tr>
<tr class="separator:a0d1b753cf3cbdeed7b58b6ee30298b4d inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a5ff810b095892f0faffd498a30457 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3a5ff810b095892f0faffd498a30457"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_binned_spectrum</b> (string output_id, float log_bin_width)</td></tr>
<tr class="separator:ae3a5ff810b095892f0faffd498a30457 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b6fc6f99c9f5facddbaa64a624be22 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_spectral.html#ab6b6fc6f99c9f5facddbaa64a624be22">IsolateChannelsWienerQQ</a> (float area_threshold, float window_radius, string q_q_filename)</td></tr>
<tr class="memdesc:ab6b6fc6f99c9f5facddbaa64a624be22 inherit pub_methods_class_l_s_d_raster_spectral"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to locate channel pixels adapted from Pelletier (2013).  <a href="#ab6b6fc6f99c9f5facddbaa64a624be22">More...</a><br/></td></tr>
<tr class="separator:ab6b6fc6f99c9f5facddbaa64a624be22 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7283c95780bd8eda038d972177775 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33a7283c95780bd8eda038d972177775"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IsolateChannelsWienerQQAdaptive</b> (float area_threshold, float window_radius, string q_q_filename)</td></tr>
<tr class="separator:a33a7283c95780bd8eda038d972177775 inherit pub_methods_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_l_s_d_raster"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_l_s_d_raster')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_l_s_d_raster.html">LSDRaster</a></td></tr>
<tr class="memitem:af845252cdd4bc8d2487386ba929f9bcc inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af845252cdd4bc8d2487386ba929f9bcc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#af845252cdd4bc8d2487386ba929f9bcc">LSDRaster</a> ()</td></tr>
<tr class="memdesc:af845252cdd4bc8d2487386ba929f9bcc inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">The create function. This is default and throws an error. <br/></td></tr>
<tr class="separator:af845252cdd4bc8d2487386ba929f9bcc inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1cb2277ff6670a4452a60156bae824 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a0e1cb2277ff6670a4452a60156bae824">LSDRaster</a> (string filename, string extension)</td></tr>
<tr class="memdesc:a0e1cb2277ff6670a4452a60156bae824 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> from a file. Uses a filename and file extension.  <a href="#a0e1cb2277ff6670a4452a60156bae824">More...</a><br/></td></tr>
<tr class="separator:a0e1cb2277ff6670a4452a60156bae824 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed823ec252536362362c1eccd90be6b2 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aed823ec252536362362c1eccd90be6b2">LSDRaster</a> (int nrows, int ncols, float xmin, float ymin, float cellsize, float ndv, Array2D&lt; float &gt; data)</td></tr>
<tr class="memdesc:aed823ec252536362362c1eccd90be6b2 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> from memory.  <a href="#aed823ec252536362362c1eccd90be6b2">More...</a><br/></td></tr>
<tr class="separator:aed823ec252536362362c1eccd90be6b2 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bce22c0ea43adab9572e8f7ab0a94ef inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a0bce22c0ea43adab9572e8f7ab0a94ef">LSDRaster</a> (int nrows, int ncols, double xmin, double ymin, double cellsize, double ndv, Array2D&lt; double &gt; data)</td></tr>
<tr class="memdesc:a0bce22c0ea43adab9572e8f7ab0a94ef inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> from memory, with the elvation data stored as double precision floats.  <a href="#a0bce22c0ea43adab9572e8f7ab0a94ef">More...</a><br/></td></tr>
<tr class="separator:a0bce22c0ea43adab9572e8f7ab0a94ef inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33936fc57aac1a226186f7330abad2fa inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a33936fc57aac1a226186f7330abad2fa">LSDRaster</a> (int nrows, int ncols, float xmin, float ymin, float cellsize, float ndv, Array2D&lt; float &gt; data, map&lt; string, string &gt; temp_GRS)</td></tr>
<tr class="memdesc:a33936fc57aac1a226186f7330abad2fa inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> from memory, includes georeferencing.  <a href="#a33936fc57aac1a226186f7330abad2fa">More...</a><br/></td></tr>
<tr class="separator:a33936fc57aac1a226186f7330abad2fa inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e25cc15564f15dccb8b66b8d4bd7d2 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a08e25cc15564f15dccb8b66b8d4bd7d2">get_NRows</a> () const </td></tr>
<tr class="separator:a08e25cc15564f15dccb8b66b8d4bd7d2 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ce4ec03dd1d0616a9577a338f69da8 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac9ce4ec03dd1d0616a9577a338f69da8">get_NCols</a> () const </td></tr>
<tr class="separator:ac9ce4ec03dd1d0616a9577a338f69da8 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e759b3e01ea8860a4ccb63cb7c975b inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a15e759b3e01ea8860a4ccb63cb7c975b">get_XMinimum</a> () const </td></tr>
<tr class="separator:a15e759b3e01ea8860a4ccb63cb7c975b inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bcd4d45f9e84eaf037bd4d3e6e653d inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac2bcd4d45f9e84eaf037bd4d3e6e653d">get_YMinimum</a> () const </td></tr>
<tr class="separator:ac2bcd4d45f9e84eaf037bd4d3e6e653d inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468965d3781bd8ea55365eaf77fc9e3d inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a468965d3781bd8ea55365eaf77fc9e3d">get_DataResolution</a> () const </td></tr>
<tr class="separator:a468965d3781bd8ea55365eaf77fc9e3d inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7f3b7c0908779a7e1060dfe9f4cd4c inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a3c7f3b7c0908779a7e1060dfe9f4cd4c">get_NoDataValue</a> () const </td></tr>
<tr class="separator:a3c7f3b7c0908779a7e1060dfe9f4cd4c inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd72008a20563ba21caf7c0d8ba41be2 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abd72008a20563ba21caf7c0d8ba41be2">get_RasterData</a> () const </td></tr>
<tr class="separator:abd72008a20563ba21caf7c0d8ba41be2 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01e17bc56551571e8c2f127e3718174 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">Array2D&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aa01e17bc56551571e8c2f127e3718174">get_RasterData_dbl</a> () const </td></tr>
<tr class="memdesc:aa01e17bc56551571e8c2f127e3718174 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw raster data, double format.  <a href="#aa01e17bc56551571e8c2f127e3718174">More...</a><br/></td></tr>
<tr class="separator:aa01e17bc56551571e8c2f127e3718174 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332a70547de45e7662eb27c0b6ef2f29 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a332a70547de45e7662eb27c0b6ef2f29">get_RasterData_int</a> () const </td></tr>
<tr class="memdesc:a332a70547de45e7662eb27c0b6ef2f29 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw raster data, integer format.  <a href="#a332a70547de45e7662eb27c0b6ef2f29">More...</a><br/></td></tr>
<tr class="separator:a332a70547de45e7662eb27c0b6ef2f29 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938ce9854d96267267f06694ef84de3b inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a938ce9854d96267267f06694ef84de3b">get_GeoReferencingStrings</a> () const </td></tr>
<tr class="separator:a938ce9854d96267267f06694ef84de3b inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9f3397df5b3cf89ec8b4d31b4aa522 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a0e9f3397df5b3cf89ec8b4d31b4aa522">get_data_element</a> (int row, int column)</td></tr>
<tr class="memdesc:a0e9f3397df5b3cf89ec8b4d31b4aa522 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raster data at a specified location.  <a href="#a0e9f3397df5b3cf89ec8b4d31b4aa522">More...</a><br/></td></tr>
<tr class="separator:a0e9f3397df5b3cf89ec8b4d31b4aa522 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521142e6e1f812b104aa80e7be86af1f inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a521142e6e1f812b104aa80e7be86af1f">set_data_element</a> (int row, int column, float value)</td></tr>
<tr class="memdesc:a521142e6e1f812b104aa80e7be86af1f inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the raster data at a specified location.  <a href="#a521142e6e1f812b104aa80e7be86af1f">More...</a><br/></td></tr>
<tr class="separator:a521142e6e1f812b104aa80e7be86af1f inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf859d3f4272ce634028fe1686dcc3f7 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf859d3f4272ce634028fe1686dcc3f7"></a>
<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aaf859d3f4272ce634028fe1686dcc3f7">operator=</a> (const <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;LSDR)</td></tr>
<tr class="memdesc:aaf859d3f4272ce634028fe1686dcc3f7 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr class="separator:aaf859d3f4272ce634028fe1686dcc3f7 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95d817228d0efa166a601c406aa7862 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac95d817228d0efa166a601c406aa7862">read_raster</a> (string filename, string extension)</td></tr>
<tr class="memdesc:ac95d817228d0efa166a601c406aa7862 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a raster into memory from a file.  <a href="#ac95d817228d0efa166a601c406aa7862">More...</a><br/></td></tr>
<tr class="separator:ac95d817228d0efa166a601c406aa7862 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa8d06ed84b1dab76bb414634699b07 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">TNT::Array2D&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aaaa8d06ed84b1dab76bb414634699b07">get_ascii_raster</a> (string FILENAME)</td></tr>
<tr class="memdesc:aaaa8d06ed84b1dab76bb414634699b07 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a raster from an ascii file for use in <a class="el" href="class_l_s_d_catchment_model.html" title="This object is used to model the hydrology, sediment transport and evolution of individual basins...">LSDCatchmentModel</a>.  <a href="#aaaa8d06ed84b1dab76bb414634699b07">More...</a><br/></td></tr>
<tr class="separator:aaaa8d06ed84b1dab76bb414634699b07 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e219b52a85ddce8659acb87248833de inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e219b52a85ddce8659acb87248833de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>read_ascii_raster</b> (string FILENAME)</td></tr>
<tr class="separator:a1e219b52a85ddce8659acb87248833de inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc85ecbaf0891c9f31ed6b886feb2860 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abc85ecbaf0891c9f31ed6b886feb2860">read_ascii_raster_integers</a> (string FILENAME)</td></tr>
<tr class="memdesc:abc85ecbaf0891c9f31ed6b886feb2860 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a raster of integers and populates <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> integer array member data.  <a href="#abc85ecbaf0891c9f31ed6b886feb2860">More...</a><br/></td></tr>
<tr class="separator:abc85ecbaf0891c9f31ed6b886feb2860 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fce06a9e645907f3b44788dc9926f2 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#af8fce06a9e645907f3b44788dc9926f2">write_raster</a> (string filename, string extension)</td></tr>
<tr class="memdesc:af8fce06a9e645907f3b44788dc9926f2 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a raster from memory to a file.  <a href="#af8fce06a9e645907f3b44788dc9926f2">More...</a><br/></td></tr>
<tr class="separator:af8fce06a9e645907f3b44788dc9926f2 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dca7a4de099dc3b3defa5d1f8c5050 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a72dca7a4de099dc3b3defa5d1f8c5050">write_double_raster</a> (string filename, string extension)</td></tr>
<tr class="memdesc:a72dca7a4de099dc3b3defa5d1f8c5050 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This calls raster write functions, writing from Arrays of type &lt;double&gt; to raster format.  <a href="#a72dca7a4de099dc3b3defa5d1f8c5050">More...</a><br/></td></tr>
<tr class="separator:a72dca7a4de099dc3b3defa5d1f8c5050 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31f5d2372a9b7bc844994f74e401a7b inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae31f5d2372a9b7bc844994f74e401a7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae31f5d2372a9b7bc844994f74e401a7b">write_double_asc_raster</a> (string string_filename)</td></tr>
<tr class="memdesc:ae31f5d2372a9b7bc844994f74e401a7b inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes out a double array to an ascii. <br/></td></tr>
<tr class="separator:ae31f5d2372a9b7bc844994f74e401a7b inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027ffd3801bbd522b439c1d230029d1a inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a027ffd3801bbd522b439c1d230029d1a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a027ffd3801bbd522b439c1d230029d1a">write_double_flt_raster</a> (string filename, string string_filename)</td></tr>
<tr class="memdesc:a027ffd3801bbd522b439c1d230029d1a inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes out a double array to a binary flt file. <br/></td></tr>
<tr class="separator:a027ffd3801bbd522b439c1d230029d1a inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ed4d63b576662474713a7a6dd30fff inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a04ed4d63b576662474713a7a6dd30fff">write_double_bil_raster</a> (string filename, string string_filename)</td></tr>
<tr class="memdesc:a04ed4d63b576662474713a7a6dd30fff inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes out a double array to a ENVI bil file (untested!)  <a href="#a04ed4d63b576662474713a7a6dd30fff">More...</a><br/></td></tr>
<tr class="separator:a04ed4d63b576662474713a7a6dd30fff inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00583bd08c65fa2f2b997b1ab7844c7c inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a00583bd08c65fa2f2b997b1ab7844c7c">does_raster_have_same_dimensions</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Compare_raster)</td></tr>
<tr class="memdesc:a00583bd08c65fa2f2b997b1ab7844c7c inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if two rasters have the same dimensions  Does NOT check georeferencing.  <a href="#a00583bd08c65fa2f2b997b1ab7844c7c">More...</a><br/></td></tr>
<tr class="separator:a00583bd08c65fa2f2b997b1ab7844c7c inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272891c6cf512ff95f489f06ef7cc042 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a272891c6cf512ff95f489f06ef7cc042">does_raster_have_same_dimensions</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Compare_raster)</td></tr>
<tr class="memdesc:a272891c6cf512ff95f489f06ef7cc042 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if two rasters have the same dimensions  Does NOT check georeferencing.  <a href="#a272891c6cf512ff95f489f06ef7cc042">More...</a><br/></td></tr>
<tr class="separator:a272891c6cf512ff95f489f06ef7cc042 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e5df5e08ad139f8b3abba7eae414b1 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a31e5df5e08ad139f8b3abba7eae414b1">does_raster_have_same_dimensions_and_georeferencing</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Compare_raster)</td></tr>
<tr class="memdesc:a31e5df5e08ad139f8b3abba7eae414b1 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if two rasters have the same georeferencing.  <a href="#a31e5df5e08ad139f8b3abba7eae414b1">More...</a><br/></td></tr>
<tr class="separator:a31e5df5e08ad139f8b3abba7eae414b1 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f34429a41eefb8397fb5a7257b7f737 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2f34429a41eefb8397fb5a7257b7f737">does_raster_have_same_dimensions_and_georeferencing</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Compare_raster)</td></tr>
<tr class="memdesc:a2f34429a41eefb8397fb5a7257b7f737 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if two rasters have the same georeferencing.  <a href="#a2f34429a41eefb8397fb5a7257b7f737">More...</a><br/></td></tr>
<tr class="separator:a2f34429a41eefb8397fb5a7257b7f737 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad561bc23880faa84f0bb8b1b04e365fc inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad561bc23880faa84f0bb8b1b04e365fc">Update_GeoReferencingStrings</a> (float NewXmin, float NewYmax)</td></tr>
<tr class="memdesc:ad561bc23880faa84f0bb8b1b04e365fc inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method which takes a new xmin and ymax value and modifys the GeoReferencingStrings map_info line to contain these new values.  <a href="#ad561bc23880faa84f0bb8b1b04e365fc">More...</a><br/></td></tr>
<tr class="separator:ad561bc23880faa84f0bb8b1b04e365fc inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31031dfeb7aa365fa0219268f2c94ac9 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a31031dfeb7aa365fa0219268f2c94ac9">Update_GeoReferencingStrings</a> ()</td></tr>
<tr class="memdesc:a31031dfeb7aa365fa0219268f2c94ac9 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method which updates the map info element of the georeferencing strings based on information within the datamembers of the raster.  <a href="#a31031dfeb7aa365fa0219268f2c94ac9">More...</a><br/></td></tr>
<tr class="separator:a31031dfeb7aa365fa0219268f2c94ac9 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea551343b827e83267b01eac832aafda inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aea551343b827e83267b01eac832aafda">impose_georeferencing_UTM</a> (int zone, string NorS)</td></tr>
<tr class="memdesc:aea551343b827e83267b01eac832aafda inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method imposes georefereing strings assuming the coordinate system is UTM.  <a href="#aea551343b827e83267b01eac832aafda">More...</a><br/></td></tr>
<tr class="separator:aea551343b827e83267b01eac832aafda inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fe2d220b79452468d401aacafdcf77 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a89fe2d220b79452468d401aacafdcf77">Find_UTM_central_meridian</a> (int UTM_zone)</td></tr>
<tr class="memdesc:a89fe2d220b79452468d401aacafdcf77 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method looks up the central meridian given a UTM zone.  <a href="#a89fe2d220b79452468d401aacafdcf77">More...</a><br/></td></tr>
<tr class="separator:a89fe2d220b79452468d401aacafdcf77 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a888311e20677e866da63c9bc508d9 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac3a888311e20677e866da63c9bc508d9">get_UTM_information</a> (int &amp;UTM_zone, bool &amp;is_North)</td></tr>
<tr class="memdesc:ac3a888311e20677e866da63c9bc508d9 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function gets the UTM_zone and a boolean that is true if the map is in the northern hemisphere  <a href="#ac3a888311e20677e866da63c9bc508d9">More...</a><br/></td></tr>
<tr class="separator:ac3a888311e20677e866da63c9bc508d9 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ca0ab8a3c7fe16ef16b25a6bbc9805 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab9ca0ab8a3c7fe16ef16b25a6bbc9805">get_x_and_y_locations</a> (int row, int col, double &amp;x_loc, double &amp;y_loc)</td></tr>
<tr class="memdesc:ab9ca0ab8a3c7fe16ef16b25a6bbc9805 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">this gets the x and y location of a node at row and column  <a href="#ab9ca0ab8a3c7fe16ef16b25a6bbc9805">More...</a><br/></td></tr>
<tr class="separator:ab9ca0ab8a3c7fe16ef16b25a6bbc9805 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6d6796b91782832d3afab303effa9e inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abc6d6796b91782832d3afab303effa9e">get_x_and_y_locations</a> (int row, int col, float &amp;x_loc, float &amp;y_loc)</td></tr>
<tr class="memdesc:abc6d6796b91782832d3afab303effa9e inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">this gets the x and y location of a node at row and column  <a href="#abc6d6796b91782832d3afab303effa9e">More...</a><br/></td></tr>
<tr class="separator:abc6d6796b91782832d3afab303effa9e inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad904ac3a113434319b9eec0857479343 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad904ac3a113434319b9eec0857479343">get_lat_and_long_locations</a> (int row, int col, double &amp;lat, double &amp;longitude, <a class="el" href="class_l_s_d_coordinate_converter_l_land_u_t_m.html">LSDCoordinateConverterLLandUTM</a> Converter)</td></tr>
<tr class="memdesc:ad904ac3a113434319b9eec0857479343 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function to get the lat and long of a node in the raster  Assumes WGS84 ellipsiod  <a href="#ad904ac3a113434319b9eec0857479343">More...</a><br/></td></tr>
<tr class="separator:ad904ac3a113434319b9eec0857479343 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6f687663706b020002604533a08379 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acc6f687663706b020002604533a08379">get_easting_and_northing_vectors</a> (vector&lt; float &gt; &amp;Eastings, vector&lt; float &gt; &amp;Northings)</td></tr>
<tr class="memdesc:acc6f687663706b020002604533a08379 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns vectors of all the easting and northing points in the raster Used for interpolations.  <a href="#acc6f687663706b020002604533a08379">More...</a><br/></td></tr>
<tr class="separator:acc6f687663706b020002604533a08379 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c2b31fb34a041c4bf240650103f645 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a24c2b31fb34a041c4bf240650103f645">interpolate_points_bilinear</a> (vector&lt; float &gt; UTMEvec, vector&lt; float &gt; UTMNvec)</td></tr>
<tr class="memdesc:a24c2b31fb34a041c4bf240650103f645 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interpolates a vector of points onto the raster. Uses bilinear interpolation.  <a href="#a24c2b31fb34a041c4bf240650103f645">More...</a><br/></td></tr>
<tr class="separator:a24c2b31fb34a041c4bf240650103f645 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad40fa659801ff5624d2d449c242fdc inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abad40fa659801ff5624d2d449c242fdc">fill_with_interpolated_data</a> (vector&lt; int &gt; rows_of_nodes, vector&lt; int &gt; cols_of_nodes, vector&lt; float &gt; interpolated_data)</td></tr>
<tr class="memdesc:abad40fa659801ff5624d2d449c242fdc inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fills a raster with precalculated interpolated data.  <a href="#abad40fa659801ff5624d2d449c242fdc">More...</a><br/></td></tr>
<tr class="separator:abad40fa659801ff5624d2d449c242fdc inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f2a2a2545c77b481c04b8d7adffd44 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a91f2a2a2545c77b481c04b8d7adffd44">get_value_of_point</a> (float UTME, float UTMN)</td></tr>
<tr class="memdesc:a91f2a2a2545c77b481c04b8d7adffd44 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the value at a point in UTM coordinates.  <a href="#a91f2a2a2545c77b481c04b8d7adffd44">More...</a><br/></td></tr>
<tr class="separator:a91f2a2a2545c77b481c04b8d7adffd44 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972d9ed0805f6a9fe83e313c32ad656a inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a972d9ed0805f6a9fe83e313c32ad656a">check_if_point_is_in_raster</a> (float X_coordinate, float Y_coordinate)</td></tr>
<tr class="memdesc:a972d9ed0805f6a9fe83e313c32ad656a inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">this check to see if a point is within the raster  <a href="#a972d9ed0805f6a9fe83e313c32ad656a">More...</a><br/></td></tr>
<tr class="separator:a972d9ed0805f6a9fe83e313c32ad656a inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad690e009f9f019da688d553789f6ae8f inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad690e009f9f019da688d553789f6ae8f">get_row_and_col_of_a_point</a> (float X_coordinate, float Y_coordinate, int &amp;row, int &amp;col)</td></tr>
<tr class="memdesc:ad690e009f9f019da688d553789f6ae8f inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the row and column of a point in the raster.  <a href="#ad690e009f9f019da688d553789f6ae8f">More...</a><br/></td></tr>
<tr class="separator:ad690e009f9f019da688d553789f6ae8f inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67188d97c05315c98e4672081b5af33 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac67188d97c05315c98e4672081b5af33"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_row_and_col_of_a_point</b> (double X_coordinate, double Y_coordinate, int &amp;row, int &amp;col)</td></tr>
<tr class="separator:ac67188d97c05315c98e4672081b5af33 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace29fbf034c7af2dc70eb5c58db57bfb inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ace29fbf034c7af2dc70eb5c58db57bfb">get_XY_MinMax</a> ()</td></tr>
<tr class="memdesc:ace29fbf034c7af2dc70eb5c58db57bfb inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a vector with the X adn Y minimum and max values.  <a href="#ace29fbf034c7af2dc70eb5c58db57bfb">More...</a><br/></td></tr>
<tr class="separator:ace29fbf034c7af2dc70eb5c58db57bfb inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfb4efd91861f3977426004ccbe5443 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a4dfb4efd91861f3977426004ccbe5443">get_RasterData_vector</a> ()</td></tr>
<tr class="memdesc:a4dfb4efd91861f3977426004ccbe5443 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the raster data as a vector.  <a href="#a4dfb4efd91861f3977426004ccbe5443">More...</a><br/></td></tr>
<tr class="separator:a4dfb4efd91861f3977426004ccbe5443 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f6f87c568b3b187861cba4822b027e inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a06f6f87c568b3b187861cba4822b027e">get_RasterData_vector_No_NDVs</a> ()</td></tr>
<tr class="memdesc:a06f6f87c568b3b187861cba4822b027e inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the raster data as a vector, ignoring NDVs.  <a href="#a06f6f87c568b3b187861cba4822b027e">More...</a><br/></td></tr>
<tr class="separator:a06f6f87c568b3b187861cba4822b027e inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bc58532a0ed8acccea68da9a787760 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a97bc58532a0ed8acccea68da9a787760">write_RasterData_to_text_file</a> (string filename)</td></tr>
<tr class="memdesc:a97bc58532a0ed8acccea68da9a787760 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the raster data as text file.  <a href="#a97bc58532a0ed8acccea68da9a787760">More...</a><br/></td></tr>
<tr class="separator:a97bc58532a0ed8acccea68da9a787760 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00b501f9761192ca7a5f4f417bdecfa inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae00b501f9761192ca7a5f4f417bdecfa">rewrite_with_random_values</a> (float range)</td></tr>
<tr class="memdesc:ae00b501f9761192ca7a5f4f417bdecfa inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">rewrite all the data array values with random numbers (with a uniform distribution).  <a href="#ae00b501f9761192ca7a5f4f417bdecfa">More...</a><br/></td></tr>
<tr class="separator:ae00b501f9761192ca7a5f4f417bdecfa inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2063e4b0055740837635911886f27e62 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2063e4b0055740837635911886f27e62">create_raster_nodata</a> ()</td></tr>
<tr class="memdesc:a2063e4b0055740837635911886f27e62 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a raster in of the same number of rows and cols with nodata.  <a href="#a2063e4b0055740837635911886f27e62">More...</a><br/></td></tr>
<tr class="separator:a2063e4b0055740837635911886f27e62 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c74ca7454b451b85a680eb581fbf7c inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a00c74ca7454b451b85a680eb581fbf7c">RasterTrimmer</a> ()</td></tr>
<tr class="memdesc:a00c74ca7454b451b85a680eb581fbf7c inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the minimum bounding rectangle for an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> Object and crop out all the surrounding NoDataValues to reduce the size and load times of output rasters.  <a href="#a00c74ca7454b451b85a680eb581fbf7c">More...</a><br/></td></tr>
<tr class="separator:a00c74ca7454b451b85a680eb581fbf7c inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33720ffe99abb3ed10264c679b9a608c inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a33720ffe99abb3ed10264c679b9a608c">RasterTrimmerPadded</a> (int padded_pixels)</td></tr>
<tr class="memdesc:a33720ffe99abb3ed10264c679b9a608c inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the minimum bounding rectangle for an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> Object and crop out all the surrounding NoDataValues to reduce the size and load times of output rasters. Similar to RasterTrimmer but has a pixel buffer. Useful for CRN data since sometimes the channel in the DEM does not correspond exactly with the data point.  <a href="#a33720ffe99abb3ed10264c679b9a608c">More...</a><br/></td></tr>
<tr class="separator:a33720ffe99abb3ed10264c679b9a608c inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b61cc0f912f93dc6e5483ce03ef468 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a47b61cc0f912f93dc6e5483ce03ef468">RasterTrimmerSpiral</a> ()</td></tr>
<tr class="memdesc:a47b61cc0f912f93dc6e5483ce03ef468 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a raster and trims nodata from around the edges to result in a rectangular <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>.  <a href="#a47b61cc0f912f93dc6e5483ce03ef468">More...</a><br/></td></tr>
<tr class="separator:a47b61cc0f912f93dc6e5483ce03ef468 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cb08ebbbaf25149d14552164671ce4 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a41cb08ebbbaf25149d14552164671ce4">clip_to_smaller_raster</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;smaller_raster)</td></tr>
<tr class="memdesc:a41cb08ebbbaf25149d14552164671ce4 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a clipped raster that has the same dimensions as the smaller raster.  <a href="#a41cb08ebbbaf25149d14552164671ce4">More...</a><br/></td></tr>
<tr class="separator:a41cb08ebbbaf25149d14552164671ce4 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ed4e5c0efe368c2a3c9708a71fd6f2 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a84ed4e5c0efe368c2a3c9708a71fd6f2">clip_to_smaller_raster</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;smaller_raster)</td></tr>
<tr class="memdesc:a84ed4e5c0efe368c2a3c9708a71fd6f2 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a clipped raster that has the same dimensions as the smaller raster.  <a href="#a84ed4e5c0efe368c2a3c9708a71fd6f2">More...</a><br/></td></tr>
<tr class="separator:a84ed4e5c0efe368c2a3c9708a71fd6f2 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a22acd87d2a12a9fef0ced5c34cc8d inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae5a22acd87d2a12a9fef0ced5c34cc8d">LSDRasterTemplate</a> (Array2D&lt; float &gt; InputData)</td></tr>
<tr class="memdesc:ae5a22acd87d2a12a9fef0ced5c34cc8d inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object using a 'template' raster and an Array2D of data.  <a href="#ae5a22acd87d2a12a9fef0ced5c34cc8d">More...</a><br/></td></tr>
<tr class="separator:ae5a22acd87d2a12a9fef0ced5c34cc8d inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb2a79bbdc11675ebb1c93c705bf01a inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a6cb2a79bbdc11675ebb1c93c705bf01a">strip_raster_padding</a> ()</td></tr>
<tr class="memdesc:a6cb2a79bbdc11675ebb1c93c705bf01a inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the edge rows/columns of a <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> on each side of the array.  <a href="#a6cb2a79bbdc11675ebb1c93c705bf01a">More...</a><br/></td></tr>
<tr class="separator:a6cb2a79bbdc11675ebb1c93c705bf01a inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7071ad2969e75a43477e90fe50e9e544 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a7071ad2969e75a43477e90fe50e9e544">BufferRasterData</a> (float window_radius)</td></tr>
<tr class="memdesc:a7071ad2969e75a43477e90fe50e9e544 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffers a raster using a circular kernel of a user-defined radius (m)  <a href="#a7071ad2969e75a43477e90fe50e9e544">More...</a><br/></td></tr>
<tr class="separator:a7071ad2969e75a43477e90fe50e9e544 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe374373ec34318878a49acde9a7e59 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebe374373ec34318878a49acde9a7e59"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aebe374373ec34318878a49acde9a7e59">PadSmallerRaster</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;smaller_raster)</td></tr>
<tr class="memdesc:aebe374373ec34318878a49acde9a7e59 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad one smaller raster to the same extent as a bigger raster by adding no data around the edges. <br/></td></tr>
<tr class="separator:aebe374373ec34318878a49acde9a7e59 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10deff45b25c7dfb065df33d057be3d inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae10deff45b25c7dfb065df33d057be3d">calculate_relief</a> (float kernelWidth, int kernelType)</td></tr>
<tr class="memdesc:ae10deff45b25c7dfb065df33d057be3d inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a relief raster.  <a href="#ae10deff45b25c7dfb065df33d057be3d">More...</a><br/></td></tr>
<tr class="separator:ae10deff45b25c7dfb065df33d057be3d inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d1dd8fb4dbecd7aa84641c06effe7d inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a94d1dd8fb4dbecd7aa84641c06effe7d">mean_elevation</a> (void)</td></tr>
<tr class="memdesc:a94d1dd8fb4dbecd7aa84641c06effe7d inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates mean elevation of a raster.  <a href="#a94d1dd8fb4dbecd7aa84641c06effe7d">More...</a><br/></td></tr>
<tr class="separator:a94d1dd8fb4dbecd7aa84641c06effe7d inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc84f4343f835502a05bf1933fa8a368 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acc84f4343f835502a05bf1933fa8a368">max_elevation</a> (void)</td></tr>
<tr class="memdesc:acc84f4343f835502a05bf1933fa8a368 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates max elevation of a raster.  <a href="#acc84f4343f835502a05bf1933fa8a368">More...</a><br/></td></tr>
<tr class="separator:acc84f4343f835502a05bf1933fa8a368 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa43db51b8b8f11f36a16e43d8228b9f inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aaa43db51b8b8f11f36a16e43d8228b9f">mean_relief</a> (float kernelsize)</td></tr>
<tr class="memdesc:aaa43db51b8b8f11f36a16e43d8228b9f inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates mean relief of a raster, it defaults to a circular kernal.  <a href="#aaa43db51b8b8f11f36a16e43d8228b9f">More...</a><br/></td></tr>
<tr class="separator:aaa43db51b8b8f11f36a16e43d8228b9f inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf499bc742ba424266af5e0917440cb inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a3cf499bc742ba424266af5e0917440cb">difference_rasters</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;compare_raster)</td></tr>
<tr class="memdesc:a3cf499bc742ba424266af5e0917440cb inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mean difference between two rasters.  <a href="#a3cf499bc742ba424266af5e0917440cb">More...</a><br/></td></tr>
<tr class="separator:a3cf499bc742ba424266af5e0917440cb inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d568d1e13391c0296652f1ab217b5f inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a33d568d1e13391c0296652f1ab217b5f">raster_multiplier</a> (float multiplier)</td></tr>
<tr class="memdesc:a33d568d1e13391c0296652f1ab217b5f inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This multiplies the raster data by a multiplier  Note that values are replaced.  <a href="#a33d568d1e13391c0296652f1ab217b5f">More...</a><br/></td></tr>
<tr class="separator:a33d568d1e13391c0296652f1ab217b5f inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cac2e67a21fbcc84ff76e617d516a9 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a13cac2e67a21fbcc84ff76e617d516a9">MapAlgebra_multiply</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;M_raster)</td></tr>
<tr class="memdesc:a13cac2e67a21fbcc84ff76e617d516a9 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This multiplies two rasters, elementwise  Simple elementwise multiplictation.  <a href="#a13cac2e67a21fbcc84ff76e617d516a9">More...</a><br/></td></tr>
<tr class="separator:a13cac2e67a21fbcc84ff76e617d516a9 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040d9da2e9fadc56445df513aab735ba inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a040d9da2e9fadc56445df513aab735ba">MapAlgebra_divide</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;M_raster)</td></tr>
<tr class="memdesc:a040d9da2e9fadc56445df513aab735ba inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This divides two rasters, elementwise  Simple elementwise division.  <a href="#a040d9da2e9fadc56445df513aab735ba">More...</a><br/></td></tr>
<tr class="separator:a040d9da2e9fadc56445df513aab735ba inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929bdcffb9dc23cf174724bf4b57a2e3 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a929bdcffb9dc23cf174724bf4b57a2e3">MapAlgebra_add</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;M_raster)</td></tr>
<tr class="memdesc:a929bdcffb9dc23cf174724bf4b57a2e3 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This add two rasters, elementwise  Simple elementwise addition.  <a href="#a929bdcffb9dc23cf174724bf4b57a2e3">More...</a><br/></td></tr>
<tr class="separator:a929bdcffb9dc23cf174724bf4b57a2e3 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa5745b2cf30b3183076aab49bf7016 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2aa5745b2cf30b3183076aab49bf7016">MapAlgebra_subtract</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;M_raster)</td></tr>
<tr class="memdesc:a2aa5745b2cf30b3183076aab49bf7016 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subtracts two rasters, elementwise  Simple elementwise subtraction.  <a href="#a2aa5745b2cf30b3183076aab49bf7016">More...</a><br/></td></tr>
<tr class="separator:a2aa5745b2cf30b3183076aab49bf7016 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd69705ea2bdb06af1703a111d8da599 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abd69705ea2bdb06af1703a111d8da599">WrapSample</a> (int row, int col)</td></tr>
<tr class="memdesc:abd69705ea2bdb06af1703a111d8da599 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a value from the array data element but wraps around the array dimensions so that row &gt; NRows (for example) returns a value.  <a href="#abd69705ea2bdb06af1703a111d8da599">More...</a><br/></td></tr>
<tr class="separator:abd69705ea2bdb06af1703a111d8da599 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258644dc36c4ed6e04011ff2419074a8 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a258644dc36c4ed6e04011ff2419074a8">SetWrapSample</a> (int row, int col, float value)</td></tr>
<tr class="memdesc:a258644dc36c4ed6e04011ff2419074a8 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets a value in the data array withthe added feature that it wraps beyond NRows and NCols.  <a href="#a258644dc36c4ed6e04011ff2419074a8">More...</a><br/></td></tr>
<tr class="separator:a258644dc36c4ed6e04011ff2419074a8 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8665f8057d8050cb61ccc1404c6f80c5 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a8665f8057d8050cb61ccc1404c6f80c5">DSSetFeatureCorners</a> (int featuresize, float scale)</td></tr>
<tr class="memdesc:a8665f8057d8050cb61ccc1404c6f80c5 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets the corners of features as the first step in the diamond square algorithm.  <a href="#a8665f8057d8050cb61ccc1404c6f80c5">More...</a><br/></td></tr>
<tr class="separator:a8665f8057d8050cb61ccc1404c6f80c5 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0aff5f6e1cdb4a1801419e5e63e9d5 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2e0aff5f6e1cdb4a1801419e5e63e9d5">DSSampleSquare</a> (int row, int col, int size, float value)</td></tr>
<tr class="memdesc:a2e0aff5f6e1cdb4a1801419e5e63e9d5 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the square sampling step of the diamond square algorithm: it takes the average of the four corners and adds a random number to set the centrepoint of a square.  <a href="#a2e0aff5f6e1cdb4a1801419e5e63e9d5">More...</a><br/></td></tr>
<tr class="separator:a2e0aff5f6e1cdb4a1801419e5e63e9d5 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e384d147a6a22b929020f97b0f16f0 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac5e384d147a6a22b929020f97b0f16f0">DSSampleDiamond</a> (int row, int col, int size, float value)</td></tr>
<tr class="memdesc:ac5e384d147a6a22b929020f97b0f16f0 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the diamond sampling step of the diamond square algorithm: it takes the average of the four corners and adds a random number to set the centrepoint of a diamond.  <a href="#ac5e384d147a6a22b929020f97b0f16f0">More...</a><br/></td></tr>
<tr class="separator:ac5e384d147a6a22b929020f97b0f16f0 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dca3c985ce96fa98df6b1f5e325f3f inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a86dca3c985ce96fa98df6b1f5e325f3f">DiamondSquare_SampleStep</a> (int stepsize, float scale)</td></tr>
<tr class="memdesc:a86dca3c985ce96fa98df6b1f5e325f3f inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the sampling function for the diamond square algorithm: it runs both a diamond and a square sampling for each step.  <a href="#a86dca3c985ce96fa98df6b1f5e325f3f">More...</a><br/></td></tr>
<tr class="separator:a86dca3c985ce96fa98df6b1f5e325f3f inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49cd0617a2eaccc60e03cededbd79ba inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac49cd0617a2eaccc60e03cededbd79ba">DiamondSquare</a> (int feature_order, float scale)</td></tr>
<tr class="memdesc:ac49cd0617a2eaccc60e03cededbd79ba inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the driving function for the diamond square algorithm.  <a href="#ac49cd0617a2eaccc60e03cededbd79ba">More...</a><br/></td></tr>
<tr class="separator:ac49cd0617a2eaccc60e03cededbd79ba inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b1fd5b037bac76a4f26c821f1d854e inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a69b1fd5b037bac76a4f26c821f1d854e">hillshade</a> ()</td></tr>
<tr class="memdesc:a69b1fd5b037bac76a4f26c821f1d854e inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a hillshade raster.  <a href="#a69b1fd5b037bac76a4f26c821f1d854e">More...</a><br/></td></tr>
<tr class="separator:a69b1fd5b037bac76a4f26c821f1d854e inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73eb390174187d2aa8ee2f57debdf8c8 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73eb390174187d2aa8ee2f57debdf8c8"></a>
<a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hillshade</b> (float altitude, float azimuth, float z_factor)</td></tr>
<tr class="separator:a73eb390174187d2aa8ee2f57debdf8c8 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc990b240756b3683628d0881f28bbb inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#adbc990b240756b3683628d0881f28bbb">Shadow</a> (int theta, int phi)</td></tr>
<tr class="memdesc:adbc990b240756b3683628d0881f28bbb inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a hillshade derivative raster using the algorithm outlined in Codilean (2006).  <a href="#adbc990b240756b3683628d0881f28bbb">More...</a><br/></td></tr>
<tr class="separator:adbc990b240756b3683628d0881f28bbb inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbcd3609a0d99e74900435020af4d88 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2bbcd3609a0d99e74900435020af4d88">CastShadows</a> (int Azimuth, int ZenithAngle)</td></tr>
<tr class="memdesc:a2bbcd3609a0d99e74900435020af4d88 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine areas of a DEM that are in shadow from a given radiation source defined by an Azimuth and Zenith following Codilean (2006).  <a href="#a2bbcd3609a0d99e74900435020af4d88">More...</a><br/></td></tr>
<tr class="separator:a2bbcd3609a0d99e74900435020af4d88 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef61f081a68a6677698daa2bd55033d inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aaef61f081a68a6677698daa2bd55033d">Shadows</a> (int Azimuth, int ZenithAngle)</td></tr>
<tr class="memdesc:aaef61f081a68a6677698daa2bd55033d inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine areas of a DEM that are in shadow from a given radiation source defined by an Azimuth and Zenith following Codilean (2006).  <a href="#aaef61f081a68a6677698daa2bd55033d">More...</a><br/></td></tr>
<tr class="separator:aaef61f081a68a6677698daa2bd55033d inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa2dc8f6e3e1c62e9e3fb74225c8aa7 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a1fa2dc8f6e3e1c62e9e3fb74225c8aa7">TopographicShielding</a> (int theta_step, int phi_step)</td></tr>
<tr class="memdesc:a1fa2dc8f6e3e1c62e9e3fb74225c8aa7 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a topographic shielding raster using the algorithm outlined in Codilean (2006).  <a href="#a1fa2dc8f6e3e1c62e9e3fb74225c8aa7">More...</a><br/></td></tr>
<tr class="separator:a1fa2dc8f6e3e1c62e9e3fb74225c8aa7 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4349f4cf7d4d587c05d5eddce3a8a9 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef4349f4cf7d4d587c05d5eddce3a8a9"></a>
<a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TopographicShielding</b> ()</td></tr>
<tr class="separator:aef4349f4cf7d4d587c05d5eddce3a8a9 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb6f3aa7b196ade7283dc77ae52640a inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aefb6f3aa7b196ade7283dc77ae52640a">calculate_polyfit_surface_metrics</a> (float window_radius, vector&lt; int &gt; raster_selection)</td></tr>
<tr class="memdesc:aefb6f3aa7b196ade7283dc77ae52640a inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface polynomial fitting and extraction of topographic metrics.  <a href="#aefb6f3aa7b196ade7283dc77ae52640a">More...</a><br/></td></tr>
<tr class="separator:aefb6f3aa7b196ade7283dc77ae52640a inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277eed7fed092e06fc22d05bebb24aaf inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a277eed7fed092e06fc22d05bebb24aaf">calculate_polyfit_surface_metrics_directional_gradients</a> (float window_radius, vector&lt; int &gt; raster_selection)</td></tr>
<tr class="memdesc:a277eed7fed092e06fc22d05bebb24aaf inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface polynomial fitting and extraction of topographic metrics. Same as above function but in this case one can opt for directional gradients. Added as another function to ensure legacy code is not broken.  A six term polynomial surface is fitted to all the points that lie within circular neighbourhood that is defined by the designated window radius. The user also inputs a binary raster, which tells the program which rasters it wants to create (label as "1" to produce them, "0" to ignore them. This has 8 elements, as listed below: 0 -&gt; Elevation (smoothed by surface fitting) 1 -&gt; Slope 2 -&gt; Aspect 3 -&gt; Curvature 4 -&gt; Planform Curvature 5 -&gt; Profile Curvature 6 -&gt; Tangential Curvature 7 -&gt; Stationary point classification (1=peak, 2=depression, 3=saddle) 8 -&gt; Directional gradients (dz/dx and dz,dy) The program returns a vector of LSDRasters. For options marked "false" in boolean input raster, the returned <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> houses a blank raster, as this metric has not been calculated. The desired <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> can be retrieved from the output vector by using the cell reference shown in the list above i.e. it is the same as the reference in the input boolean vector.  <a href="#a277eed7fed092e06fc22d05bebb24aaf">More...</a><br/></td></tr>
<tr class="separator:a277eed7fed092e06fc22d05bebb24aaf inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb085209c3dc12eb6b59ed0dc58e4ba3 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aeb085209c3dc12eb6b59ed0dc58e4ba3">calculate_polyfit_roughness_metrics</a> (float window_radius1, float window_radius2, vector&lt; int &gt; raster_selection)</td></tr>
<tr class="memdesc:aeb085209c3dc12eb6b59ed0dc58e4ba3 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface polynomial fitting and extraction of roughness metrics.  <a href="#aeb085209c3dc12eb6b59ed0dc58e4ba3">More...</a><br/></td></tr>
<tr class="separator:aeb085209c3dc12eb6b59ed0dc58e4ba3 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fe83faa31eabe0ef3b5e5ca8333254 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a04fe83faa31eabe0ef3b5e5ca8333254">calculate_polyfit_coefficient_matrices</a> (float window_radius, Array2D&lt; float &gt; &amp;a, Array2D&lt; float &gt; &amp;b, Array2D&lt; float &gt; &amp;c, Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e, Array2D&lt; float &gt; &amp;f)</td></tr>
<tr class="memdesc:a04fe83faa31eabe0ef3b5e5ca8333254 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates 6 coefficient matrices that allow the user to then calcualte slope, curvature, aspect, a classification for finding saddles and peaks and other metrics.  <a href="#a04fe83faa31eabe0ef3b5e5ca8333254">More...</a><br/></td></tr>
<tr class="separator:a04fe83faa31eabe0ef3b5e5ca8333254 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6aa4aee4586df345a2cfcfe2adf6f9a inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad6aa4aee4586df345a2cfcfe2adf6f9a">calculate_polyfit_elevation</a> (Array2D&lt; float &gt; &amp;f)</td></tr>
<tr class="memdesc:ad6aa4aee4586df345a2cfcfe2adf6f9a inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the elevation based on a polynomial fit.  <a href="#ad6aa4aee4586df345a2cfcfe2adf6f9a">More...</a><br/></td></tr>
<tr class="separator:ad6aa4aee4586df345a2cfcfe2adf6f9a inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae2eadcadcd924ebb7e4e4eeac3cd7a inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a9ae2eadcadcd924ebb7e4e4eeac3cd7a">calculate_polyfit_slope</a> (Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e)</td></tr>
<tr class="memdesc:a9ae2eadcadcd924ebb7e4e4eeac3cd7a inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the slope based on a polynomial fit.  <a href="#a9ae2eadcadcd924ebb7e4e4eeac3cd7a">More...</a><br/></td></tr>
<tr class="separator:a9ae2eadcadcd924ebb7e4e4eeac3cd7a inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7b1dfb873b632a49c8aa755eb399db inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a9c7b1dfb873b632a49c8aa755eb399db">calculate_polyfit_aspect</a> (Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e)</td></tr>
<tr class="memdesc:a9c7b1dfb873b632a49c8aa755eb399db inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the aspect based on a polynomial fit.  <a href="#a9c7b1dfb873b632a49c8aa755eb399db">More...</a><br/></td></tr>
<tr class="separator:a9c7b1dfb873b632a49c8aa755eb399db inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b313feafa3a2e9ab790389976f522ce inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a7b313feafa3a2e9ab790389976f522ce">calculate_polyfit_curvature</a> (Array2D&lt; float &gt; &amp;a, Array2D&lt; float &gt; &amp;b)</td></tr>
<tr class="memdesc:a7b313feafa3a2e9ab790389976f522ce inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the curvature based on a polynomial fit.  <a href="#a7b313feafa3a2e9ab790389976f522ce">More...</a><br/></td></tr>
<tr class="separator:a7b313feafa3a2e9ab790389976f522ce inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf3bb49b83db88798647b8ceee85c94 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aeaf3bb49b83db88798647b8ceee85c94">calculate_polyfit_planform_curvature</a> (Array2D&lt; float &gt; &amp;a, Array2D&lt; float &gt; &amp;b, Array2D&lt; float &gt; &amp;c, Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e)</td></tr>
<tr class="memdesc:aeaf3bb49b83db88798647b8ceee85c94 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the planform curvature based on a polynomial fit.  <a href="#aeaf3bb49b83db88798647b8ceee85c94">More...</a><br/></td></tr>
<tr class="separator:aeaf3bb49b83db88798647b8ceee85c94 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4da58e27375a3609942872e1dd45341 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aa4da58e27375a3609942872e1dd45341">calculate_polyfit_profile_curvature</a> (Array2D&lt; float &gt; &amp;a, Array2D&lt; float &gt; &amp;b, Array2D&lt; float &gt; &amp;c, Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e)</td></tr>
<tr class="memdesc:aa4da58e27375a3609942872e1dd45341 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the profile curvature based on a polynomial fit.  <a href="#aa4da58e27375a3609942872e1dd45341">More...</a><br/></td></tr>
<tr class="separator:aa4da58e27375a3609942872e1dd45341 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5b09464e02fac88cf06563b4c16eb6 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aea5b09464e02fac88cf06563b4c16eb6">calculate_polyfit_tangential_curvature</a> (Array2D&lt; float &gt; &amp;a, Array2D&lt; float &gt; &amp;b, Array2D&lt; float &gt; &amp;c, Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e)</td></tr>
<tr class="memdesc:aea5b09464e02fac88cf06563b4c16eb6 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the tangential curvature based on a polynomial fit.  <a href="#aea5b09464e02fac88cf06563b4c16eb6">More...</a><br/></td></tr>
<tr class="separator:aea5b09464e02fac88cf06563b4c16eb6 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50913916b5a16f90470d5bf7b14741b7 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a50913916b5a16f90470d5bf7b14741b7">calculate_polyfit_classification</a> (Array2D&lt; float &gt; &amp;a, Array2D&lt; float &gt; &amp;b, Array2D&lt; float &gt; &amp;c, Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e)</td></tr>
<tr class="memdesc:a50913916b5a16f90470d5bf7b14741b7 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function identifies approximate position of stationary points within discrete surface using a threshold slope.  <a href="#a50913916b5a16f90470d5bf7b14741b7">More...</a><br/></td></tr>
<tr class="separator:a50913916b5a16f90470d5bf7b14741b7 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17fbce489da7ed4f49cab22f993cb0a inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad17fbce489da7ed4f49cab22f993cb0a">get_hilltop_curvature</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;curvature, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Hilltops)</td></tr>
<tr class="memdesc:ad17fbce489da7ed4f49cab22f993cb0a inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the hilltop curvature raster.  <a href="#ad17fbce489da7ed4f49cab22f993cb0a">More...</a><br/></td></tr>
<tr class="separator:ad17fbce489da7ed4f49cab22f993cb0a inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccac8e8ee1daaf3a6751e67b4874319 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a7ccac8e8ee1daaf3a6751e67b4874319">remove_positive_hilltop_curvature</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;hilltop_curvature)</td></tr>
<tr class="memdesc:a7ccac8e8ee1daaf3a6751e67b4874319 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes positive hilltop curvature values.  <a href="#a7ccac8e8ee1daaf3a6751e67b4874319">More...</a><br/></td></tr>
<tr class="separator:a7ccac8e8ee1daaf3a6751e67b4874319 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b5fecd2a59a3fedf8019f78d8adede inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae5b5fecd2a59a3fedf8019f78d8adede">remove_positive_values</a> ()</td></tr>
<tr class="memdesc:ae5b5fecd2a59a3fedf8019f78d8adede inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes positive values from a raster.  <a href="#ae5b5fecd2a59a3fedf8019f78d8adede">More...</a><br/></td></tr>
<tr class="separator:ae5b5fecd2a59a3fedf8019f78d8adede inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7b0e0fc28fae36bbfb37ad8efcb2ee inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2c7b0e0fc28fae36bbfb37ad8efcb2ee">get_percentage_bedrock_ridgetops</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;roughness, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;hilltop_curvature, float threshold)</td></tr>
<tr class="memdesc:a2c7b0e0fc28fae36bbfb37ad8efcb2ee inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the percentage of bedrock ridges.  <a href="#a2c7b0e0fc28fae36bbfb37ad8efcb2ee">More...</a><br/></td></tr>
<tr class="separator:a2c7b0e0fc28fae36bbfb37ad8efcb2ee inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398ed8c6898a690f851f49bef41e18f2 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a398ed8c6898a690f851f49bef41e18f2">calculate_slope_angles</a> ()</td></tr>
<tr class="memdesc:a398ed8c6898a690f851f49bef41e18f2 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates slope angle in radians. Needs the slope raster.  <a href="#a398ed8c6898a690f851f49bef41e18f2">More...</a><br/></td></tr>
<tr class="separator:a398ed8c6898a690f851f49bef41e18f2 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129887343a9122cb5b3fd65a3854e850 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a129887343a9122cb5b3fd65a3854e850">calculate_water_supply_rate_for_saturation</a> (float soil_thick, float K, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;ContributingArea, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;SlopeAngle)</td></tr>
<tr class="memdesc:a129887343a9122cb5b3fd65a3854e850 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the water supply rate required for saturation of the hillslope soil.  <a href="#a129887343a9122cb5b3fd65a3854e850">More...</a><br/></td></tr>
<tr class="separator:a129887343a9122cb5b3fd65a3854e850 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5caf033ba21aeec45e774595292be2c inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad5caf033ba21aeec45e774595292be2c">calculate_factor_of_safety_at_saturation</a> (float C_r, float rho_s, float soil_thick, float tan_phi, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;SlopeAngle)</td></tr>
<tr class="memdesc:ad5caf033ba21aeec45e774595292be2c inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This calculates the factor of safety if the soil is completely saturated.  <a href="#ad5caf033ba21aeec45e774595292be2c">More...</a><br/></td></tr>
<tr class="separator:ad5caf033ba21aeec45e774595292be2c inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0beaa7242443b3421ae97d5402752454 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a0beaa7242443b3421ae97d5402752454">calculate_polyfit_directional_cosines</a> (Array2D&lt; float &gt; &amp;d, Array2D&lt; float &gt; &amp;e, Array2D&lt; float &gt; &amp;l, Array2D&lt; float &gt; &amp;m, Array2D&lt; float &gt; &amp;n)</td></tr>
<tr class="memdesc:a0beaa7242443b3421ae97d5402752454 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithm that assesses surface roughness based on a polynomial fit.  <a href="#a0beaa7242443b3421ae97d5402752454">More...</a><br/></td></tr>
<tr class="separator:a0beaa7242443b3421ae97d5402752454 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae417692b85ad0880acdf60af4e61ea22 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae417692b85ad0880acdf60af4e61ea22">calculate_orientation_matrix_eigenvalues</a> (float window_radius, Array2D&lt; float &gt; &amp;l, Array2D&lt; float &gt; &amp;m, Array2D&lt; float &gt; &amp;n, Array2D&lt; float &gt; &amp;s1, Array2D&lt; float &gt; &amp;s2, Array2D&lt; float &gt; &amp;s3)</td></tr>
<tr class="memdesc:ae417692b85ad0880acdf60af4e61ea22 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find eigenvalues for orientation matrix.  <a href="#ae417692b85ad0880acdf60af4e61ea22">More...</a><br/></td></tr>
<tr class="separator:ae417692b85ad0880acdf60af4e61ea22 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfa6f1e75d776f505d3067816876f06 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aadfa6f1e75d776f505d3067816876f06">calculate_plane_coefficient_matrices</a> (float window_radius, Array2D&lt; float &gt; &amp;a_plane, Array2D&lt; float &gt; &amp;b_plane, Array2D&lt; float &gt; &amp;c_plane)</td></tr>
<tr class="memdesc:aadfa6f1e75d776f505d3067816876f06 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a wrapper to get the three roughness eigenvalues s1, s2 and s3.  <a href="#aadfa6f1e75d776f505d3067816876f06">More...</a><br/></td></tr>
<tr class="separator:aadfa6f1e75d776f505d3067816876f06 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a6dd434f0c62f00f0657cf79c7a4ea inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a17a6dd434f0c62f00f0657cf79c7a4ea">calculate_REI</a> (Array2D&lt; float &gt; &amp;a_plane, Array2D&lt; float &gt; &amp;b_plane, float CriticalSlope)</td></tr>
<tr class="memdesc:a17a6dd434f0c62f00f0657cf79c7a4ea inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the REI raster.  <a href="#a17a6dd434f0c62f00f0657cf79c7a4ea">More...</a><br/></td></tr>
<tr class="separator:a17a6dd434f0c62f00f0657cf79c7a4ea inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf94a0a1d208e3916b6c9fbd90c8c2fe inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abf94a0a1d208e3916b6c9fbd90c8c2fe">calculate_REI</a> (float window_radius, float CriticalSlope)</td></tr>
<tr class="memdesc:abf94a0a1d208e3916b6c9fbd90c8c2fe inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the REI raster (imporoved wrapper) Rock exposure index defined as areas with local slope exceeding some critical slope as defined by DiBiase et al. (2012)  <a href="#abf94a0a1d208e3916b6c9fbd90c8c2fe">More...</a><br/></td></tr>
<tr class="separator:abf94a0a1d208e3916b6c9fbd90c8c2fe inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca50a43384109d85912fb825f1250c44 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aca50a43384109d85912fb825f1250c44">calculate_and_print_polyfit_rasters</a> (float window_radius, string file_prefix, vector&lt; int &gt; file_list)</td></tr>
<tr class="memdesc:aca50a43384109d85912fb825f1250c44 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function takes the polyfit functions and requires a window radius and a vector telling the function which rasters to print to file.  <a href="#aca50a43384109d85912fb825f1250c44">More...</a><br/></td></tr>
<tr class="separator:aca50a43384109d85912fb825f1250c44 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae206ccc0de12e1b0dfa6ae1370337898 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae206ccc0de12e1b0dfa6ae1370337898">calculate_and_print_polyfit_and_roughness_rasters</a> (float window_radius, float roughness_radius, string file_prefix, vector&lt; int &gt; file_list)</td></tr>
<tr class="memdesc:ae206ccc0de12e1b0dfa6ae1370337898 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the combines the polyfit functions and the roughness function in one package.  <a href="#ae206ccc0de12e1b0dfa6ae1370337898">More...</a><br/></td></tr>
<tr class="separator:ae206ccc0de12e1b0dfa6ae1370337898 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ec635af20e1808fdd245d4f61d2fd5 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad0ec635af20e1808fdd245d4f61d2fd5">calculate_roughness_rasters</a> (float window_radius, float roughness_radius, string file_prefix, vector&lt; int &gt; file_code)</td></tr>
<tr class="memdesc:ad0ec635af20e1808fdd245d4f61d2fd5 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the combines the roughness functions in one package.  <a href="#ad0ec635af20e1808fdd245d4f61d2fd5">More...</a><br/></td></tr>
<tr class="separator:ad0ec635af20e1808fdd245d4f61d2fd5 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe32afe622883ef703bbac4d997ad7a1 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abe32afe622883ef703bbac4d997ad7a1">remove_seas</a> ()</td></tr>
<tr class="memdesc:abe32afe622883ef703bbac4d997ad7a1 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function changes any elevation &lt;= 0 to NoDataValue.  <a href="#abe32afe622883ef703bbac4d997ad7a1">More...</a><br/></td></tr>
<tr class="separator:abe32afe622883ef703bbac4d997ad7a1 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26453b71595e28f065cd383e585f05a inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae26453b71595e28f065cd383e585f05a">mask_to_nodata_below_threshold</a> (float threshold)</td></tr>
<tr class="memdesc:ae26453b71595e28f065cd383e585f05a inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function changes any elevation &lt;= threshold to NoDataValue.  <a href="#ae26453b71595e28f065cd383e585f05a">More...</a><br/></td></tr>
<tr class="separator:ae26453b71595e28f065cd383e585f05a inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1786c3a7aecae312c603b8c4468202b5 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a1786c3a7aecae312c603b8c4468202b5">mask_to_nodata_using_threshold</a> (float threshold, bool belowthresholdisnodata)</td></tr>
<tr class="memdesc:a1786c3a7aecae312c603b8c4468202b5 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function changes any data point either above or below threshold to NoDataValue.  <a href="#a1786c3a7aecae312c603b8c4468202b5">More...</a><br/></td></tr>
<tr class="separator:a1786c3a7aecae312c603b8c4468202b5 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f9ec033f242844ee71dbbfd6ce77f8 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aa2f9ec033f242844ee71dbbfd6ce77f8">mask_to_nodata_using_threshold_using_other_raster</a> (float threshold, bool belowthresholdisnodata, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;MaskingRaster)</td></tr>
<tr class="memdesc:aa2f9ec033f242844ee71dbbfd6ce77f8 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function changes any data point either above or below threshold to NoDataValue The threshold is determined by a second raster.  <a href="#aa2f9ec033f242844ee71dbbfd6ce77f8">More...</a><br/></td></tr>
<tr class="separator:aa2f9ec033f242844ee71dbbfd6ce77f8 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ea0cf684b50c7857ae2eff6942f181 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a66ea0cf684b50c7857ae2eff6942f181">mask_to_indexraster_using_threshold</a> (float threshold, bool belowthresholdisnodata)</td></tr>
<tr class="memdesc:a66ea0cf684b50c7857ae2eff6942f181 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creats an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> mask (with true == 1 and otherwise nodata) from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. Can mask either above or below a threshold.  <a href="#a66ea0cf684b50c7857ae2eff6942f181">More...</a><br/></td></tr>
<tr class="separator:a66ea0cf684b50c7857ae2eff6942f181 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a75facf0f59d77d39d9e908e4d3ea4 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#af9a75facf0f59d77d39d9e908e4d3ea4">mask_to_nodata_with_mask_raster</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Mask_raster, int mask_value)</td></tr>
<tr class="memdesc:af9a75facf0f59d77d39d9e908e4d3ea4 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function masks a raster to nodata based on a mask value and a mask raster.  <a href="#af9a75facf0f59d77d39d9e908e4d3ea4">More...</a><br/></td></tr>
<tr class="separator:af9a75facf0f59d77d39d9e908e4d3ea4 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef40878b1deabc0c81c79a9675eb1890 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aef40878b1deabc0c81c79a9675eb1890">fill</a> ()</td></tr>
<tr class="memdesc:aef40878b1deabc0c81c79a9675eb1890 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills pits/sinks in a DEM by incrementing elevations for cells with no downslope neighbour. The process is repeated adnausium until no cells require incrementing.  <a href="#aef40878b1deabc0c81c79a9675eb1890">More...</a><br/></td></tr>
<tr class="separator:aef40878b1deabc0c81c79a9675eb1890 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29cb6b8a0ceeeaa361b94197e0e0f09 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab29cb6b8a0ceeeaa361b94197e0e0f09">fill_iterator</a> (Array2D&lt; float &gt; &amp;fill_data, int i, int j)</td></tr>
<tr class="memdesc:ab29cb6b8a0ceeeaa361b94197e0e0f09 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a recursive algorithm that is called by the fill function.  <a href="#ab29cb6b8a0ceeeaa361b94197e0e0f09">More...</a><br/></td></tr>
<tr class="separator:ab29cb6b8a0ceeeaa361b94197e0e0f09 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8464ee1d76a8b6b4de78e828400e727 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac8464ee1d76a8b6b4de78e828400e727">fill</a> (float &amp;MinSlope)</td></tr>
<tr class="memdesc:ac8464ee1d76a8b6b4de78e828400e727 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills pits/sinks in a DEM by checking for pits from lowest to highest elevation, starting at the DEM boundary (raster edge or adjacent to NDVs).  <a href="#ac8464ee1d76a8b6b4de78e828400e727">More...</a><br/></td></tr>
<tr class="separator:ac8464ee1d76a8b6b4de78e828400e727 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2f4870e7575dcc983845eaab2c976d inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#afe2f4870e7575dcc983845eaab2c976d">MDFlow</a> (vector&lt; string &gt; BoundaryConditions)</td></tr>
<tr class="memdesc:afe2f4870e7575dcc983845eaab2c976d inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a flow area raster using a multi direction algorithm.  <a href="#afe2f4870e7575dcc983845eaab2c976d">More...</a><br/></td></tr>
<tr class="separator:afe2f4870e7575dcc983845eaab2c976d inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167eac046b8207dc711962847f737ccc inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a167eac046b8207dc711962847f737ccc">FreemanMDFlow</a> ()</td></tr>
<tr class="memdesc:a167eac046b8207dc711962847f737ccc inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a flow area raster using a multi direction algorithm.  <a href="#a167eac046b8207dc711962847f737ccc">More...</a><br/></td></tr>
<tr class="separator:a167eac046b8207dc711962847f737ccc inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496d804e34d7ec4c030d6eea2ae90cb2 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a496d804e34d7ec4c030d6eea2ae90cb2">FreemanMDFlow_SingleSource</a> (int i_source, int j_source)</td></tr>
<tr class="memdesc:a496d804e34d7ec4c030d6eea2ae90cb2 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Route flow from one source pixel using FreemanMDFlow. Adapted from SWDG's code above.  <a href="#a496d804e34d7ec4c030d6eea2ae90cb2">More...</a><br/></td></tr>
<tr class="separator:a496d804e34d7ec4c030d6eea2ae90cb2 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fa0ff6fdbb7700d35d594c24d39cc5 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ad8fa0ff6fdbb7700d35d594c24d39cc5">FMDChannelsFromChannelHeads</a> (vector&lt; int &gt; &amp;channel_heads_rows, vector&lt; int &gt; &amp;channel_heads_cols, float R_threshold)</td></tr>
<tr class="memdesc:ad8fa0ff6fdbb7700d35d594c24d39cc5 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a multi-pixel channel network, as opposed to a single thread channel, using method outlined in Pelletier, 2013, WRR; A robust, two-parameter method for the extraction of drainage networks from high-resolution digital elevation models (DEMs): Evaluation using synthetic and real-world DEMs.  <a href="#ad8fa0ff6fdbb7700d35d594c24d39cc5">More...</a><br/></td></tr>
<tr class="separator:ad8fa0ff6fdbb7700d35d594c24d39cc5 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e484a0efe3df226c1ecf69d11eb114b inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a5e484a0efe3df226c1ecf69d11eb114b">QuinnMDFlow</a> ()</td></tr>
<tr class="memdesc:a5e484a0efe3df226c1ecf69d11eb114b inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a flow area raster using a multi direction algorithm.  <a href="#a5e484a0efe3df226c1ecf69d11eb114b">More...</a><br/></td></tr>
<tr class="separator:a5e484a0efe3df226c1ecf69d11eb114b inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9629de0411ee55d57b9f3b7020265d0f inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a9629de0411ee55d57b9f3b7020265d0f">M2DFlow</a> ()</td></tr>
<tr class="memdesc:a9629de0411ee55d57b9f3b7020265d0f inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a flow area raster using a multi 2-direction algorithm.  <a href="#a9629de0411ee55d57b9f3b7020265d0f">More...</a><br/></td></tr>
<tr class="separator:a9629de0411ee55d57b9f3b7020265d0f inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca4a22a3e5ea44a2eb2d0224ec40766 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#afca4a22a3e5ea44a2eb2d0224ec40766">RidgeSample</a> (Array2D&lt; float &gt; &amp;Ridges)</td></tr>
<tr class="memdesc:afca4a22a3e5ea44a2eb2d0224ec40766 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module to sample <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> values running along a ridgetop network.  <a href="#afca4a22a3e5ea44a2eb2d0224ec40766">More...</a><br/></td></tr>
<tr class="separator:afca4a22a3e5ea44a2eb2d0224ec40766 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83502ee2ffab4935277aec652ab4a789 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a83502ee2ffab4935277aec652ab4a789">RidgeSmoother</a> (int WindowRadius)</td></tr>
<tr class="memdesc:a83502ee2ffab4935277aec652ab4a789 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass a smoothing window over a ridge <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object to calculate an average value running along the ridgetop.  <a href="#a83502ee2ffab4935277aec652ab4a789">More...</a><br/></td></tr>
<tr class="separator:a83502ee2ffab4935277aec652ab4a789 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21318933bf408b932c053465d0f0aa7a inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a21318933bf408b932c053465d0f0aa7a">RidgeBuffer</a> (int BufferRadius)</td></tr>
<tr class="memdesc:a21318933bf408b932c053465d0f0aa7a inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass a buffer over a ridge <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object to increase sampling area.  <a href="#a21318933bf408b932c053465d0f0aa7a">More...</a><br/></td></tr>
<tr class="separator:a21318933bf408b932c053465d0f0aa7a inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d6f6dc51982fb2a57fb8cda09d53b6 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab4d6f6dc51982fb2a57fb8cda09d53b6">BasinAverager</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Basins)</td></tr>
<tr class="memdesc:ab4d6f6dc51982fb2a57fb8cda09d53b6 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module assigns an average <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> value to each basin.  <a href="#ab4d6f6dc51982fb2a57fb8cda09d53b6">More...</a><br/></td></tr>
<tr class="separator:ab4d6f6dc51982fb2a57fb8cda09d53b6 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c7f7dcdd605a47e0413d1fd08927bd inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a28c7f7dcdd605a47e0413d1fd08927bd">SingleBasinAverager</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Basin)</td></tr>
<tr class="memdesc:a28c7f7dcdd605a47e0413d1fd08927bd inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module calculates an average value to each for a given raster from within a basin.  <a href="#a28c7f7dcdd605a47e0413d1fd08927bd">More...</a><br/></td></tr>
<tr class="separator:a28c7f7dcdd605a47e0413d1fd08927bd inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d26db29e36eb4d025f03d01a10577c inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a54d26db29e36eb4d025f03d01a10577c">BasinArea</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Basins)</td></tr>
<tr class="memdesc:a54d26db29e36eb4d025f03d01a10577c inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the area(in spatial units) of each basin to the basin's pixels.  <a href="#a54d26db29e36eb4d025f03d01a10577c">More...</a><br/></td></tr>
<tr class="separator:a54d26db29e36eb4d025f03d01a10577c inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32129c11234059809449a3619d2bd84f inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a32129c11234059809449a3619d2bd84f">GetBasinVector</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Basins, int BasinOfInterest)</td></tr>
<tr class="memdesc:a32129c11234059809449a3619d2bd84f inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a basin, given by a basin ID, into a chain of xy coordinates for fast plotting of vector basin outlines.  <a href="#a32129c11234059809449a3619d2bd84f">More...</a><br/></td></tr>
<tr class="separator:a32129c11234059809449a3619d2bd84f inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0215007ed0ee4132dc409687be0a89 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aca0215007ed0ee4132dc409687be0a89">BasinPuncher</a> (vector&lt; int &gt; basin_ids, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> BasinArray)</td></tr>
<tr class="memdesc:aca0215007ed0ee4132dc409687be0a89 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Punch basins out of an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to create DEMs of a single catchment.  <a href="#aca0215007ed0ee4132dc409687be0a89">More...</a><br/></td></tr>
<tr class="separator:aca0215007ed0ee4132dc409687be0a89 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ab990fdcde1aa7d4c2cfcfa3124ad8 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae2ab990fdcde1aa7d4c2cfcfa3124ad8">CookieCutRaster</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Cutter)</td></tr>
<tr class="memdesc:ae2ab990fdcde1aa7d4c2cfcfa3124ad8 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cookie cut a raster using a smaller raster.  <a href="#ae2ab990fdcde1aa7d4c2cfcfa3124ad8">More...</a><br/></td></tr>
<tr class="separator:ae2ab990fdcde1aa7d4c2cfcfa3124ad8 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879a99a63a916a31a2c8eb868733eccd inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a879a99a63a916a31a2c8eb868733eccd">CollectBasinMetrics</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Basins, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Slope, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Elevation, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Aspect, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Area, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;<a class="el" href="class_l_s_d_raster.html#acb6d3568dc1191e7b69b6606602ac515">DrainageDensity</a>, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Cht, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;HillslopeLength, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;MeanSlope, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Relief, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;MeanAspect, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;LH_drainage_density, Array2D&lt; float &gt; LH_Data, float CriticalSlope, string RasterFilename)</td></tr>
<tr class="memdesc:a879a99a63a916a31a2c8eb868733eccd inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all basin average metrics into a single file.  <a href="#a879a99a63a916a31a2c8eb868733eccd">More...</a><br/></td></tr>
<tr class="separator:a879a99a63a916a31a2c8eb868733eccd inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0173327e0a52943052f8a3486c382e inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aeb0173327e0a52943052f8a3486c382e">raster_statistics_by_index</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;IndexRaster, vector&lt; float &gt; &amp;mean_vector, vector&lt; float &gt; &amp;sd_vector, vector&lt; float &gt; &amp;serr_vector, vector&lt; int &gt; &amp;Npts_vector)</td></tr>
<tr class="memdesc:aeb0173327e0a52943052f8a3486c382e inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a raster and a corresponding index raster, and calculates the mean, sd and standard error by index. Returns four vectors: mean, st.dev., st.err and Number of points for each category.  <a href="#aeb0173327e0a52943052f8a3486c382e">More...</a><br/></td></tr>
<tr class="separator:aeb0173327e0a52943052f8a3486c382e inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ceb6c4b936bb1b7bc8120f1e34cc2a inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">pair&lt; float, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab6ceb6c4b936bb1b7bc8120f1e34cc2a">Boomerang</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Slope, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;<a class="el" href="class_l_s_d_raster.html#a331723d71e095e496a4467578e26dafb">D_inf</a>, string RasterFilename, float log_bin_width=0.1, int SplineResolution=200, float bin_threshold=0.05)</td></tr>
<tr class="memdesc:ab6ceb6c4b936bb1b7bc8120f1e34cc2a inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate data in two text files to create a boomerang plot as in Roering et al [2007].  <a href="#ab6ceb6c4b936bb1b7bc8120f1e34cc2a">More...</a><br/></td></tr>
<tr class="separator:ab6ceb6c4b936bb1b7bc8120f1e34cc2a inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6d3568dc1191e7b69b6606602ac515 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acb6d3568dc1191e7b69b6606602ac515">DrainageDensity</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;StreamNetwork, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Basins, Array2D&lt; int &gt; FlowDir)</td></tr>
<tr class="memdesc:acb6d3568dc1191e7b69b6606602ac515 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate drainage density of a set of input basins.  <a href="#acb6d3568dc1191e7b69b6606602ac515">More...</a><br/></td></tr>
<tr class="separator:acb6d3568dc1191e7b69b6606602ac515 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a65dc8420e194476046570ee04e802 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a75a65dc8420e194476046570ee04e802">get_drainage_density_of_raster</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;StreamNetwork, Array2D&lt; int &gt; FlowDir)</td></tr>
<tr class="memdesc:a75a65dc8420e194476046570ee04e802 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate drainage density of a DEM.  <a href="#a75a65dc8420e194476046570ee04e802">More...</a><br/></td></tr>
<tr class="separator:a75a65dc8420e194476046570ee04e802 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3618df18dc9c4b0e4aa8f087100053a inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae3618df18dc9c4b0e4aa8f087100053a">HillslopeLengthFromDrainageDensity</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;StreamNetwork, <a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;Basins, Array2D&lt; int &gt; FlowDir)</td></tr>
<tr class="memdesc:ae3618df18dc9c4b0e4aa8f087100053a inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple method to calculate drainage density for each basin and then convert these values into a hillslope length raster.  <a href="#ae3618df18dc9c4b0e4aa8f087100053a">More...</a><br/></td></tr>
<tr class="separator:ae3618df18dc9c4b0e4aa8f087100053a inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc088f9b26e7c925781a01b69a974e3b inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#afc088f9b26e7c925781a01b69a974e3b">GetVectors</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Magnitude, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> Direction, string output_file, int step)</td></tr>
<tr class="memdesc:afc088f9b26e7c925781a01b69a974e3b inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to export thinned vector field data to a text file.  <a href="#afc088f9b26e7c925781a01b69a974e3b">More...</a><br/></td></tr>
<tr class="separator:afc088f9b26e7c925781a01b69a974e3b inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070a492ed5f8c076fe1fa27653117654 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a070a492ed5f8c076fe1fa27653117654">NonLocalMeansFilter</a> (int WindowRadius=2, int SimilarityRadius=2, int DegreeFiltering=2, float Sigma=1.25)</td></tr>
<tr class="memdesc:a070a492ed5f8c076fe1fa27653117654 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform Non-local means filtering on a DEM following Baude et al [2005].  <a href="#a070a492ed5f8c076fe1fa27653117654">More...</a><br/></td></tr>
<tr class="separator:a070a492ed5f8c076fe1fa27653117654 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f8489f6abf33725b90fd1e1b88aded inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a15f8489f6abf33725b90fd1e1b88aded">PadRasterSymmetric</a> (Array2D&lt; float &gt; &amp;PaddedRasterData, int &amp;SimilarityRadius)</td></tr>
<tr class="memdesc:a15f8489f6abf33725b90fd1e1b88aded inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer around an array (of size SimilarityRadius) and gives the new border mirror symmetric values of the original array reflected across the boundary.  <a href="#a15f8489f6abf33725b90fd1e1b88aded">More...</a><br/></td></tr>
<tr class="separator:a15f8489f6abf33725b90fd1e1b88aded inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fa514549d4c6fbd9d662639cf433b7 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a69fa514549d4c6fbd9d662639cf433b7">MakeGaussianKernel</a> (Array2D&lt; float &gt; &amp;Kernel, float sigma, int SimilarityRadius)</td></tr>
<tr class="memdesc:a69fa514549d4c6fbd9d662639cf433b7 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate gaussian weighted kernel.  <a href="#a69fa514549d4c6fbd9d662639cf433b7">More...</a><br/></td></tr>
<tr class="separator:a69fa514549d4c6fbd9d662639cf433b7 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6136e17477083dcb28e0c60fdf14038 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aa6136e17477083dcb28e0c60fdf14038">GaussianFilter</a> (float sigma, int kr=0)</td></tr>
<tr class="memdesc:aa6136e17477083dcb28e0c60fdf14038 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the raster using a square 2D Gaussian filter. The filter is applied using a moving kernel of gaussian weights with a radius of 3*sigma.  <a href="#aa6136e17477083dcb28e0c60fdf14038">More...</a><br/></td></tr>
<tr class="separator:aa6136e17477083dcb28e0c60fdf14038 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e482d20d43327c6ee6e2f6190dbe736 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2e482d20d43327c6ee6e2f6190dbe736">PeronaMalikFilter</a> (int timesteps, float percentile_for_lambda, float dt)</td></tr>
<tr class="memdesc:a2e482d20d43327c6ee6e2f6190dbe736 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the raster using a Perona-Malik non-linear diffusion filter.  <a href="#a2e482d20d43327c6ee6e2f6190dbe736">More...</a><br/></td></tr>
<tr class="separator:a2e482d20d43327c6ee6e2f6190dbe736 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ed6f1737d703a6e2db5fa385e59dfd inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a23ed6f1737d703a6e2db5fa385e59dfd">D_inf_FlowDir</a> ()</td></tr>
<tr class="memdesc:a23ed6f1737d703a6e2db5fa385e59dfd inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">D-infinity flow direction algorithm after Tarboton (1997).  <a href="#a23ed6f1737d703a6e2db5fa385e59dfd">More...</a><br/></td></tr>
<tr class="separator:a23ed6f1737d703a6e2db5fa385e59dfd inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b70073ef6f1a23ae832c98c2e087ee inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae8b70073ef6f1a23ae832c98c2e087ee">D_inf_FlowArea</a> (Array2D&lt; float &gt; FlowDir_array)</td></tr>
<tr class="memdesc:ae8b70073ef6f1a23ae832c98c2e087ee inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function for generating a D-infinity flow area raster after Tarboton (1997).  <a href="#ae8b70073ef6f1a23ae832c98c2e087ee">More...</a><br/></td></tr>
<tr class="separator:ae8b70073ef6f1a23ae832c98c2e087ee inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8177cf5be3dd00700a04f72722676cd inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab8177cf5be3dd00700a04f72722676cd">D_infAccum</a> (int i, int j, Array2D&lt; float &gt; CountGrid, Array2D&lt; float &gt; Flowarea_Raster, Array2D&lt; float &gt; FlowDir_array)</td></tr>
<tr class="memdesc:ab8177cf5be3dd00700a04f72722676cd inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive function to calculate accumulating area for a given pixel.  <a href="#ab8177cf5be3dd00700a04f72722676cd">More...</a><br/></td></tr>
<tr class="separator:ab8177cf5be3dd00700a04f72722676cd inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331723d71e095e496a4467578e26dafb inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a331723d71e095e496a4467578e26dafb">D_inf</a> ()</td></tr>
<tr class="memdesc:a331723d71e095e496a4467578e26dafb inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper Function to create a D-infinity flow area raster with one function call.  <a href="#a331723d71e095e496a4467578e26dafb">More...</a><br/></td></tr>
<tr class="separator:a331723d71e095e496a4467578e26dafb inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddb73dd9d50df2c09422da36bfad0f9 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#adddb73dd9d50df2c09422da36bfad0f9">D_inf_units</a> ()</td></tr>
<tr class="memdesc:adddb73dd9d50df2c09422da36bfad0f9 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper Function to create a D-infinity flow area raster, in spatial units, with one function call.  <a href="#adddb73dd9d50df2c09422da36bfad0f9">More...</a><br/></td></tr>
<tr class="separator:adddb73dd9d50df2c09422da36bfad0f9 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe51c2dd1980080101ce669301d426f inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2fe51c2dd1980080101ce669301d426f">D_inf_ConvertFlowToArea</a> ()</td></tr>
<tr class="memdesc:a2fe51c2dd1980080101ce669301d426f inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper Function to convert a D-infinity flow raster into spatial units.  <a href="#a2fe51c2dd1980080101ce669301d426f">More...</a><br/></td></tr>
<tr class="separator:a2fe51c2dd1980080101ce669301d426f inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef35a4944909540182a86f86fc7a20a5 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aef35a4944909540182a86f86fc7a20a5">write_dinf_flowdir_to_LSDRaster</a> (Array2D&lt; float &gt; dinflow)</td></tr>
<tr class="memdesc:aef35a4944909540182a86f86fc7a20a5 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to write the D-infinity flow directions to an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>.  <a href="#aef35a4944909540182a86f86fc7a20a5">More...</a><br/></td></tr>
<tr class="separator:aef35a4944909540182a86f86fc7a20a5 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d61141306c7b413b7f2528836ceeb1 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac3d61141306c7b413b7f2528836ceeb1">D_inf_watershed</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> <a class="el" href="class_l_s_d_raster.html#a23ed6f1737d703a6e2db5fa385e59dfd">D_inf_FlowDir</a>, int PourRow, int PourCol)</td></tr>
<tr class="memdesc:ac3d61141306c7b413b7f2528836ceeb1 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to generate upslope contributing area extent from the D-infinity flow directions to an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>.  <a href="#ac3d61141306c7b413b7f2528836ceeb1">More...</a><br/></td></tr>
<tr class="separator:ac3d61141306c7b413b7f2528836ceeb1 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3948a815d7a5634834a42a9ae7e5cd58 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a3948a815d7a5634834a42a9ae7e5cd58">calculate_topographic_index</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;AccumulationArea, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Slope)</td></tr>
<tr class="memdesc:a3948a815d7a5634834a42a9ae7e5cd58 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the topographic index, a moisture distribution indicator.  <a href="#a3948a815d7a5634834a42a9ae7e5cd58">More...</a><br/></td></tr>
<tr class="separator:a3948a815d7a5634834a42a9ae7e5cd58 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25df4b9a8c3ddc1c7db18fb44bc2b6e inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac25df4b9a8c3ddc1c7db18fb44bc2b6e">PointShapefileToRaster</a> (string FileName)</td></tr>
<tr class="memdesc:ac25df4b9a8c3ddc1c7db18fb44bc2b6e inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to turn a point shapefile into an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>.  <a href="#ac25df4b9a8c3ddc1c7db18fb44bc2b6e">More...</a><br/></td></tr>
<tr class="separator:ac25df4b9a8c3ddc1c7db18fb44bc2b6e inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682b6387335aef59febeda5c49598a04 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a682b6387335aef59febeda5c49598a04">PolylineShapefileToRaster</a> (string FileName)</td></tr>
<tr class="memdesc:a682b6387335aef59febeda5c49598a04 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to turn a polyline shapefile into an <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a>.  <a href="#a682b6387335aef59febeda5c49598a04">More...</a><br/></td></tr>
<tr class="separator:a682b6387335aef59febeda5c49598a04 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdc54eca6f5b0807d424fd981a85971 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aafdc54eca6f5b0807d424fd981a85971">Resample</a> (float OutputResolution)</td></tr>
<tr class="memdesc:aafdc54eca6f5b0807d424fd981a85971 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to resample an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to a lower resolution.  <a href="#aafdc54eca6f5b0807d424fd981a85971">More...</a><br/></td></tr>
<tr class="separator:aafdc54eca6f5b0807d424fd981a85971 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0766768246987cca6e55f0849107778b inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a0766768246987cca6e55f0849107778b">create_mask</a> (float window_radius, int neighbourhood_switch)</td></tr>
<tr class="memdesc:a0766768246987cca6e55f0849107778b inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a circular mask for neighbourhood statistics  <a href="#a0766768246987cca6e55f0849107778b">More...</a><br/></td></tr>
<tr class="separator:a0766768246987cca6e55f0849107778b inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3f409837c842162c26ad80036baa24 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#add3f409837c842162c26ad80036baa24">neighbourhood_statistics_spatial_average</a> (float window_radius, int neighbourhood_switch)</td></tr>
<tr class="memdesc:add3f409837c842162c26ad80036baa24 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets mean value for specified circular neighbourhood  <a href="#add3f409837c842162c26ad80036baa24">More...</a><br/></td></tr>
<tr class="separator:add3f409837c842162c26ad80036baa24 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb71a579a1f8e5bf5847b1e61b374ba4 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acb71a579a1f8e5bf5847b1e61b374ba4">neighbourhood_statistics_spatial_average_and_SD</a> (float window_radius, int neighbourhood_switch)</td></tr>
<tr class="memdesc:acb71a579a1f8e5bf5847b1e61b374ba4 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets mean &amp; standard deviation value specified circular neighbourhood  <a href="#acb71a579a1f8e5bf5847b1e61b374ba4">More...</a><br/></td></tr>
<tr class="separator:acb71a579a1f8e5bf5847b1e61b374ba4 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3d1d5ceab7f16949a14c19c7abbc18 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aca3d1d5ceab7f16949a14c19c7abbc18">neighbourhood_statistics_local_relief</a> (float window_radius, int neighbourhood_switch)</td></tr>
<tr class="memdesc:aca3d1d5ceab7f16949a14c19c7abbc18 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets relief within value specified circular neighbourhood  <a href="#aca3d1d5ceab7f16949a14c19c7abbc18">More...</a><br/></td></tr>
<tr class="separator:aca3d1d5ceab7f16949a14c19c7abbc18 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058821368f5f48758cf102062f691ace inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a058821368f5f48758cf102062f691ace">neighbourhood_statistics_fraction_condition</a> (float window_radius, int neighbourhood_switch, int condition_switch, float test_value)</td></tr>
<tr class="memdesc:a058821368f5f48758cf102062f691ace inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests neighbourhood for the fraction of values for which the specified condition is met.  <a href="#a058821368f5f48758cf102062f691ace">More...</a><br/></td></tr>
<tr class="separator:a058821368f5f48758cf102062f691ace inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a190d2415b9087054b44a1b577c3ed inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a42a190d2415b9087054b44a1b577c3ed">border_with_nodata</a> (int border_width, int irregular_switch=0)</td></tr>
<tr class="memdesc:a42a190d2415b9087054b44a1b577c3ed inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to change border pixels to nodata.  <a href="#a42a190d2415b9087054b44a1b577c3ed">More...</a><br/></td></tr>
<tr class="separator:a42a190d2415b9087054b44a1b577c3ed inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48280de81ceb10c1b509676e632a2cb inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#af48280de81ceb10c1b509676e632a2cb">find_cells_bordered_by_nodata</a> ()</td></tr>
<tr class="memdesc:af48280de81ceb10c1b509676e632a2cb inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a mask that has the value of 1 for cells that are either on the edge or bordered by nodata (from their 9 neighbors)  <a href="#af48280de81ceb10c1b509676e632a2cb">More...</a><br/></td></tr>
<tr class="separator:af48280de81ceb10c1b509676e632a2cb inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72361701912660a064734779ef60954b inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a72361701912660a064734779ef60954b">check_isolated_nodata</a> ()</td></tr>
<tr class="memdesc:a72361701912660a064734779ef60954b inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This looks for isolated instances of no data.  <a href="#a72361701912660a064734779ef60954b">More...</a><br/></td></tr>
<tr class="separator:a72361701912660a064734779ef60954b inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32042e55758bdf70dd50f631727fc787 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a32042e55758bdf70dd50f631727fc787">rudimentary_nodata_fill</a> ()</td></tr>
<tr class="memdesc:a32042e55758bdf70dd50f631727fc787 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">a very rudimentay filling routine that just fills nodata nodes with the average elevation of its neighbors  <a href="#a32042e55758bdf70dd50f631727fc787">More...</a><br/></td></tr>
<tr class="separator:a32042e55758bdf70dd50f631727fc787 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e94622f9b8a1558bdba2bbb50829764 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a4e94622f9b8a1558bdba2bbb50829764">alternating_direction_nodata_fill</a> (int window_width)</td></tr>
<tr class="memdesc:a4e94622f9b8a1558bdba2bbb50829764 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that fills nodata holes. It cannot recognise nodata around the edges so the spiral trimmer should be used first  The routine sweeps the raster looking for nodata and filling this nodata with an average value from surrounding nodes. The sweeping changes directions, four sweep directions in all (+ rows, - rows, + cols, -cols) and it alternates between these directions until the raster is filled.  <a href="#a4e94622f9b8a1558bdba2bbb50829764">More...</a><br/></td></tr>
<tr class="separator:a4e94622f9b8a1558bdba2bbb50829764 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4900b2a06bf880a98ed09c12d394c392 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a4900b2a06bf880a98ed09c12d394c392">create_binary_isdata_raster</a> ()</td></tr>
<tr class="memdesc:a4900b2a06bf880a98ed09c12d394c392 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns an index raster with 1 for data and 0 for nodata.  <a href="#a4900b2a06bf880a98ed09c12d394c392">More...</a><br/></td></tr>
<tr class="separator:a4900b2a06bf880a98ed09c12d394c392 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4083c73f25904c819f4a6dc5e84f03e4 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a4083c73f25904c819f4a6dc5e84f03e4">alternating_direction_nodata_fill_with_trimmer</a> (int window_width)</td></tr>
<tr class="memdesc:a4083c73f25904c819f4a6dc5e84f03e4 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that fills nodata holes. It first prepares the data with the sprial trimmer so nodata around the edges is removed.  The routine sweeps the raster looking for nodata and filling this nodata with an average value from surrounding nodes. The sweeping changes directions, four sweep directions in all (+ rows, - rows, + cols, -cols) and it alternates between these directions until the raster is filled. The routine is particularly useful for data with holes that is to be prepared for spectral analysis.  <a href="#a4083c73f25904c819f4a6dc5e84f03e4">More...</a><br/></td></tr>
<tr class="separator:a4083c73f25904c819f4a6dc5e84f03e4 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2709b4b8c999a6a5b504a0383381fa inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf2709b4b8c999a6a5b504a0383381fa"></a>
<a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acf2709b4b8c999a6a5b504a0383381fa">nodata_fill_irregular_raster</a> (int window_radius)</td></tr>
<tr class="memdesc:acf2709b4b8c999a6a5b504a0383381fa inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to fill in no data holes in an irregular raster. Pixel must have all neighbours not equal to no data value within the specified window radius. Data is filled based on mean of pixels within the window radius. <br/></td></tr>
<tr class="separator:acf2709b4b8c999a6a5b504a0383381fa inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44ce1cb61d914e03738c608e543208f inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab44ce1cb61d914e03738c608e543208f">alternating_direction_nodata_fill_irregular_raster</a> (int window_width)</td></tr>
<tr class="memdesc:ab44ce1cb61d914e03738c608e543208f inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that fills nodata holes. Modified by FJC to only fill holes surrounded in all directions by pixels with valid elevation values.  <a href="#ab44ce1cb61d914e03738c608e543208f">More...</a><br/></td></tr>
<tr class="separator:ab44ce1cb61d914e03738c608e543208f inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcb6e797d48233ac7fa06ff64c41409 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acdcb6e797d48233ac7fa06ff64c41409">Create_Mask</a> (string Condition, float TestValue)</td></tr>
<tr class="memdesc:acdcb6e797d48233ac7fa06ff64c41409 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a masked <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> raster based on a conditional statement.  <a href="#acdcb6e797d48233ac7fa06ff64c41409">More...</a><br/></td></tr>
<tr class="separator:acdcb6e797d48233ac7fa06ff64c41409 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869906150040117268fdad50b81402b9 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a869906150040117268fdad50b81402b9">ExtractByMask</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Mask)</td></tr>
<tr class="memdesc:a869906150040117268fdad50b81402b9 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to extract an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> based on a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> mask.  <a href="#a869906150040117268fdad50b81402b9">More...</a><br/></td></tr>
<tr class="separator:a869906150040117268fdad50b81402b9 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821d1f21bc4b3eb32b61e92a56f95982 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a821d1f21bc4b3eb32b61e92a56f95982">MaskRaster</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> Mask)</td></tr>
<tr class="memdesc:a821d1f21bc4b3eb32b61e92a56f95982 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> based on a <a class="el" href="class_l_s_d_index_raster.html" title="Object to handle integer rasters. ">LSDIndexRaster</a> mask.  <a href="#a821d1f21bc4b3eb32b61e92a56f95982">More...</a><br/></td></tr>
<tr class="separator:a821d1f21bc4b3eb32b61e92a56f95982 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4859921d32b0ff29fad31f89ec8b941 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#af4859921d32b0ff29fad31f89ec8b941">IsolateChannelsLashermesCurvature</a> (float sigma, string q_q_filename)</td></tr>
<tr class="memdesc:af4859921d32b0ff29fad31f89ec8b941 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to locate channel pixels outlined by Lashermes.  <a href="#af4859921d32b0ff29fad31f89ec8b941">More...</a><br/></td></tr>
<tr class="separator:af4859921d32b0ff29fad31f89ec8b941 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bf4a36e76540ccfb255c7137aeccd4 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07bf4a36e76540ccfb255c7137aeccd4"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IsolateChannelsLashermesAspect</b> (float sigma, string q_q_filename)</td></tr>
<tr class="separator:a07bf4a36e76540ccfb255c7137aeccd4 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c92f8d2b2daeba77f167c7bec8728f6 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c92f8d2b2daeba77f167c7bec8728f6"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IsolateChannelsLashermesFull</b> (float sigma, string q_q_filename_prefix)</td></tr>
<tr class="separator:a4c92f8d2b2daeba77f167c7bec8728f6 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3158314bdc432fdc1a52acbb356a0e23 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3158314bdc432fdc1a52acbb356a0e23"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IsolateChannelsLashermesCurvatureArea</b> (float sigma, float area_threshold, string q_q_filename)</td></tr>
<tr class="separator:a3158314bdc432fdc1a52acbb356a0e23 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5d20b56b3ec4ae4b34846257477a5f inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a5f5d20b56b3ec4ae4b34846257477a5f">IsolateChannelsGeonet</a> (float timesteps, float area_threshold, float window_radius, string q_q_filename)</td></tr>
<tr class="memdesc:a5f5d20b56b3ec4ae4b34846257477a5f inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">method to locate channel pixels outlined by Passalacqua et al. (2010).  <a href="#a5f5d20b56b3ec4ae4b34846257477a5f">More...</a><br/></td></tr>
<tr class="separator:a5f5d20b56b3ec4ae4b34846257477a5f inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aabb85de4b848f357b3f92d7a26b1c0 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a6aabb85de4b848f357b3f92d7a26b1c0">IsolateChannelsQuantileQuantile</a> (string q_q_filename)</td></tr>
<tr class="memdesc:a6aabb85de4b848f357b3f92d7a26b1c0 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">uses quantile-quantile analysis to pick departure from gaussian behaviour, then uses this as a threshold to create a binary dataset.  <a href="#a6aabb85de4b848f357b3f92d7a26b1c0">More...</a><br/></td></tr>
<tr class="separator:a6aabb85de4b848f357b3f92d7a26b1c0 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f569f226055c02da8ddbafbf80fb3b9 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f569f226055c02da8ddbafbf80fb3b9"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IsolateChannelsQuantileQuantileAdaptive</b> (int half_width)</td></tr>
<tr class="separator:a3f569f226055c02da8ddbafbf80fb3b9 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d1f8c8b202df072becb69100d93839 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a79d1f8c8b202df072becb69100d93839">CalculateAdaptiveCurvatureThresholdSD</a> (int half_width)</td></tr>
<tr class="memdesc:a79d1f8c8b202df072becb69100d93839 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the curvature threshold used for DrEICH channel extraction which varies across the landscape.  <a href="#a79d1f8c8b202df072becb69100d93839">More...</a><br/></td></tr>
<tr class="separator:a79d1f8c8b202df072becb69100d93839 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d2ee698cc2b672ea70dcff2564b93e inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac1d2ee698cc2b672ea70dcff2564b93e">CreateHilltopPatches</a> (int minimum_patch_size)</td></tr>
<tr class="memdesc:ac1d2ee698cc2b672ea70dcff2564b93e inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to convert an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> hilltop file into a series of contigiuous hilltop patches.  <a href="#ac1d2ee698cc2b672ea70dcff2564b93e">More...</a><br/></td></tr>
<tr class="separator:ac1d2ee698cc2b672ea70dcff2564b93e inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33e4e010d721dcd98d4605e45a299d3 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab33e4e010d721dcd98d4605e45a299d3"></a>
<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CreateHilltopPatchesNEW</b> (int minimum_patch_size)</td></tr>
<tr class="separator:ab33e4e010d721dcd98d4605e45a299d3 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbd534a153549a070747668ee82b5e3 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abdbd534a153549a070747668ee82b5e3">FlattenToFile</a> (string FileName)</td></tr>
<tr class="memdesc:abdbd534a153549a070747668ee82b5e3 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple method to flatten an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to a text file, with a sigle value on each line.  <a href="#abdbd534a153549a070747668ee82b5e3">More...</a><br/></td></tr>
<tr class="separator:abdbd534a153549a070747668ee82b5e3 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1891ab358d51150fd78960d37ddd19ee inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a1891ab358d51150fd78960d37ddd19ee">FlattenToCSV</a> (string FileName)</td></tr>
<tr class="memdesc:a1891ab358d51150fd78960d37ddd19ee inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to flatten an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> and place the non NDV values in a csv file.  <a href="#a1891ab358d51150fd78960d37ddd19ee">More...</a><br/></td></tr>
<tr class="separator:a1891ab358d51150fd78960d37ddd19ee inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04779a5d0361d814ca82c0e65678cba7 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a04779a5d0361d814ca82c0e65678cba7">FlattenToWGS84CSV</a> (string FileName)</td></tr>
<tr class="memdesc:a04779a5d0361d814ca82c0e65678cba7 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to flatten an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> and place the non NDV values in a csv file.  <a href="#a04779a5d0361d814ca82c0e65678cba7">More...</a><br/></td></tr>
<tr class="separator:a04779a5d0361d814ca82c0e65678cba7 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f89819eff281f83e613c5d3f9952b3c inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a3f89819eff281f83e613c5d3f9952b3c">RemoveBelow</a> (float Value)</td></tr>
<tr class="memdesc:a3f89819eff281f83e613c5d3f9952b3c inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple method to remove any values below a user supplied value from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>.  <a href="#a3f89819eff281f83e613c5d3f9952b3c">More...</a><br/></td></tr>
<tr class="separator:a3f89819eff281f83e613c5d3f9952b3c inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac89c6707b5e24a1e0ba8261352533f7 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aac89c6707b5e24a1e0ba8261352533f7">RemoveAbove</a> (float Value)</td></tr>
<tr class="memdesc:aac89c6707b5e24a1e0ba8261352533f7 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple method to remove any values above a user supplied value from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>.  <a href="#aac89c6707b5e24a1e0ba8261352533f7">More...</a><br/></td></tr>
<tr class="separator:aac89c6707b5e24a1e0ba8261352533f7 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa304348f61e9ca3726d50f3d437258e8 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aa304348f61e9ca3726d50f3d437258e8">apply_mask</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;mask)</td></tr>
<tr class="memdesc:aa304348f61e9ca3726d50f3d437258e8 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a mask to a raster dataset, converts pixels to nodata where mas=k=1  <a href="#aa304348f61e9ca3726d50f3d437258e8">More...</a><br/></td></tr>
<tr class="separator:aa304348f61e9ca3726d50f3d437258e8 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc4d506a8dd46bd2f23fc1a3ce354fe inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#abcc4d506a8dd46bd2f23fc1a3ce354fe">ConvertToBinary</a> (int Value, int ndv)</td></tr>
<tr class="memdesc:abcc4d506a8dd46bd2f23fc1a3ce354fe inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to convert all values in an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> to a single value.  <a href="#abcc4d506a8dd46bd2f23fc1a3ce354fe">More...</a><br/></td></tr>
<tr class="separator:abcc4d506a8dd46bd2f23fc1a3ce354fe inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f80e0c1d976238555a4518a092c21a inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a47f80e0c1d976238555a4518a092c21a">MergeRasters</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;RasterToAdd)</td></tr>
<tr class="memdesc:a47f80e0c1d976238555a4518a092c21a inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to merge data from two LSDRasters WITH SAME EXTENT together. /// The data from the raster specified as an argument will be added (will overwrite the original raster if there is a conflict).  <a href="#a47f80e0c1d976238555a4518a092c21a">More...</a><br/></td></tr>
<tr class="separator:a47f80e0c1d976238555a4518a092c21a inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9674b03324b823871c59ffe549669082 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a9674b03324b823871c59ffe549669082">OverwriteRaster</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;RasterToAdd)</td></tr>
<tr class="memdesc:a9674b03324b823871c59ffe549669082 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to merge data from two LSDRasters WITH SAME EXTENT together. /// The data from the raster specified as an argument will be added (will overwrite the original raster if there is a conflict). Overloaded function to rewrite original raster rather than creating a new one.  <a href="#a9674b03324b823871c59ffe549669082">More...</a><br/></td></tr>
<tr class="separator:a9674b03324b823871c59ffe549669082 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4104b232e5686b68070ce4f7d29c21f1 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a4104b232e5686b68070ce4f7d29c21f1">get_potential_floodplain_patches</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Relief, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Slope, float relief_threshold, float slope_threshold)</td></tr>
<tr class="memdesc:a4104b232e5686b68070ce4f7d29c21f1 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get potential floodplain patches using a slope and relief threshold.  <a href="#a4104b232e5686b68070ce4f7d29c21f1">More...</a><br/></td></tr>
<tr class="separator:a4104b232e5686b68070ce4f7d29c21f1 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372400c4d0d1b4a5365b8973ce1301c4 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a372400c4d0d1b4a5365b8973ce1301c4">get_threshold_for_floodplain</a> (float bin_width, float peak_threshold, int peak_distance)</td></tr>
<tr class="memdesc:a372400c4d0d1b4a5365b8973ce1301c4 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get threshold from a raster using a histogram of Probability-Density values. The function identifies the peaks in the PDF, and sets the threshold to the peak with the lowest value. This can be used to set the floodplain threshold.  <a href="#a372400c4d0d1b4a5365b8973ce1301c4">More...</a><br/></td></tr>
<tr class="separator:a372400c4d0d1b4a5365b8973ce1301c4 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983ed9b8d8f60fb2890dba50d48408df inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a983ed9b8d8f60fb2890dba50d48408df">get_threshold_for_floodplain_QQ</a> (string q_q_filename, float threshold_condition, int lower_percentile, int upper_percentile)</td></tr>
<tr class="memdesc:a983ed9b8d8f60fb2890dba50d48408df inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get threshold from a raster using qq plots.  <a href="#a983ed9b8d8f60fb2890dba50d48408df">More...</a><br/></td></tr>
<tr class="separator:a983ed9b8d8f60fb2890dba50d48408df inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bf04f5047c82d16cc0bd0c1a8e04ee inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a87bf04f5047c82d16cc0bd0c1a8e04ee">ChannelLengthByOrder</a> (<a class="el" href="class_l_s_d_index_raster.html">LSDIndexRaster</a> &amp;StreamNetwork, Array2D&lt; int &gt; FlowDir)</td></tr>
<tr class="memdesc:a87bf04f5047c82d16cc0bd0c1a8e04ee inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lengths in spatial units of each part of the channel network, divided by strahler order.  <a href="#a87bf04f5047c82d16cc0bd0c1a8e04ee">More...</a><br/></td></tr>
<tr class="separator:a87bf04f5047c82d16cc0bd0c1a8e04ee inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34295ea8299a2bef045984f833c33976 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a34295ea8299a2bef045984f833c33976">PoupulateRasterGaussian</a> (float minimum, float mean)</td></tr>
<tr class="memdesc:a34295ea8299a2bef045984f833c33976 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a raster with random noise drawn from a gaussian distribution of given mean and minimum values.  <a href="#a34295ea8299a2bef045984f833c33976">More...</a><br/></td></tr>
<tr class="separator:a34295ea8299a2bef045984f833c33976 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821e7693904a2ea45fef8e6414988d07 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a821e7693904a2ea45fef8e6414988d07">PoupulateRasterSingleValue</a> (float value)</td></tr>
<tr class="memdesc:a821e7693904a2ea45fef8e6414988d07 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a raster with a single value.  <a href="#a821e7693904a2ea45fef8e6414988d07">More...</a><br/></td></tr>
<tr class="separator:a821e7693904a2ea45fef8e6414988d07 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4f18c6ed62e541057f3a604a84fb35 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#adf4f18c6ed62e541057f3a604a84fb35">HilltopsToCSV</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;CHT, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;CHT_gradient, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;gradient, int UTMZone, bool isNorth, int eId, string filename)</td></tr>
<tr class="memdesc:adf4f18c6ed62e541057f3a604a84fb35 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write CHT and hilltop gradient data to a *.csv file, coded by UTM coordinates as well as lat/long.  <a href="#adf4f18c6ed62e541057f3a604a84fb35">More...</a><br/></td></tr>
<tr class="separator:adf4f18c6ed62e541057f3a604a84fb35 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78165b8a11dccdeb493fbfe892aa17d inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ae78165b8a11dccdeb493fbfe892aa17d">Sample_Along_Ridge</a> (<a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Raster1, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Raster2, <a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;Raster3, int a, int b, int threshold)</td></tr>
<tr class="memdesc:ae78165b8a11dccdeb493fbfe892aa17d inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample the values of 3 input rasters that intersect with the point a,b within the area defined by threshold.  <a href="#ae78165b8a11dccdeb493fbfe892aa17d">More...</a><br/></td></tr>
<tr class="separator:ae78165b8a11dccdeb493fbfe892aa17d inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb88fa7304a7a05928250352230ef123 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#aeb88fa7304a7a05928250352230ef123">convert_from_feet_to_metres</a> ()</td></tr>
<tr class="memdesc:aeb88fa7304a7a05928250352230ef123 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to convert feet to metres using US international feet, where 1 foot = 0.3048006096012192 metres.  <a href="#aeb88fa7304a7a05928250352230ef123">More...</a><br/></td></tr>
<tr class="separator:aeb88fa7304a7a05928250352230ef123 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801154ac96833085a14a0a16814781f8 inherit pub_methods_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a801154ac96833085a14a0a16814781f8">convert_from_centimetres_to_metres</a> ()</td></tr>
<tr class="memdesc:a801154ac96833085a14a0a16814781f8 inherit pub_methods_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to convert elevations from centimetres to metres  <a href="#a801154ac96833085a14a0a16814781f8">More...</a><br/></td></tr>
<tr class="separator:a801154ac96833085a14a0a16814781f8 inherit pub_methods_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4d79f7374a5c719d6a2f341810ee28ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d79f7374a5c719d6a2f341810ee28ad"></a>
map&lt; string, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a4d79f7374a5c719d6a2f341810ee28ad">RM_model_switches</a></td></tr>
<tr class="memdesc:a4d79f7374a5c719d6a2f341810ee28ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This map holds all the possible model switches. <br/></td></tr>
<tr class="separator:a4d79f7374a5c719d6a2f341810ee28ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f22e311afb70a0c2acfe4aa190139d"><td class="memItemLeft" align="right" valign="top">map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a09f22e311afb70a0c2acfe4aa190139d">RM_method_map</a></td></tr>
<tr class="separator:a09f22e311afb70a0c2acfe4aa190139d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa409bea7948a3e3134d1ae53e19dd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fa409bea7948a3e3134d1ae53e19dd8"></a>
map&lt; string, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a6fa409bea7948a3e3134d1ae53e19dd8">RM_float_parameters</a></td></tr>
<tr class="memdesc:a6fa409bea7948a3e3134d1ae53e19dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds float parameters. <br/></td></tr>
<tr class="separator:a6fa409bea7948a3e3134d1ae53e19dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d6c31606b588281949e7acfa61b1e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37d6c31606b588281949e7acfa61b1e4"></a>
map&lt; string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a37d6c31606b588281949e7acfa61b1e4">RM_int_parameters</a></td></tr>
<tr class="memdesc:a37d6c31606b588281949e7acfa61b1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This holds integer parameters. <br/></td></tr>
<tr class="separator:a37d6c31606b588281949e7acfa61b1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa718ffbfb7d7a2fc15818219c04478"><td class="memItemLeft" align="right" valign="top">map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a6aa718ffbfb7d7a2fc15818219c04478">RM_support_file_names</a></td></tr>
<tr class="separator:a6aa718ffbfb7d7a2fc15818219c04478"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a668fbea001017975b5c248e9cae4e852"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a668fbea001017975b5c248e9cae4e852"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a668fbea001017975b5c248e9cae4e852">quiet</a></td></tr>
<tr class="memdesc:a668fbea001017975b5c248e9cae4e852"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if Supress output messages. <br/></td></tr>
<tr class="separator:a668fbea001017975b5c248e9cae4e852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead7047f77bb86885ffeaa6c33adc43a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aead7047f77bb86885ffeaa6c33adc43a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aead7047f77bb86885ffeaa6c33adc43a">initialized</a></td></tr>
<tr class="memdesc:aead7047f77bb86885ffeaa6c33adc43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if initialize_model has been run. <br/></td></tr>
<tr class="separator:aead7047f77bb86885ffeaa6c33adc43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944845a6fa9c7ddab5fe6956bc4e71dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a944845a6fa9c7ddab5fe6956bc4e71dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a944845a6fa9c7ddab5fe6956bc4e71dc">steady_state</a></td></tr>
<tr class="memdesc:a944845a6fa9c7ddab5fe6956bc4e71dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if initial steady state has been arrived at. <br/></td></tr>
<tr class="separator:a944845a6fa9c7ddab5fe6956bc4e71dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cff3849b69bf33a3d2a8e1759e9dee3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cff3849b69bf33a3d2a8e1759e9dee3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a3cff3849b69bf33a3d2a8e1759e9dee3">initial_steady_state</a></td></tr>
<tr class="memdesc:a3cff3849b69bf33a3d2a8e1759e9dee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">True for first steady state arrival, used for activating periodic forcing parameters. <br/></td></tr>
<tr class="separator:a3cff3849b69bf33a3d2a8e1759e9dee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e516058b07e939adaf31f3eae822ac5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e516058b07e939adaf31f3eae822ac5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a3e516058b07e939adaf31f3eae822ac5">cycle_steady_check</a></td></tr>
<tr class="memdesc:a3e516058b07e939adaf31f3eae822ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">True for steady state using periodic forcing (not sure about this one) <br/></td></tr>
<tr class="separator:a3e516058b07e939adaf31f3eae822ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e269cd74a00e4bc4559f06b4a3877a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e269cd74a00e4bc4559f06b4a3877a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a7e269cd74a00e4bc4559f06b4a3877a4">recording</a></td></tr>
<tr class="memdesc:a7e269cd74a00e4bc4559f06b4a3877a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if recording data. <br/></td></tr>
<tr class="separator:a7e269cd74a00e4bc4559f06b4a3877a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457608af9eb2375853f4a01af67a0cc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a457608af9eb2375853f4a01af67a0cc4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a457608af9eb2375853f4a01af67a0cc4">reporting</a></td></tr>
<tr class="memdesc:a457608af9eb2375853f4a01af67a0cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if writing the run report. <br/></td></tr>
<tr class="separator:a457608af9eb2375853f4a01af67a0cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12d2404131e260213a7b222fc666fe8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae12d2404131e260213a7b222fc666fe8"></a>
vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae12d2404131e260213a7b222fc666fe8">boundary_conditions</a></td></tr>
<tr class="memdesc:ae12d2404131e260213a7b222fc666fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boundary conditions of model NESW. <br/></td></tr>
<tr class="separator:ae12d2404131e260213a7b222fc666fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9471043d3cb80318abe82e383b2ddb4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9471043d3cb80318abe82e383b2ddb4c"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a9471043d3cb80318abe82e383b2ddb4c">name</a></td></tr>
<tr class="memdesc:a9471043d3cb80318abe82e383b2ddb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the model run. <br/></td></tr>
<tr class="separator:a9471043d3cb80318abe82e383b2ddb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74048107c88bdf946e4f36ebf7dbee9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74048107c88bdf946e4f36ebf7dbee9e"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a74048107c88bdf946e4f36ebf7dbee9e">report_name</a></td></tr>
<tr class="memdesc:a74048107c88bdf946e4f36ebf7dbee9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the report. <br/></td></tr>
<tr class="separator:a74048107c88bdf946e4f36ebf7dbee9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae944e64e421f4ab45ffc58cdac7ced"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ae944e64e421f4ab45ffc58cdac7ced"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a2ae944e64e421f4ab45ffc58cdac7ced">current_time</a></td></tr>
<tr class="memdesc:a2ae944e64e421f4ab45ffc58cdac7ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current time. <br/></td></tr>
<tr class="separator:a2ae944e64e421f4ab45ffc58cdac7ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30693df45eab4321bf3348e9ca10136f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30693df45eab4321bf3348e9ca10136f"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a30693df45eab4321bf3348e9ca10136f">time_delay</a></td></tr>
<tr class="memdesc:a30693df45eab4321bf3348e9ca10136f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time at which steady state was reached. Used to sync period after steady state. <br/></td></tr>
<tr class="separator:a30693df45eab4321bf3348e9ca10136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531a36b42c18dcab6790e819b514c7ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a531a36b42c18dcab6790e819b514c7ed"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a531a36b42c18dcab6790e819b514c7ed">timeStep</a></td></tr>
<tr class="memdesc:a531a36b42c18dcab6790e819b514c7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time in between each calculation. <br/></td></tr>
<tr class="separator:a531a36b42c18dcab6790e819b514c7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c269c36d91a4f19105d3dfb2a93873"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50c269c36d91a4f19105d3dfb2a93873"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a50c269c36d91a4f19105d3dfb2a93873">maxtimeStep</a></td></tr>
<tr class="memdesc:a50c269c36d91a4f19105d3dfb2a93873"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum possible timestep. Used with adaptive timestepping. <br/></td></tr>
<tr class="separator:a50c269c36d91a4f19105d3dfb2a93873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4ad3bfbee4193a6b51cddb3b8faaa5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e4ad3bfbee4193a6b51cddb3b8faaa5"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a2e4ad3bfbee4193a6b51cddb3b8faaa5">endTime</a></td></tr>
<tr class="memdesc:a2e4ad3bfbee4193a6b51cddb3b8faaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ending time <br/></td></tr>
<tr class="separator:a2e4ad3bfbee4193a6b51cddb3b8faaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978652ec046ee38762fda91020382c41"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a978652ec046ee38762fda91020382c41">endTime_mode</a></td></tr>
<tr class="separator:a978652ec046ee38762fda91020382c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61ad04c41927e3039e6f3d1f71ce6db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae61ad04c41927e3039e6f3d1f71ce6db"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae61ad04c41927e3039e6f3d1f71ce6db">num_runs</a></td></tr>
<tr class="memdesc:ae61ad04c41927e3039e6f3d1f71ce6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of runs, used to do repeated cycles from the same steady state <br/></td></tr>
<tr class="separator:ae61ad04c41927e3039e6f3d1f71ce6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab533276c540cf946adec779670f0cfc2"><td class="memItemLeft" align="right" valign="top">Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab533276c540cf946adec779670f0cfc2">uplift_field</a></td></tr>
<tr class="separator:ab533276c540cf946adec779670f0cfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1956dbd31336aaf80735b8418fe9335e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a1956dbd31336aaf80735b8418fe9335e">uplift_mode</a></td></tr>
<tr class="separator:a1956dbd31336aaf80735b8418fe9335e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad021a48fc8bdf0b6d47a97cb2b1aaeff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad021a48fc8bdf0b6d47a97cb2b1aaeff"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ad021a48fc8bdf0b6d47a97cb2b1aaeff">max_uplift</a></td></tr>
<tr class="memdesc:ad021a48fc8bdf0b6d47a97cb2b1aaeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">the maximum uplift rate <br/></td></tr>
<tr class="separator:ad021a48fc8bdf0b6d47a97cb2b1aaeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab085fd3bad74019db52527ebfe08d125"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab085fd3bad74019db52527ebfe08d125"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab085fd3bad74019db52527ebfe08d125">uplift_amplitude</a></td></tr>
<tr class="memdesc:ab085fd3bad74019db52527ebfe08d125"><td class="mdescLeft">&#160;</td><td class="mdescRight">the amplitude of uplift <br/></td></tr>
<tr class="separator:ab085fd3bad74019db52527ebfe08d125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4e96ab76ca0c1086b351d2d92f83d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb4e96ab76ca0c1086b351d2d92f83d2"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#adb4e96ab76ca0c1086b351d2d92f83d2">baseline_uplift</a></td></tr>
<tr class="memdesc:adb4e96ab76ca0c1086b351d2d92f83d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the baseline uplift rate (for different uplift modes) <br/></td></tr>
<tr class="separator:adb4e96ab76ca0c1086b351d2d92f83d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacc29dde882d07b414e9ae68c857421"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acacc29dde882d07b414e9ae68c857421"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#acacc29dde882d07b414e9ae68c857421">steady_state_tolerance</a></td></tr>
<tr class="memdesc:acacc29dde882d07b414e9ae68c857421"><td class="mdescLeft">&#160;</td><td class="mdescRight">an iteration tolerance for detemring if a model run is at steady state. <br/></td></tr>
<tr class="separator:acacc29dde882d07b414e9ae68c857421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ae7569751b4637993dd95c3d0cee77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5ae7569751b4637993dd95c3d0cee77"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>steady_state_limit</b></td></tr>
<tr class="separator:ad5ae7569751b4637993dd95c3d0cee77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cae56faea604d33f3404c96551d415"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3cae56faea604d33f3404c96551d415"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab3cae56faea604d33f3404c96551d415">m</a></td></tr>
<tr class="memdesc:ab3cae56faea604d33f3404c96551d415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Area exponent from the stream power law. <br/></td></tr>
<tr class="separator:ab3cae56faea604d33f3404c96551d415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa1e522fb52b5e39e556321e5862134"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fa1e522fb52b5e39e556321e5862134"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a6fa1e522fb52b5e39e556321e5862134">n</a></td></tr>
<tr class="memdesc:a6fa1e522fb52b5e39e556321e5862134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slope exponent for the stream power law. <br/></td></tr>
<tr class="separator:a6fa1e522fb52b5e39e556321e5862134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b4d0dfa1fc473cf79eb1fa26a3668d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8b4d0dfa1fc473cf79eb1fa26a3668d"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab8b4d0dfa1fc473cf79eb1fa26a3668d">K_fluv</a></td></tr>
<tr class="memdesc:ab8b4d0dfa1fc473cf79eb1fa26a3668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fluvial erodability coefficient (units depend on m and n) <br/></td></tr>
<tr class="separator:ab8b4d0dfa1fc473cf79eb1fa26a3668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41df228911b312427f66b7ca8c7de560"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41df228911b312427f66b7ca8c7de560"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a41df228911b312427f66b7ca8c7de560">K_soil</a></td></tr>
<tr class="memdesc:a41df228911b312427f66b7ca8c7de560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Soil transport coefficient (usually in m^2/yr) <br/></td></tr>
<tr class="separator:a41df228911b312427f66b7ca8c7de560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924133a29ef8bc3517cc57348e72a1c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a924133a29ef8bc3517cc57348e72a1c6"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a924133a29ef8bc3517cc57348e72a1c6">threshold_drainage</a></td></tr>
<tr class="memdesc:a924133a29ef8bc3517cc57348e72a1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drainage area above which soil will be flushed from the system in m^2. <br/></td></tr>
<tr class="separator:a924133a29ef8bc3517cc57348e72a1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70f615261aa7a7907be28009858e1c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab70f615261aa7a7907be28009858e1c4"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab70f615261aa7a7907be28009858e1c4">S_c</a></td></tr>
<tr class="memdesc:ab70f615261aa7a7907be28009858e1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Critical slope (for non-linear soil creep), dimensionless. <br/></td></tr>
<tr class="separator:ab70f615261aa7a7907be28009858e1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a278f21d903c624f2477fef490d918"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38a278f21d903c624f2477fef490d918"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a38a278f21d903c624f2477fef490d918">rigidity</a></td></tr>
<tr class="memdesc:a38a278f21d903c624f2477fef490d918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flexural rigidity of plate (SMM: dimensions?) <br/></td></tr>
<tr class="separator:a38a278f21d903c624f2477fef490d918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127a2a878fb2458261d076b39d862c72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a127a2a878fb2458261d076b39d862c72"></a>
Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a127a2a878fb2458261d076b39d862c72">root_depth</a></td></tr>
<tr class="memdesc:a127a2a878fb2458261d076b39d862c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth to topographic root, used in isostatic calculations. <br/></td></tr>
<tr class="separator:a127a2a878fb2458261d076b39d862c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacca822ef061535d355152cdd807ef38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacca822ef061535d355152cdd807ef38"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aacca822ef061535d355152cdd807ef38">erosion</a></td></tr>
<tr class="memdesc:aacca822ef061535d355152cdd807ef38"><td class="mdescLeft">&#160;</td><td class="mdescRight">the erosion (distance) <br/></td></tr>
<tr class="separator:aacca822ef061535d355152cdd807ef38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36fe00783b0f158e1116c6331d8c167"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab36fe00783b0f158e1116c6331d8c167"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab36fe00783b0f158e1116c6331d8c167">erosion_last_step</a></td></tr>
<tr class="memdesc:ab36fe00783b0f158e1116c6331d8c167"><td class="mdescLeft">&#160;</td><td class="mdescRight">the erosion (distance) over the last timestep <br/></td></tr>
<tr class="separator:ab36fe00783b0f158e1116c6331d8c167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177434b85afba081efea6c4ae9767b45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a177434b85afba081efea6c4ae9767b45"></a>
vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a177434b85afba081efea6c4ae9767b45">erosion_cycle_record</a></td></tr>
<tr class="memdesc:a177434b85afba081efea6c4ae9767b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">the erosion over cycles, a vector since it stores sucessive cycles <br/></td></tr>
<tr class="separator:a177434b85afba081efea6c4ae9767b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034fcb89292d98d7880e9f9a22a9816b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a034fcb89292d98d7880e9f9a22a9816b"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a034fcb89292d98d7880e9f9a22a9816b">total_erosion</a></td></tr>
<tr class="memdesc:a034fcb89292d98d7880e9f9a22a9816b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total erosion, calcualted as Offset from uplift from each cell. <br/></td></tr>
<tr class="separator:a034fcb89292d98d7880e9f9a22a9816b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb8b3b0382026ab2e00a5af48863fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adecb8b3b0382026ab2e00a5af48863fe"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#adecb8b3b0382026ab2e00a5af48863fe">min_erosion</a></td></tr>
<tr class="memdesc:adecb8b3b0382026ab2e00a5af48863fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum erosion distance, used in cyclic calculations <br/></td></tr>
<tr class="separator:adecb8b3b0382026ab2e00a5af48863fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b603fde9e92f1b19c90314cfc073d1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b603fde9e92f1b19c90314cfc073d1f"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a3b603fde9e92f1b19c90314cfc073d1f">max_erosion</a></td></tr>
<tr class="memdesc:a3b603fde9e92f1b19c90314cfc073d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum erosion distance, used in cyclic calculations <br/></td></tr>
<tr class="separator:a3b603fde9e92f1b19c90314cfc073d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eb1d8627adf8852421e46413cd85c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6eb1d8627adf8852421e46413cd85c9"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab6eb1d8627adf8852421e46413cd85c9">response</a></td></tr>
<tr class="memdesc:ab6eb1d8627adf8852421e46413cd85c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum response over a single run (SMM: no idea if this is a length or what) <br/></td></tr>
<tr class="separator:ab6eb1d8627adf8852421e46413cd85c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43dced651a4017557624340f811100c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae43dced651a4017557624340f811100c"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae43dced651a4017557624340f811100c">total_response</a></td></tr>
<tr class="memdesc:ae43dced651a4017557624340f811100c"><td class="mdescLeft">&#160;</td><td class="mdescRight">response over all model runs (to be divided by num_runs) <br/></td></tr>
<tr class="separator:ae43dced651a4017557624340f811100c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f8e52a0bc460f9a7b3d0afaa7ea56a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29f8e52a0bc460f9a7b3d0afaa7ea56a"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a29f8e52a0bc460f9a7b3d0afaa7ea56a">noise</a></td></tr>
<tr class="memdesc:a29f8e52a0bc460f9a7b3d0afaa7ea56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets the amplitude of random noise, used in model initialisation. <br/></td></tr>
<tr class="separator:a29f8e52a0bc460f9a7b3d0afaa7ea56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c09f608e56547cac43172e285705bc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c09f608e56547cac43172e285705bc1"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a5c09f608e56547cac43172e285705bc1">report_delay</a></td></tr>
<tr class="memdesc:a5c09f608e56547cac43172e285705bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMM: not sure what this does. <br/></td></tr>
<tr class="separator:a5c09f608e56547cac43172e285705bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0546c395e8961e140636461051ba6d15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0546c395e8961e140636461051ba6d15"></a>
Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a0546c395e8961e140636461051ba6d15">zeta_old</a></td></tr>
<tr class="memdesc:a0546c395e8961e140636461051ba6d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">the elevations from the last timestep <br/></td></tr>
<tr class="separator:a0546c395e8961e140636461051ba6d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2309dac008956b39d00d913f2bb1740b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2309dac008956b39d00d913f2bb1740b"></a>
Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a2309dac008956b39d00d913f2bb1740b">steady_state_data</a></td></tr>
<tr class="memdesc:a2309dac008956b39d00d913f2bb1740b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the elevations at steady state <br/></td></tr>
<tr class="separator:a2309dac008956b39d00d913f2bb1740b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cd638d278136351c2bf4de58f4ed87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6cd638d278136351c2bf4de58f4ed87"></a>
Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab6cd638d278136351c2bf4de58f4ed87">erosion_cycle_field</a></td></tr>
<tr class="memdesc:ab6cd638d278136351c2bf4de58f4ed87"><td class="mdescLeft">&#160;</td><td class="mdescRight">a field calculated over an erosion cycle <br/></td></tr>
<tr class="separator:ab6cd638d278136351c2bf4de58f4ed87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b30bd1ce1854f21f89c11b0ec454d71"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a5b30bd1ce1854f21f89c11b0ec454d71">K_mode</a></td></tr>
<tr class="separator:a5b30bd1ce1854f21f89c11b0ec454d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221d96c9081b11d6ab60b87696b24fd1"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a221d96c9081b11d6ab60b87696b24fd1">D_mode</a></td></tr>
<tr class="separator:a221d96c9081b11d6ab60b87696b24fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a3936bc1f786a9e4147ab388a0bd25"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ac0a3936bc1f786a9e4147ab388a0bd25">period_mode</a></td></tr>
<tr class="separator:ac0a3936bc1f786a9e4147ab388a0bd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41d7ebc79cc63181aa1753e35b41411"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab41d7ebc79cc63181aa1753e35b41411"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ab41d7ebc79cc63181aa1753e35b41411">K_amplitude</a></td></tr>
<tr class="memdesc:ab41d7ebc79cc63181aa1753e35b41411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amplitude of K wave. <br/></td></tr>
<tr class="separator:ab41d7ebc79cc63181aa1753e35b41411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867ecff781dab5a595b8f4d8f06321d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a867ecff781dab5a595b8f4d8f06321d0"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a867ecff781dab5a595b8f4d8f06321d0">D_amplitude</a></td></tr>
<tr class="memdesc:a867ecff781dab5a595b8f4d8f06321d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amplitude of D wave. <br/></td></tr>
<tr class="separator:a867ecff781dab5a595b8f4d8f06321d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f64caa1758aa5b7b69f807c5322f86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60f64caa1758aa5b7b69f807c5322f86"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a60f64caa1758aa5b7b69f807c5322f86">periodicity</a></td></tr>
<tr class="memdesc:a60f64caa1758aa5b7b69f807c5322f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Periodicty. <br/></td></tr>
<tr class="separator:a60f64caa1758aa5b7b69f807c5322f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a1d2c6ed02d768ba6b03641d0824fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47a1d2c6ed02d768ba6b03641d0824fb"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a47a1d2c6ed02d768ba6b03641d0824fb">periodicity_2</a></td></tr>
<tr class="memdesc:a47a1d2c6ed02d768ba6b03641d0824fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">2nd periodicity (if period_mode = 2) <br/></td></tr>
<tr class="separator:a47a1d2c6ed02d768ba6b03641d0824fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30b9fb15aa2af2d7db4fd2a28bd5ec0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae30b9fb15aa2af2d7db4fd2a28bd5ec0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae30b9fb15aa2af2d7db4fd2a28bd5ec0">cycle_number</a></td></tr>
<tr class="memdesc:ae30b9fb15aa2af2d7db4fd2a28bd5ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">cycle that the model is on. Used to track changes in erosion between cycles <br/></td></tr>
<tr class="separator:ae30b9fb15aa2af2d7db4fd2a28bd5ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb23742b593bce5c3f123f2acec5fffe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb23742b593bce5c3f123f2acec5fffe"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#abb23742b593bce5c3f123f2acec5fffe">p_weight</a></td></tr>
<tr class="memdesc:abb23742b593bce5c3f123f2acec5fffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ratio for weight of periodicity in period_mode 3 or 4. <br/></td></tr>
<tr class="separator:abb23742b593bce5c3f123f2acec5fffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfada60f5eb3e9e6b902af1f68f9436"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dfada60f5eb3e9e6b902af1f68f9436"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a7dfada60f5eb3e9e6b902af1f68f9436">switch_time</a></td></tr>
<tr class="memdesc:a7dfada60f5eb3e9e6b902af1f68f9436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time at which switch happens (time mode is same as endTime_mode) <br/></td></tr>
<tr class="separator:a7dfada60f5eb3e9e6b902af1f68f9436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30022b1a5dc341f19c380eac46bbc0fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30022b1a5dc341f19c380eac46bbc0fc"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a30022b1a5dc341f19c380eac46bbc0fc">switch_delay</a></td></tr>
<tr class="memdesc:a30022b1a5dc341f19c380eac46bbc0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to time delay (but for switching periodicities) <br/></td></tr>
<tr class="separator:a30022b1a5dc341f19c380eac46bbc0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2241d319bb64b0e250eb07652077413c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2241d319bb64b0e250eb07652077413c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a2241d319bb64b0e250eb07652077413c">fluvial</a></td></tr>
<tr class="memdesc:a2241d319bb64b0e250eb07652077413c"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if fluvial erosion is on. <br/></td></tr>
<tr class="separator:a2241d319bb64b0e250eb07652077413c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06170ebb136f5ac16e2fb62d7ed404a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06170ebb136f5ac16e2fb62d7ed404a2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a06170ebb136f5ac16e2fb62d7ed404a2">hillslope</a></td></tr>
<tr class="memdesc:a06170ebb136f5ac16e2fb62d7ed404a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if linear hillslope erosion is on <br/></td></tr>
<tr class="separator:a06170ebb136f5ac16e2fb62d7ed404a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa377fe56a1a474d51245782f53a20f08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa377fe56a1a474d51245782f53a20f08"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aa377fe56a1a474d51245782f53a20f08">nonlinear</a></td></tr>
<tr class="memdesc:aa377fe56a1a474d51245782f53a20f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if nonlinear hillslope erosion is on. <br/></td></tr>
<tr class="separator:aa377fe56a1a474d51245782f53a20f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca92343d9b26f4044101dd198e494b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ca92343d9b26f4044101dd198e494b2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a4ca92343d9b26f4044101dd198e494b2">isostasy</a></td></tr>
<tr class="memdesc:a4ca92343d9b26f4044101dd198e494b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if isostatic component is on. <br/></td></tr>
<tr class="separator:a4ca92343d9b26f4044101dd198e494b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f015d2e441133f2798641a2e1828848"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f015d2e441133f2798641a2e1828848"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a6f015d2e441133f2798641a2e1828848">flexure</a></td></tr>
<tr class="memdesc:a6f015d2e441133f2798641a2e1828848"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if // Whether flexural isostasy will be used. <br/></td></tr>
<tr class="separator:a6f015d2e441133f2798641a2e1828848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec7db721600f8c072c67f285c0409b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaec7db721600f8c072c67f285c0409b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aaec7db721600f8c072c67f285c0409b4">current_frame</a></td></tr>
<tr class="memdesc:aaec7db721600f8c072c67f285c0409b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the current frame, used for keeping track of the output rasters. <br/></td></tr>
<tr class="separator:aaec7db721600f8c072c67f285c0409b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f4abb97af2d2053eec5e9a60ea246c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40f4abb97af2d2053eec5e9a60ea246c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a40f4abb97af2d2053eec5e9a60ea246c">print_interval</a></td></tr>
<tr class="memdesc:a40f4abb97af2d2053eec5e9a60ea246c"><td class="mdescLeft">&#160;</td><td class="mdescRight">interval over which output is written. Just based on number of timesteps <br/></td></tr>
<tr class="separator:a40f4abb97af2d2053eec5e9a60ea246c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63de863e2d56b80310b838df18b90ea4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63de863e2d56b80310b838df18b90ea4"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a63de863e2d56b80310b838df18b90ea4">float_print_interval</a></td></tr>
<tr class="memdesc:a63de863e2d56b80310b838df18b90ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is for printing at fixed times <br/></td></tr>
<tr class="separator:a63de863e2d56b80310b838df18b90ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5729f2b8b8f2c2967d0cc0c545334b84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5729f2b8b8f2c2967d0cc0c545334b84"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>next_printing_time</b></td></tr>
<tr class="separator:a5729f2b8b8f2c2967d0cc0c545334b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3494615580ffc0dbe0b410e75a44bbd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3494615580ffc0dbe0b410e75a44bbd8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a3494615580ffc0dbe0b410e75a44bbd8">print_elevation</a></td></tr>
<tr class="memdesc:a3494615580ffc0dbe0b410e75a44bbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch for printing elevation, if true elevation is printed to a raster. <br/></td></tr>
<tr class="separator:a3494615580ffc0dbe0b410e75a44bbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ab114cdc4e5c8e6d39c5463f4f0b7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3ab114cdc4e5c8e6d39c5463f4f0b7a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae3ab114cdc4e5c8e6d39c5463f4f0b7a">print_erosion</a></td></tr>
<tr class="memdesc:ae3ab114cdc4e5c8e6d39c5463f4f0b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch for printing erosion, if true elevation is printed to a raster. <br/></td></tr>
<tr class="separator:ae3ab114cdc4e5c8e6d39c5463f4f0b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fbab9f2870eb400ac7bdf063d2abd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5fbab9f2870eb400ac7bdf063d2abd8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ae5fbab9f2870eb400ac7bdf063d2abd8">print_erosion_cycle</a></td></tr>
<tr class="memdesc:ae5fbab9f2870eb400ac7bdf063d2abd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch for printing erosion over a cycle, if true erosion is printed to a raster. <br/></td></tr>
<tr class="separator:ae5fbab9f2870eb400ac7bdf063d2abd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a35c85a77bdb6fbe0e78eb5ba20781"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4a35c85a77bdb6fbe0e78eb5ba20781"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#ac4a35c85a77bdb6fbe0e78eb5ba20781">print_hillshade</a></td></tr>
<tr class="memdesc:ac4a35c85a77bdb6fbe0e78eb5ba20781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch for printing the hillshade, if true hillshade is printed to a raster. <br/></td></tr>
<tr class="separator:ac4a35c85a77bdb6fbe0e78eb5ba20781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251f337d9f36abdf6dd82404eaefe477"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a251f337d9f36abdf6dd82404eaefe477"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a251f337d9f36abdf6dd82404eaefe477">print_slope_area</a></td></tr>
<tr class="memdesc:a251f337d9f36abdf6dd82404eaefe477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch for printing S-A data, if true S-A data is printed. <br/></td></tr>
<tr class="separator:a251f337d9f36abdf6dd82404eaefe477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2542a14b8ddb80758117f48c039a5949"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2542a14b8ddb80758117f48c039a5949"></a>
Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a2542a14b8ddb80758117f48c039a5949">zeta_last_iter</a></td></tr>
<tr class="memdesc:a2542a14b8ddb80758117f48c039a5949"><td class="mdescLeft">&#160;</td><td class="mdescRight">This array keeps track of the elevation on the previous iteration. <br/></td></tr>
<tr class="separator:a2542a14b8ddb80758117f48c039a5949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8820ba2924b494b5c97ed7db321be8dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8820ba2924b494b5c97ed7db321be8dd"></a>
Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a8820ba2924b494b5c97ed7db321be8dd">zeta_last_timestep</a></td></tr>
<tr class="memdesc:a8820ba2924b494b5c97ed7db321be8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This array keeps track of the elevation from the previous timestep. <br/></td></tr>
<tr class="separator:a8820ba2924b494b5c97ed7db321be8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbe122474888dd4f7c4a2e3ea373bc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dbe122474888dd4f7c4a2e3ea373bc8"></a>
Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a6dbe122474888dd4f7c4a2e3ea373bc8">zeta_this_iter</a></td></tr>
<tr class="memdesc:a6dbe122474888dd4f7c4a2e3ea373bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array for the current iteratation (used for implicit nonlinear solvers) <br/></td></tr>
<tr class="separator:a6dbe122474888dd4f7c4a2e3ea373bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fc62895116d37317da49819e493304"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08fc62895116d37317da49819e493304"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a08fc62895116d37317da49819e493304">inv_dx_S_c_squared</a></td></tr>
<tr class="memdesc:a08fc62895116d37317da49819e493304"><td class="mdescLeft">&#160;</td><td class="mdescRight">precalculated 1/(dx^2*S_c^2) <br/></td></tr>
<tr class="separator:a08fc62895116d37317da49819e493304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553293dfd932797c936fbbc6e1e8ffd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a553293dfd932797c936fbbc6e1e8ffd8"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a553293dfd932797c936fbbc6e1e8ffd8">dx_front_term</a></td></tr>
<tr class="memdesc:a553293dfd932797c936fbbc6e1e8ffd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">precalculated dt*D_nl/(dx^2) <br/></td></tr>
<tr class="separator:a553293dfd932797c936fbbc6e1e8ffd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f55f1d6b3de5fbd571b2de0b97d645"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17f55f1d6b3de5fbd571b2de0b97d645"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a17f55f1d6b3de5fbd571b2de0b97d645">problem_dimension</a></td></tr>
<tr class="memdesc:a17f55f1d6b3de5fbd571b2de0b97d645"><td class="mdescLeft">&#160;</td><td class="mdescRight">the problem dimension, used to determine the size of the solver matrix <br/></td></tr>
<tr class="separator:a17f55f1d6b3de5fbd571b2de0b97d645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad44dfbe1614a2dd5ad6543b2025a4d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad44dfbe1614a2dd5ad6543b2025a4d7"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aad44dfbe1614a2dd5ad6543b2025a4d7">vec_k_value_i_j</a></td></tr>
<tr class="memdesc:aad44dfbe1614a2dd5ad6543b2025a4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">k value at i,j. This is an index into the vectorised elevation data. <br/></td></tr>
<tr class="separator:aad44dfbe1614a2dd5ad6543b2025a4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc92df89fce060f64b8b05f43fdddbe1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc92df89fce060f64b8b05f43fdddbe1"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#acc92df89fce060f64b8b05f43fdddbe1">vec_k_value_ip1_j</a></td></tr>
<tr class="memdesc:acc92df89fce060f64b8b05f43fdddbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">k value at i+1, j. This is an index into the vectorised elevation data. <br/></td></tr>
<tr class="separator:acc92df89fce060f64b8b05f43fdddbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8f8923535a6499c63fceb976762f63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee8f8923535a6499c63fceb976762f63"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aee8f8923535a6499c63fceb976762f63">vec_k_value_im1_j</a></td></tr>
<tr class="memdesc:aee8f8923535a6499c63fceb976762f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">k value at i-1, j. This is an index into the vectorised elevation data. <br/></td></tr>
<tr class="separator:aee8f8923535a6499c63fceb976762f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec069ee9cce959702cfbf75d7627907"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaec069ee9cce959702cfbf75d7627907"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#aaec069ee9cce959702cfbf75d7627907">vec_k_value_i_jp1</a></td></tr>
<tr class="memdesc:aaec069ee9cce959702cfbf75d7627907"><td class="mdescLeft">&#160;</td><td class="mdescRight">k value at i, j+1. This is an index into the vectorised elevation data. <br/></td></tr>
<tr class="separator:aaec069ee9cce959702cfbf75d7627907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985cef4e6e9a6990c13442a3c13beb9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a985cef4e6e9a6990c13442a3c13beb9e"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster_model.html#a985cef4e6e9a6990c13442a3c13beb9e">vec_k_value_i_jm1</a></td></tr>
<tr class="memdesc:a985cef4e6e9a6990c13442a3c13beb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">k value at i, j-1. This is an index into the vectorised elevation data. <br/></td></tr>
<tr class="separator:a985cef4e6e9a6990c13442a3c13beb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_l_s_d_raster_spectral"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_l_s_d_raster_spectral')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_l_s_d_raster_spectral.html">LSDRasterSpectral</a></td></tr>
<tr class="memitem:ae6d5746d1eb004da288b95a0c7bfc15a inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6d5746d1eb004da288b95a0c7bfc15a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Lx</b></td></tr>
<tr class="separator:ae6d5746d1eb004da288b95a0c7bfc15a inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c863c3ee2225e8cd702f61f9b700a7 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7c863c3ee2225e8cd702f61f9b700a7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Ly</b></td></tr>
<tr class="separator:ae7c863c3ee2225e8cd702f61f9b700a7 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ded58ba0a5ad60c4411f59daf89175b inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ded58ba0a5ad60c4411f59daf89175b"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>dfx</b></td></tr>
<tr class="separator:a1ded58ba0a5ad60c4411f59daf89175b inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7877ce922b42a7586ad21df998a3763e inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7877ce922b42a7586ad21df998a3763e"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>dfy</b></td></tr>
<tr class="separator:a7877ce922b42a7586ad21df998a3763e inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e13b4668ac03da51a1e363725f12d96 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e13b4668ac03da51a1e363725f12d96"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>NyquistFreq</b></td></tr>
<tr class="separator:a5e13b4668ac03da51a1e363725f12d96 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f0c7675b91ce853706e829a010abc3 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80f0c7675b91ce853706e829a010abc3"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>WSS</b></td></tr>
<tr class="separator:a80f0c7675b91ce853706e829a010abc3 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb88907ebeb246bbed43547f02df9bc inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fb88907ebeb246bbed43547f02df9bc"></a>
Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>P_DFT</b></td></tr>
<tr class="separator:a9fb88907ebeb246bbed43547f02df9bc inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bb1d17cb6a362230a49f5994a31d01 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6bb1d17cb6a362230a49f5994a31d01"></a>
vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RadialFrequency</b></td></tr>
<tr class="separator:af6bb1d17cb6a362230a49f5994a31d01 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5964d688512b6ac22229950914de01d2 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5964d688512b6ac22229950914de01d2"></a>
vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RadialPSD</b></td></tr>
<tr class="separator:a5964d688512b6ac22229950914de01d2 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfce26444d3211fd4ec0ecb2527fff6 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bfce26444d3211fd4ec0ecb2527fff6"></a>
vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BackgroundPSD</b></td></tr>
<tr class="separator:a6bfce26444d3211fd4ec0ecb2527fff6 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43eda7ecd04ae37223c57a15f927235 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa43eda7ecd04ae37223c57a15f927235"></a>
vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NormalisedPSD</b></td></tr>
<tr class="separator:aa43eda7ecd04ae37223c57a15f927235 inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076c84ef810c1342257564dffb34147a inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a076c84ef810c1342257564dffb34147a"></a>
vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CI95</b></td></tr>
<tr class="separator:a076c84ef810c1342257564dffb34147a inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57e1eb23429f60d8bbced9ff307f27d inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae57e1eb23429f60d8bbced9ff307f27d"></a>
vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>normCI95</b></td></tr>
<tr class="separator:ae57e1eb23429f60d8bbced9ff307f27d inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e41178c8e905981a2c62e786b413fc inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94e41178c8e905981a2c62e786b413fc"></a>
vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>normCI99</b></td></tr>
<tr class="separator:a94e41178c8e905981a2c62e786b413fc inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869b1ea82e50da4ae0ebcbe77756303e inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a869b1ea82e50da4ae0ebcbe77756303e"></a>
vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>R_sq</b></td></tr>
<tr class="separator:a869b1ea82e50da4ae0ebcbe77756303e inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e925c24a15cc16e52f45a62429652d inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6e925c24a15cc16e52f45a62429652d"></a>
vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>beta</b></td></tr>
<tr class="separator:ae6e925c24a15cc16e52f45a62429652d inherit pro_attribs_class_l_s_d_raster_spectral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_l_s_d_raster"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_l_s_d_raster')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_l_s_d_raster.html">LSDRaster</a></td></tr>
<tr class="memitem:ac88ec4e856cb32a69f58b7da5bfc24c0 inherit pro_attribs_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac88ec4e856cb32a69f58b7da5bfc24c0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ac88ec4e856cb32a69f58b7da5bfc24c0">NRows</a></td></tr>
<tr class="memdesc:ac88ec4e856cb32a69f58b7da5bfc24c0 inherit pro_attribs_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows. <br/></td></tr>
<tr class="separator:ac88ec4e856cb32a69f58b7da5bfc24c0 inherit pro_attribs_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5835c070514b4bfc39b730e117a3abb7 inherit pro_attribs_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5835c070514b4bfc39b730e117a3abb7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a5835c070514b4bfc39b730e117a3abb7">NCols</a></td></tr>
<tr class="memdesc:a5835c070514b4bfc39b730e117a3abb7 inherit pro_attribs_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns. <br/></td></tr>
<tr class="separator:a5835c070514b4bfc39b730e117a3abb7 inherit pro_attribs_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7ca2d66394d42913c09c27478b9bef inherit pro_attribs_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d7ca2d66394d42913c09c27478b9bef"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a0d7ca2d66394d42913c09c27478b9bef">XMinimum</a></td></tr>
<tr class="memdesc:a0d7ca2d66394d42913c09c27478b9bef inherit pro_attribs_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum X coordinate. <br/></td></tr>
<tr class="separator:a0d7ca2d66394d42913c09c27478b9bef inherit pro_attribs_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273693464ba52e8280efe84700dcd680 inherit pro_attribs_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a273693464ba52e8280efe84700dcd680"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a273693464ba52e8280efe84700dcd680">YMinimum</a></td></tr>
<tr class="memdesc:a273693464ba52e8280efe84700dcd680 inherit pro_attribs_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum Y coordinate. <br/></td></tr>
<tr class="separator:a273693464ba52e8280efe84700dcd680 inherit pro_attribs_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cc9f431dddb56ed538b398f0d3d8ed inherit pro_attribs_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07cc9f431dddb56ed538b398f0d3d8ed"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a07cc9f431dddb56ed538b398f0d3d8ed">DataResolution</a></td></tr>
<tr class="memdesc:a07cc9f431dddb56ed538b398f0d3d8ed inherit pro_attribs_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data resolution. <br/></td></tr>
<tr class="separator:a07cc9f431dddb56ed538b398f0d3d8ed inherit pro_attribs_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dfb77f3740c6842cb3ff375635fd01 inherit pro_attribs_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03dfb77f3740c6842cb3ff375635fd01"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a03dfb77f3740c6842cb3ff375635fd01">NoDataValue</a></td></tr>
<tr class="memdesc:a03dfb77f3740c6842cb3ff375635fd01 inherit pro_attribs_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">No data value. <br/></td></tr>
<tr class="separator:a03dfb77f3740c6842cb3ff375635fd01 inherit pro_attribs_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc7c8d78e57b02aa72d243b4cc755af inherit pro_attribs_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fc7c8d78e57b02aa72d243b4cc755af"></a>
map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#a2fc7c8d78e57b02aa72d243b4cc755af">GeoReferencingStrings</a></td></tr>
<tr class="memdesc:a2fc7c8d78e57b02aa72d243b4cc755af inherit pro_attribs_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of strings for holding georeferencing information. <br/></td></tr>
<tr class="separator:a2fc7c8d78e57b02aa72d243b4cc755af inherit pro_attribs_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ac67e4da1ad0e36d097687411d4707 inherit pro_attribs_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1ac67e4da1ad0e36d097687411d4707"></a>
Array2D&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#ab1ac67e4da1ad0e36d097687411d4707">RasterData</a></td></tr>
<tr class="memdesc:ab1ac67e4da1ad0e36d097687411d4707 inherit pro_attribs_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raster data. <br/></td></tr>
<tr class="separator:ab1ac67e4da1ad0e36d097687411d4707 inherit pro_attribs_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd9c7284b4fe091960b78e47c079f72 inherit pro_attribs_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdd9c7284b4fe091960b78e47c079f72"></a>
Array2D&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_s_d_raster.html#acdd9c7284b4fe091960b78e47c079f72">RasterData_dbl</a></td></tr>
<tr class="memdesc:acdd9c7284b4fe091960b78e47c079f72 inherit pro_attribs_class_l_s_d_raster"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are used primarily by <a class="el" href="class_l_s_d_catchment_model.html" title="This object is used to model the hydrology, sediment transport and evolution of individual basins...">LSDCatchmentModel</a>. <br/></td></tr>
<tr class="separator:acdd9c7284b4fe091960b78e47c079f72 inherit pro_attribs_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2050da482727bd81d58d55ceb2ae16 inherit pro_attribs_class_l_s_d_raster"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c2050da482727bd81d58d55ceb2ae16"></a>
Array2D&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RasterData_int</b></td></tr>
<tr class="separator:a6c2050da482727bd81d58d55ceb2ae16 inherit pro_attribs_class_l_s_d_raster"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Create model objects to use <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> methods on synthetic landscapes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1de3c183b5f2f8f96d8a62b2c8109932"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDRasterModel::LSDRasterModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. Create a deafult <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> (100x100) </p>
<dl class="section return"><dt>Returns</dt><dd>An instance of <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a433a0754ab4048d2a88c55ec8d389ce2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDRasterModel::LSDRasterModel </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>master_param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. Create a <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> from a parameter file. </p>
<dl class="section return"><dt>Returns</dt><dd>An instance of <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">master_param</td><td>A filenam for the master parameter file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a801fb83a5f478d8432929a1f44b1a919"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDRasterModel::LSDRasterModel </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. Create an <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> from a file. Uses a filename and file extension. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A String, the file to be loaded. </td></tr>
    <tr><td class="paramname">extension</td><td>A String, the file extension to be loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa26f19c8094cfced7b2cc943310d270"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDRasterModel::LSDRasterModel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ymin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cellsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ndv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. Create an <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> from memory. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nrows</td><td>An integer of the number of rows. </td></tr>
    <tr><td class="paramname">ncols</td><td>An integer of the number of columns. </td></tr>
    <tr><td class="paramname">xmin</td><td>A float of the minimum X coordinate. </td></tr>
    <tr><td class="paramname">ymin</td><td>A float of the minimum Y coordinate. </td></tr>
    <tr><td class="paramname">cellsize</td><td>A float of the cellsize. </td></tr>
    <tr><td class="paramname">ndv</td><td>An integer of the no data value. </td></tr>
    <tr><td class="paramname">data</td><td>An Array2D of floats in the shape nrows*ncols, containing the data to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59955d7470346fc100360687221387a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LSDRasterModel::LSDRasterModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>An_LSDRaster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. Create an <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> from an <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">An_LSDRaster</td><td><a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13d7382c826d36af69e17fb0fba7e306"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LSDRasterModel::LSDRasterModel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. Create a blank raster nodel. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NCols</td><td>Height of raster </td></tr>
    <tr><td class="paramname">NRows</td><td>Width of raster </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a687c77476e57a4b0217a82f8354bdbfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::add_path_to_names </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this ads a pathname to the default names </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>name of the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a04f60042d6b0f13a2951a7637069d663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::Airy_isostasy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <h2>Correct for isostasy using Airy model </h2>

</div>
</div>
<a class="anchor" id="af015d79ae4fd62a026ff3e2ed32d9bce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::append_run_name </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>append_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this appends a string to the run name  can be used to append parameters to run names </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>09/04/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a084a2206ec53c4e95eca7943cd818b58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRasterModel::array_channel_width_wolman </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>k_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> array_channel_width_wolman this function calcualtes channel width in a stand alone module so the widths </p>
<h2>can be tested </h2>

</div>
</div>
<a class="anchor" id="a36e109544d223f9a3981b0dd9b2cb1da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::base_level_fall </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>uplift_amt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simulate instantaneous base level fall </p>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/07/18 </dd></dl>

</div>
</div>
<a class="anchor" id="a155a4a6203f9aeac25bf40df0505223c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::calculate_channel_width_wolman </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Q_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>k_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- </p>
<h2>HYDROLOGICAL TOOLS </h2>
<p>calculate_channel_width_wolman This function calculates channel width using the wolman method. NOTE: typically Q_w will be in m^3/s. EXAMPLE: in Salmon River, Idaho (Emmett, 1975 cited in Knighton 1988): </p>
<h2>k_w = 2.77 and b = 0.56. b is often assumed to be 0.5 </h2>

</div>
</div>
<a class="anchor" id="a627e0ea53705582a8767c84fa969370e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRasterModel::calculate_erosion_rates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple function that creates an array with the erosion rates for a given timestep. It doesn't do anything with NoData cells, and for cells with data it calls the get_erosion_at_cell member function updated to catch instances when zeta_old has not been calculated. </p>
<dl class="section return"><dt>Returns</dt><dd>an array with the erosion rates </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ updated SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 updated 01/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="aad56ab74937d94b3cb5e59ba58980674"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRasterModel::calculate_fluvial_erosion_rate </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>ChannelWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>Q_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>TopoDivergence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eros_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- EROSION RATES/SEDIMENT FLUXES </p>
<hr/>
 <h2>this caluclates the fluvial erosion rate at each point </h2>

</div>
</div>
<a class="anchor" id="a7ac1dd92d9e6b156c6c9277174f13322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::calculate_k_values_for_assembly_matrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_value_i_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_value_ip1_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_value_im1_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_value_i_jp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>k_value_i_jm1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- </p>
<h2>IMPLICIT MODEL COMPONENTS </h2>
<p>Implicit schemes for combination of hillslope sediment transport using non-linear hillslope transport law, and fluvial erosion. This is essentially the implicit implementation of MuddPILE, but has been modified so that now fluvial erosion is undertaken using FASTSCAPE (Braun and Willet, 2013), which </p>
<h2>greatly increases computational efficiency. </h2>
<p>calculate_k_values_for_assembly_matrix/mtl_initiate_assembler_matrix this function creates vectors of integers that refer to the k values, that is the index into the vectorized matrix of zeta values, that is used in the assembly matrix </p>
<h2>the number of elements in the k vectors is N_rows*N_cols </h2>

</div>
</div>
<a class="anchor" id="a77632533c5f622cf4ea5e675435e3850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRasterModel::calculate_root </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <h2>Calculates depth of topographic root using FFT methods inherited from <a class="el" href="class_l_s_d_raster_spectral.html" title="This object performs spectral analysis. ">LSDRasterSpectral</a> </h2>

</div>
</div>
<a class="anchor" id="a3cf2fbe1fa282b7897eafd8ac3ab5552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::check_and_correct_uplift_field </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This checks to see if the uplift field is consistent with the raster dimensions. If not it corrects the dimensions of the uplift field. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>23/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a62048b6dcd9553b03d1c6950e617cdb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LSDRasterModel::check_end_condition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This checks on the ending condition of the model run endTime_mode: 1 == The end time is just some fixed time after initial steady state 2 == The end time is after a fixed number of cycles 3 == The time is after steady state, but waits for a fixed number of cycles before ending. </p>
<dl class="section return"><dt>Returns</dt><dd>returns a boolean that is true if the end time has been reached and false if end time has not been reached </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ, comments SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 comments SMM 27/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a7fb5171ffe6b680cd8d66f5b28e01b50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LSDRasterModel::check_if_hung </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the periodic model cycles over 100 times this returns true. </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>

</div>
</div>
<a class="anchor" id="a15760c528df4d411b4cc5a5ed1decaab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::check_periodicity_switch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks to see if this is a periodic run. If it is, it sets the times to align with the period Note this only realy comes into play if period mode == 2 or 4 period_mode means 1 (default) one periodicity used without 2 Two periodicities that switch at a given interval 3 Two periodicities used as a compound sin wave 4 Same as three, but weightings switch at a given interval (as in 2) </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/012014 </dd></dl>
<p>Possible problem here, if running sequential models we can't remeber which periodicity was the original one </p>

</div>
</div>
<a class="anchor" id="a5c5c246aa026d9a5292cca13c6aad189"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::check_recording </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks to see if the model should record results If initial steady state has not been reached, recording is set to false: that is, the model does not record information on the build up to steady state. </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a32fb915d3eb2fb31f57292c72cc27e68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::check_steady_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks to see if the model has achieved steady state. The nature of steady state checked is set by the cycle_steady_check flag If this is false, it checks if there is simple steady state (the surface elevations do not change in time) If the cycle_steady_check is true, it check if steady state has been achieved from one cycle to another. </p>
<dl class="section return"><dt>Returns</dt><dd>does not return anything, but instead changes the steady_state flag </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ commented SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 commented SMM 27/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="aa354efe4967bbbcd2f5d5870586ded8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::close_static_outfiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function closes some static outfiles used for printing. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/08/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a0a85312bf014b46b8944197f33d4cf94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a> LSDRasterModel::create_buffered_surf </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This first function is used as a simple way to implement boundary conditions, particularly no flux and periodic boundary conditions. The buffered surface has NRows+2 rows and NCols+2 columns. The integer b_type sets the type of boundary conditions, but currently there is only one implementation: no flux across N and S; periodic for E and W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b_type</td><td>at the moment this is irrelevant since this just switches to default </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>creates a buffered <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aff77cd0beee7155ae1e247b5ce8432df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a> LSDRasterModel::create_buffered_surf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>South_boundary_elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>North_boundary_elevation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This second version has periodic boundaries at E and W boundaries, and Neumann boundary conditions (prescribed elevations) at the N and S boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">South_boundary_elevation</td><td>the elevation at the southern boundary </td></tr>
    <tr><td class="paramname">North_boundary_elevation</td><td>the elevation at the southern boundary </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab735eebfabfe689f7d6bb24f1ea4bcbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::cycle_report </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>elev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>relief0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>relief10</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this prints a file about what has happened over a cycle </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a3ad3ae2130aeecb5b593de765adb14f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::final_report </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this prints a final report (SMML not sure what is in the final report) </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a4bed30e73f0ee13a334ac1df002ce143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::find_max_boundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>boundary_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the maxium elevation along a boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary_number</td><td>0 == row 0 1 == col 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum elevation along the boundaty </dd></dl>

</div>
</div>
<a class="anchor" id="ae60d05732f02edfb229c9a827b67e411"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::flexural_isostasy </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <h2>Correct for isostasy using flexural model </h2>

</div>
</div>
<a class="anchor" id="a94d40257c1cc4f409c663488d7a514b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::fluvial_calculate_K_for_steady_state_relief </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>desired_relief</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method calcualtes the fluvial K required to generate the desired relief at steady state for the farthest upstream chi. It is based on equation 4a from Mudd et al 2014 JGR-ES.  This does not update aything in the model, but simply returns the desired K. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>the uplift rate (in m/yr) </td></tr>
    <tr><td class="paramname">desired_relief</td><td>The desired landscape relief in metres </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The back calculated K value for the desired relief </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="abea4c2a6f4958b9c92a0905a5adad6a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRasterModel::fluvial_erosion_rate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timestep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt;&#160;</td>
          <td class="paramname"><em>boundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is more or less identical to fluvial_incision above, but it Returns a raster with the erosion rate and takes arguments rather than reading from data members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestep</td><td>the time spacing </td></tr>
    <tr><td class="paramname">K</td><td>fluvial erosivity </td></tr>
    <tr><td class="paramname">m</td><td>area exponent </td></tr>
    <tr><td class="paramname">n</td><td>slope exponent </td></tr>
    <tr><td class="paramname">boundary</td><td>a vector of strings cotaining model boundary conditions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raster containing the erosion rate from fluvial processes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a615b8c5b500a525282921d313d12a7fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRasterModel::fluvial_erosion_rate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is more or less identical to fluvial_incision above, but it Returns an array and takes arguments rather reads from data members. </p>
<dl class="section return"><dt>Returns</dt><dd>A 2d float containing the erosion rate from fluvial processes </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>07/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="acc2a8455c460b4ce906d7b883179bab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::fluvial_incision </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fastscape, implicit finite difference solver for stream power equations O(n) Method takes its paramaters from the model data members and solves the stream power equation at a future timestep in linear time. </p>
<dl class="section author"><dt>Author</dt><dd>JAJ, commented SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014, edit 18/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ad3204a5d3d4acdb70043c242f5ade271"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::fluvial_incision_with_uplift </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fastscape, implicit finite difference solver for stream power equations O(n) Method takes its paramaters from the model data members and solves the stream power equation at a future timestep in linear time This version includes the current uplift, so you do not need to call uplift after this has finished. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>7/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="aef9bf0ae3332f1389f13da2a9836c03a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::fluvial_incision_with_uplift_and_variable_K </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>K_raster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fastscape, implicit finite difference solver for stream power equations O(n) Method takes the K value from a raster fed to it and solves the stream power equation at a future timestep in linear time This version includes the current uplift, so you do not need to call uplift after this has finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K_raster</td><td>the raster of K values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a12316bca2ffb8a31451430fdabf9694b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::fluvial_incision_with_variable_uplift_and_variable_K </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Uplift_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>K_raster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fastscape, implicit finite difference solver for stream power equations O(n) Method takes the K value from a raster fed to it and also take a raster of the uplift rates and solves the stream power equation at a future timestep in linear time This version includes the current uplift, so you do not need to call uplift after this has finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K_raster</td><td>the raster of K values. </td></tr>
    <tr><td class="paramname">Uplift_rate</td><td>a raster of uplift rates in m/yr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="aa779dbfb7214661088d9157b1af22f0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::fluvial_incision_with_variable_uplift_and_variable_K_adaptive_timestep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>Uplift_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>K_raster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fastscape, implicit finite difference solver for stream power equations O(n) Method takes the K value from a raster fed to it and also take a raster of the uplift rates and solves the stream power equation at a future timestep in linear time This version includes the current uplift, so you do not need to call uplift after this has finished. Uses an adaptive timestep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K_raster</td><td>the raster of K values. </td></tr>
    <tr><td class="paramname">Uplift_rate</td><td>a raster of uplift rates in m/yr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>06/09/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a3934e2c1fa1658d8be464d4aeea1e011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::fluvial_snap_to_steady_state </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method creates a steady landscape that assumes everywhere obeys the stream power law. It is based on equation 4a from Mudd et al 2014 JGR-ES  There is no return but the underlying raster data will reflect the analytical steady topography for the uplift rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>the uplift rate (in m/yr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="aacd92e0cd0cc8bb73d91ac4a7ff93b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::fluvial_snap_to_steady_state_tune_K_for_relief </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>desired_relief</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method creates a steady landscape that assumes everywhere obeys the stream power law. It is based on equation 4a from Mudd et al 2014 JGR-ES. The function is given a target relief and the K value is adjusted to match this target relief at the maximum chi value.  In addition to the return, the underlying raster data will reflect the analytical steady topography for the uplift rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>the uplift rate (in m/yr) </td></tr>
    <tr><td class="paramname">desired_relief</td><td>The desired landscape relief in metres </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The back calculated K value for the desired relief </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="af817b9d03df68bc3f8b3f09dda921093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mtl::compressed2D&lt; float &gt; LSDRasterModel::generate_fd_matrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
 <h2>Finite difference matrix </h2>

</div>
</div>
<a class="anchor" id="a1c81479ad710ae501e19226ffc9b7db1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRasterModel::generate_uplift_field </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_uplift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates uplift field from a set of templates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>specifies a mode of uplift: (0) - block uplift 1 - tilt block 2 - gaussian 3 - quadratic </td></tr>
    <tr><td class="paramname">second</td><td>argument is the maximum uplift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the uplift field that is the same dimensions as the original raster </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ab5da6c2938dc2467b21d1c4025c27652"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRasterModel::generate_uplift_field </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates uplift field from a set of templates, parameters are taken from data members. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the uplift field that is the same dimensions as the original raster </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>07/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a1fa1f9ef398ae753f04bfefbfc9f8155"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::get_average_upflit_rate_last_timestep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this calcualtes the average uplfit rate over the entire model domain, excluding the N and S boundaries </p>
<dl class="section return"><dt>Returns</dt><dd>the average uplift rate in m/yr </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/08/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a028144c488e456bedc8431f4b9370a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::get_D </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the soil transport coefficient erodability. It has a number of switches that determine how D is calculated. D_mode == 1 sine wave D_mode == 2 square wave D_mode == 3 read from file D_mode: default is constant value. </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="af318687f4e7536aaf9973730ce9fec37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::get_erosion_at_cell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This calculates the erosion rate for individual cells. Currently it assumes that the zeta_old data member is from the previous timestep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the cell </td></tr>
    <tr><td class="paramname">col</td><td>the column of the cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="abb071b3d18b9f814a7b86dcef0509ab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::get_K </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the fluvial erodability. It has a number of switches that determine how K is calcualted. K_mode == 1 sine wave K_mode == 2 square wave K_mode == 3 read from file K_mode: default is constant value. </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a567605b74fe84a36e1de90a350faefd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::get_m </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the area exponent. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="acd709b90c70728620958372af75b264a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::get_max_uplift </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This just returns the max_uplift data member NOTE; while this is currently a very trivial, and arguably unecessary method, it should be used and developed if someone wants to integrate some sort of changing uplift field. </p>
<dl class="section return"><dt>Returns</dt><dd>the data member holding the maximum uplift </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a80f1a0645a4f6e1df36208084e657731"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::get_n </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the slope exponent. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a2cfae5bb8d844157a604d3a384886542"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string LSDRasterModel::get_name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets the name of the model run from the data members </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the model run </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a6b247191f214206be56ed7f03697c505"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDRasterModel::get_NCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of columns as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a14b305ebdc386eb856ee32990e405c04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDRasterModel::get_NRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of rows as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e0ad45b0d6732993705b433e63ee115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::get_slopes </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>SlopesBetweenRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>SlopesBetweenCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- TOPOGRAPHIC DERIVATIVES Specifically, this function gets the topographic slopes, as required for the sediment flux calculations. The slopes are stored as two matrices, one that stores slopes between rows, the other which for slopes between columns. Note that this is a finite volume model that utilises cubic model voxels. Sediment fluxes are only permitted through the faces.</p>
<p>For slopes between columns, the entry at S[row][col] refers to the slope between zeta at node [row][col] and at node [row][col+1]. Likewise for the slopes between rows. In short, the center points of the slopes are offset by 1/2 a node spacing in the positive direction. </p>
<h2>Note that there are NCols +1 and NRows +1 columns and rows respectively </h2>

</div>
</div>
<a class="anchor" id="a9ead96b3085ca24da4f812bf0114aa93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRasterModel::get_topographic_divergence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> get_topographic_divergence gets the topographic divergence at each point in the model domain. Use </p>
<h2>buffered topography </h2>

</div>
</div>
<a class="anchor" id="acbb5db4f45eb5196f8c9bfa3e0ae33e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::get_total_erosion_rate_over_timestep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this calcualtes the total erosion over a timester </p>
<dl class="section return"><dt>Returns</dt><dd>the erosion rate calculated over the last timestep </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/08/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a691069a8cafbaee11223e2c16b3e749b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::get_uplift_at_cell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the uplift value at a given cell this method is implemented as a memory saving measure, rather than storing the uplift field in memory Some methods still implemented still use this uplift field It's advisable this is changed, otherwise the size of rasters that can be modelled will be severely reduced. </p>
<p>This uses the uplift_mode to determine how uplift is calculated (0) - block uplift 1 - tilt block 2 - gaussian 3 - quadratic 4 - periodic </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td></td></tr>
    <tr><td class="paramname">column</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uplift (as a distance rather than rate, uses data member timestep) </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ commented SMM </dd>
<dd>
01/01/2014 commented 26/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ae4461aa99a0b538a96d8a3ee9220c04e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LSDRasterModel::get_uplift_rate_at_cell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the uplift rate at a given cell this method is implemented as a memory saving measure, rather than storing the uplift field in memory Some methods still implemented still use this uplift field It's advisable this is changed, otherwise the size of rasters that can be modelled will be severely reduced. </p>
<p>This uses the uplift_mode to determine how uplift is calculated (0) - block uplift 1 - tilt block 2 - gaussian 3 - quadratic 4 - periodic </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td></td></tr>
    <tr><td class="paramname">column</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uplift rate </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>07/07/2014 commented 26/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a24b1bd91533cb93bd103ee761e9147cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::initialise_model </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This module initialises the model using the maps that have been read in from the parameter file via the param file parser function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nowt</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DAV </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2015-01-17 </dd></dl>

</div>
</div>
<a class="anchor" id="a62fdbd1f5deb2e7efe222e06966602a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::initialise_nonlinear_SS </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This initialises a surface with a hillslope that is the solution to the nonlinear sediment flux equation. It overwrites RasterData. </p>
<p>The parameters D and S_c are stored as data members Solution from Roering et al., (EPSL, 2007) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>the uplift rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a49fa78695df7f24b2693437f6d2cf8a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::initialise_parabolic_surface </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>peak_elev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>edge_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This resets the RasterData array to have a parabolic shape, with 0 elevation at the N and S boundaries. It also adds some random noise to the topography. The amplitude of this noise is set by the data member 'noise'. The default noise is 1mm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peak_elev</td><td>The peak elevation in metres. Is in the middle of the model domain </td></tr>
    <tr><td class="paramname">edge_offset</td><td>an offest from the edge elevation. You can have a little cliff at the edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>1/7/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a6e815867c696c09bd5fc8b333f949edc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::initialise_taper_edges_and_raise_raster </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows_to_taper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This takes a raster and tapers the edges to zero elevation. Its purpose is to remove edge artefacts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows_to_taper</td><td>The number of rows at the N and S boudaries to taper </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a4494efe08b81f45eb0abc2284f1ddb13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::initialize_model </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>parameter_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This module initialises the model runs, calling the required function from the initial topography and loads the parameters from the parameter file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter_file</td><td>the filename of the paramter file (with extension) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a2ba0fb6ea4c89a5376cf44bc5ed06e76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_l_s_d_particle_column.html">LSDParticleColumn</a> &gt; LSDRasterModel::initiate_steady_CRN_columns </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column_spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>CRNcol_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>CRNcol_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>this_U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>particle_spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_c_r_n_parameters.html">LSDCRNParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>CRNParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This initiates a vector of CRN columns that sit under the model. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_spacing</td><td>and integer telling how many nodes between particle columns </td></tr>
    <tr><td class="paramname">CRNcol_rows</td><td>this is an integer vector that is replaced in this function each element indexes the row of the vector of columns </td></tr>
    <tr><td class="paramname">CRNcol_cols</td><td>this is an integer vector that is replaced in this function each element indexes the col of the vector of columns </td></tr>
    <tr><td class="paramname">rho_r</td><td>the density of the rock in kg/m^3 </td></tr>
    <tr><td class="paramname">this_U</td><td>the uplift rate in m/yr that the particles CRN concentrations will be equilibrated to. Note it is only via nucleonic production </td></tr>
    <tr><td class="paramname">startType</td><td>the starting type of the particle (doesn't really play a role) </td></tr>
    <tr><td class="paramname">startDepth</td><td>the starting depth (in m) of the particles </td></tr>
    <tr><td class="paramname">particle_spacing</td><td>vertical distance between particles in the column </td></tr>
    <tr><td class="paramname">CRNParam</td><td>the cosmogenic parameter values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of particle columns </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>31/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a1aa477acdd27d860cf0fa597d30e9a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::intialise_diamond_square_fractal_surface </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>feature_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>desired_relief</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This initialises the raster model to a fractal surface using the diamond square algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature_order</td><td>is an interger n where the feature size consists of 2^n nodes. If the feature order is set bigger than the dimensions of the parent raster then this will default to the order of the parent raster. </td></tr>
    <tr><td class="paramname">desired_relief</td><td>The relief desired from the final surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a7861c2f0425f312ec0c3f3c7ad6b18f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::intialise_fourier_fractal_surface </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fractal_D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This initialises the raster model to a square model domain with a fractal surface using the algorithm from Saupe (1987d) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fractal_D</td><td>Used to determine the fractal dimension, D by: D = 3 - fractal_D. So the fractal dimension should be between 2 and 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>DAV </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/10/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a3180c87b4d3b8e6a5304cc70c0e38cf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::intialise_fourier_fractal_surface_v2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>desired_relief</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This initialises the raster model to a square model domain with a fractal surface using the algorithm from the <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>Used to determine the fractal dimension, beta by: beta = 3 - fractal_beta. So the fractal dimension should be between 2 and 3. </td></tr>
    <tr><td class="paramname">desired_relief</td><td>The relief desired from the final surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="ab36b5aaeced6fb4cc49e9ab7a069f3b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LSDRasterModel::is_base_level </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether current node is a base level node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td></td></tr>
    <tr><td class="paramname">column</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a7d4e51173669b002d3a63467810401d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::make_template_param_file </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a template of a parameter file to be supplied to the model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>name of the parameter file to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ac6de596e422be98a58b48ce1975ef0c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::mtl_assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>zeta_last_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>zeta_last_timestep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>zeta_this_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>uplift_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>fluvial_erosion_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtl::compressed2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>mtl_Assembly_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtl::dense_vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>mtl_b_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>problem_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inv_dx_S_c_squared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inv_dy_S_c_squared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx_front_term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy_front_term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>South_boundary_elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>North_boundary_elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_i_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_ip1_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_im1_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_i_jp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_i_jm1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mtl_assemble_matrix this function assembles the solution matrix for nonlinear creep transport </p>

</div>
</div>
<a class="anchor" id="a915f3238ea9fb47a3cf468108b6b2501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::mtl_solve_assembler_matrix </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>zeta_last_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>zeta_last_timestep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>zeta_this_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>uplift_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>fluvial_erosion_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>problem_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inv_dx_S_c_squared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inv_dy_S_c_squared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx_front_term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy_front_term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_i_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_ip1_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_im1_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_i_jp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_i_jm1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>South_boundary_elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>North_boundary_elevation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> mtl_solve_assembler_matrix </p>
<h2>this function assembles the solution matrix </h2>

</div>
</div>
<a class="anchor" id="a09c9b142f87ccf133fa8fb9b3676b41a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::MuddPILE_assemble_matrix </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>uplift_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>fluvial_erosion_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtl::compressed2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>mtl_Assembly_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mtl::dense_vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>mtl_b_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this assembles the sparse matrix that must then be solved to get the next iteration of the hillslope elevations </p>
<p>Note this is not a buffered surface, boundaries are implemented at Row == 0 and Row = NRows-1 in the LSDModelRasters domain </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uplift_rate</td><td>a float array giving the uplift rate </td></tr>
    <tr><td class="paramname">fluvial_erosion_rate</td><td>a float array giving the fluvial erosion rate </td></tr>
    <tr><td class="paramname">mtl_Assembly_matrix</td><td>this is a sparce matrix that is reset within this member function and passed to the solver </td></tr>
    <tr><td class="paramname">mtl_b_vector</td><td>the b vector in the linear system M z = b where M is the assembly matrix and z is the vector of surface elevations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a9b66e5a49f91f618ebfd2403f09e94b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::MuddPILE_calculate_k_values_for_assembly_matrix </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this initiates some parameters for the assembler matrix it is required before running any further calculations for the nonlinear solver </p>
<p>Does the work of calculating vec_k_value_i_j, vec_k_value_ip1_j, vec_k_value_im1_j, vec_k_value_i_jp1 and vec_k_value_i_jm1. These are the indices into the vectorized matrix of zeta values that are used in the assembly matrix the number of elements in the k vectors is N_rows*N_cols WARNING: This is only used for fixed NS boundaries and periodic EW boundaries </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a9af0ea7133d7af8a3e4fc45b797e409b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::MuddPILE_initiate_assembler_matrix </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this initiates some parameters for the assembler matrix it is required before running any further calculations for the nonlinear solver </p>
<p>The function sets data members inv_dx_S_c_squared, dx_front_term, problem_dimension, vec_k_value_i_j, vec_k_value_ip1_j, vec_k_value_im1_j, vec_k_value_i_jp1 and vec_k_value_i_jm1 </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a3f3d08a706de097ca698272835f2c687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::MuddPILE_nl_soil_diffusion_nouplift </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of the MuddPILE nonlinear solver does not include uplift and uses a default iteration tolerance of 1e-7. It is built to integrate with JAJ's 'run_components' module. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>03/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a5c0869cf030684a1021c2214e523aebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::MuddPILE_nonlinear_creep_timestep </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>uplift_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>fluvial_erosion_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>iteration_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This runs one timestep of the nonlinear sediment flux law It replaces the data in RasterData. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uplift_rate</td><td>a float array of the same size as RasterData that contains the uplift rate </td></tr>
    <tr><td class="paramname">fluvial_erosion_rate</td><td>a float array of the same size as RasterData </td></tr>
    <tr><td class="paramname">iteration_tolerance</td><td>the maximum change in surface elevation between iterations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ab0a6a08dd4cb9e4525f61fa42975566d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::MuddPILE_solve_assembler_matrix </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>uplift_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>fluvial_erosion_rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function solves the assembled matrix for the nonlinear hillslope sediment flux law. The implementation calls MuddPILE_assemble_matrix. </p>
<p>After solution the zeta_this_iter data member will be updated </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uplift_rate</td><td>a float array of the same size as RasterData that contains the uplift rate </td></tr>
    <tr><td class="paramname">fluvial_erosion_rate</td><td>a float array of the same size as RasterData </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ad7c8da854b7b44a9a90c962d6fb9e3e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::nonlinear_creep_timestep </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>fluvial_erosion_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>iteration_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>problem_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inv_dx_S_c_squared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inv_dy_S_c_squared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx_front_term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy_front_term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_i_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_ip1_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_im1_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_i_jp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_k_value_i_jm1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>South_boundary_elevation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>North_boundary_elevation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> nonlinear_creep_timestep do a creep timestep. This function houses the above two functions to undertake model timestep using implicit implementation of the nonlinear transport law. </p>
<h2>NOTE you need to run mtl_initiate_assembler_matrix before you run this function </h2>

</div>
</div>
<a class="anchor" id="ae8678095d20dbc0f105607d73b1f5ce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::normal_fault_part_of_raster </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>throw_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>throw_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a normal fault horizontally across the raster. </p>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>06/07/18 </dd></dl>

</div>
</div>
<a class="anchor" id="ada4d5defd202390cc09b90f3a0780040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt; float &gt; LSDRasterModel::precip_array_from_precip_rate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>precip_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= CREATE PRECIPITION FLUX ARRAY </p>
<h2>Produces precipitation array from provided precipitation rate. </h2>

</div>
</div>
<a class="anchor" id="af428a8244abd07a47f07927d6b1ca82e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::print_average_erosion_and_apparent_erosion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_l_s_d_particle_column.html">LSDParticleColumn</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>CRNColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_c_r_n_parameters.html">LSDCRNParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>CRNParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints the apparent cosmogenic rates from a collection of <a class="el" href="class_l_s_d_particle.html" title="This is a class for a particle that can be tracked through simulations and retains data about positio...">LSDParticle</a> Columns  This function opens a file if none exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>the frame to be printed </td></tr>
    <tr><td class="paramname">CRNColumns</td><td>the columns of cosmogenic particles </td></tr>
    <tr><td class="paramname">CRNParams</td><td>and LSDCRNParamters object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/08/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a85f65004ec63ad9b41a35f110e8fe67c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::print_column_erosion_and_apparent_erosion </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_l_s_d_particle_column.html">LSDParticleColumn</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>CRNColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_c_r_n_parameters.html">LSDCRNParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>CRNParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints the apparent cosmogenic rates from individual <a class="el" href="class_l_s_d_particle.html" title="This is a class for a particle that can be tracked through simulations and retains data about positio...">LSDParticle</a> Columns  This function opens a file if none exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>the frame to be printed </td></tr>
    <tr><td class="paramname">CRNColumns</td><td>the columns of cosmogenic particles </td></tr>
    <tr><td class="paramname">CRNParams</td><td>and LSDCRNParamters object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>24/05/2015 </dd></dl>

</div>
</div>
<a class="anchor" id="a790599317823cfe42e59e51ddd7798c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::print_parameters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this prints parameters to screen </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a0d98f6e0c5a3f4404165e0ea1990d188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::print_rasters </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints a series of rasters. The rasters printed depend on the switches print_elevation, print_erosion, print_erosion_cycle, print_hillshade; and print_slope_area The filename inculdes the frame_num. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>frame of the rasters to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ac8d55cc1fa59b93d3c54490631605e58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::print_rasters_and_csv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints a series of rasters. The rasters printed depend on the switches print_elevation, print_erosion, print_erosion_cycle, print_hillshade; and print_slope_area The filename inculdes the frame_num It also prints a csv of the model info which can be ingested by pandas for visualisation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>frame of the rasters to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>FJC </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22/08/17 </dd></dl>

</div>
</div>
<a class="anchor" id="a5de63c7016fdbf627f0ceaaa229751c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::raise_and_fill_raster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this raises the raster so the lowest point is zero and also fills the raster </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a6a78a12257641af8735520ddaa53d5f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::random_surface_noise </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds random noise to each pixel in range [min, max]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minium</td><td>random addition </td></tr>
    <tr><td class="paramname">maximum</td><td>random addition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ae37bd5d8b4f32bffe118b7ac13a5eea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::random_surface_noise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds random noise to each pixel using the noise data member. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>17/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ad6794287484c8c2683c72d38bb40fe9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::reach_steady_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method forces the landscape into its steady state profile, by using periodic forcing. This is much more efficient than using static forcing (as in run model), but doesn't give a nice animation of an evolving landscape Swings and roundabouts. </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a09c5ee678da5236c286b412f45476e88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::reset_model </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset model - reset erosion values to 0 after a complete model run. </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="abad405276214c6ada09faa9aa08dc4d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::resize_and_reset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This resizes the <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a>, resetting some flags in the process, as well as setting many of the Array2D data members to be empty arrays The raster data in the end is a random surface (determined by the noise data member) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_rows</td><td>the new number of rows </td></tr>
    <tr><td class="paramname">new_cols</td><td>the new number of columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>30/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a0c069763e573b623816e253a560184be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::resize_and_reset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>new_resolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This resizes the <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a>, resetting some flags in the process, as well as setting many of the Array2D data members to be empty arrays The raster data in the end is a random surface (determined by the noise data member) This overloaded version also changes the data resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_rows</td><td>the new number of rows </td></tr>
    <tr><td class="paramname">new_cols</td><td>the new number of columns </td></tr>
    <tr><td class="paramname">new_resolution</td><td>the new data resolution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>30/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a59e951371b5111ef5bb175371bd9f9a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> LSDRasterModel::return_as_raster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This just returns the raster model object data as a raster. </p>
<dl class="section return"><dt>Returns</dt><dd>A raster with the data from the <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/09/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="ab07fe62578a9754af53f2d01dfb165f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::run_components </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This wrapper just calls the run_components method. Parameters used are those stored as data members. This one actually calls the erosion laws. </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ae4a896652bfa268fe3e84ceb2a30bbf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::run_components_combined </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a wrapper similar to run_components but sends the fluvial and uplfit fields to the nonlinear solver. </p>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>07/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a5d2a4c25bf2772e3108da8f349d686fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::run_components_combined </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>URaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_raster.html">LSDRaster</a> &amp;&#160;</td>
          <td class="paramname"><em>KRaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_adaptive_timestep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a wrapper similar to run_components but sends the fluvial and uplfit fields to the nonlinear solver.  Variable U and K rasters can be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">URaster</td><td>A raster of uplift rates </td></tr>
    <tr><td class="paramname">KRaster</td><td>A raster of K values </td></tr>
    <tr><td class="paramname">use_adaptive_timestep</td><td>If true, an adaptive timestep is used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>03/09/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="ac8bc5cf26e557dd1e94be0a847bcf091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::run_components_combined_cell_tracker </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_l_s_d_particle_column.html">LSDParticleColumn</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>CRNColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_l_s_d_particle_column.html">LSDParticleColumn</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>eroded_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>particle_spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_l_s_d_c_r_n_parameters.html">LSDCRNParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>CRNParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a wrapper that runs the model but includes CRN columns fluvial and uplfit fields to the nonlinear solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CRNColumns</td><td>the vector of particle columns </td></tr>
    <tr><td class="paramname">eroded_cells</td><td>this gets replaced, it is the eroded particles </td></tr>
    <tr><td class="paramname">startType</td><td>the starting type of the particle (doesn't really play a role) </td></tr>
    <tr><td class="paramname">startDepth</td><td>the starting depth (in m) of the particles </td></tr>
    <tr><td class="paramname">particle_spacing</td><td>vertical distance between particles in the column </td></tr>
    <tr><td class="paramname">CRNParam</td><td>the cosmogenic parameter values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>25/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="aa6285eea4a82b23f6d52e8c69aea0e10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a> LSDRasterModel::run_isostatic_correction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Runs flexural isostatic calculations Uses fourier filtering method </p>
<h2>Pelletier (2008) </h2>

</div>
</div>
<a class="anchor" id="a0f91ca83a51a91e5f8518261ede061ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::run_model </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This wrapper just calls the run_components method. Parameters used are those stored as data members. </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="afadcfe595fad8bfb23f2b2d90b9af96f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::run_model_from_steady_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This loads a steady state raster from the data members so that a model can be run repeatedly from the same steady state condition. </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="ab8072cbbec5bc2c811c9bc62cffccc6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a> LSDRasterModel::run_model_implicit_hillslope_and_fluvial </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>param_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- </p>
<h2>RUN MODEL </h2>
<h2>A series of wrapper functions that implement the numerical model </h2>
<p>implicit_hillslope_and_fluvial This function sets up a landscape evolution model run incorporating fluvial erosion and hillslope erosion via non-linear creep. It calls the implicit implementation and returns the topography after the final timestep. The user should provide the parameter file which sets out the details of the </p>
<h2>model run. </h2>

</div>
</div>
<a class="anchor" id="afc836f381a720b218ca55bc6b028cf84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_D_mode </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this sets the D mode </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The mode of calculating D D_mode == 1 sine wave D_mode == 2 square wave D_mode == 3 read from file D_mode: default is constant value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a23b50dbd1d9c07eee0910bd67124df67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_flexure </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the flexure switch </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_status</td><td>a boolean, true if on, false if off </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ @ date 01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a337eae43f827a0319aecbfd8fcf6e400"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_fluvial </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the fluvial switch </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_status</td><td>a boolean, true if on, false if off </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ @ date 01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a46569ec3e4fcca5cea926599be43e212"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_hillslope </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the hillslop switch </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_status</td><td>a boolean, true if on, false if off </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ @ date 01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a2fac7642cb3346c3df7cde4c548be1bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_isostasy </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the isostacy switch </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_status</td><td>a boolean, true if on, false if off </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ @ date 01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="afa84e64c2f193e1f2bacc3f405ebbfa4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_K_mode </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this sets the K mode </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The mode of calculating K K_mode == 1 sine wave K_mode == 2 square wave K_mode == 3 read from file K_mode: default is constant value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="aeffe213ca2f8d0b9b58a0cff9ff44dba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_nonlinear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the hillslop linear or nonlinear switch </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_status</td><td>a boolean, true if on, false if off </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM @ date 03/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a5020e8dcf05355ccf765df1a69f1303d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_period_mode </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This sets the way the periodicity is calculated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the mode of periodic forcing 1 (default) one periodicity used without 2 Two periodicities that switch at a given interval 3 Two periodicities used as a compound sin wave 4 Same as three, but weightings switch at a given interval (as in 2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a39ebb0cb0164765c5e9333951968c425"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_print_elevation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_I_print_elevation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the print elevation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boolean;</td><td>if true prints elevation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>09/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a299fadc81b5955f203422370fed44fcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_print_erosion </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_I_print_erosion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the print erosion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boolean;</td><td>if true prints erosion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>09/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="aa26f5466015d345dbf5b6e1fb12974aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_print_hillshade </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_I_print_hillshade</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the print hillshade. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boolean;</td><td>if true prints hillshade </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>09/08/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a759863062a5daffab113ca1d00b5128f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_quiet </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the quiet switch </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_status</td><td>a boolean, true if on, false if off </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ @ date 01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a44812ac46570c72a866c9ff198ef28eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_uplift </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overloaded function, set the array of uplift, but using the uplift mode </p>
<p>uplfit modes are: (0) - block uplift 1 - tilt block 2 - gaussian 3 - quadratic 4 - periodic </p>

</div>
</div>
<a class="anchor" id="a7ec2f15d2a759abd8e65b5f843efe8a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::set_uplift_field_to_block_uplift </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>uplift_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the uplift_field data member as bolck uplift with a rate of uplift_rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uplift_rate</td><td>a float of uplift rate, the entire block will uplift at this rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>03/07/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="aa23e1f841dc90f503e0947368f58ae6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::slope_area_data </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print slope area data Probably fits better into <a class="el" href="class_l_s_d_raster.html" title="Main analysis object to interface with other LSD objects. ">LSDRaster</a>, but requires <a class="el" href="class_l_s_d_flow_info.html" title="Object to perform flow routing. ">LSDFlowInfo</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requires</td><td>a filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a650308748f24f78ebbee77858ddcf192"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::slope_area_data </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slope_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>area_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print slope area data This is an overloaded function that calcualtes slope area data based on flags. There are two flag, one for the slope calculation and one for the area calculation. </p>
<p>The output is a file with four columns Elevation slope area predicted_slope The predicted slope is that based on the SS solution of stream power at the current uplift rate and the current K </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requires</td><td>a filename </td></tr>
    <tr><td class="paramname">a</td><td>flag for calculation of the topographic slope 0 == polyfit using the data resolution as the smoothing diameter 1 == slope calculated with the D8 slopes, with dx = data resolution or DataResolution*sqrt(2) depending on flow direction. </td></tr>
    <tr><td class="paramname">a</td><td>flag for calculation of the area 0 == area using contributing pixels but smoothed to data resolution with polyfit 1 == area using contributing pixels only 2 == </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>18/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a8eabd21a489fa58012c10a1338123c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::soil_diffusion_fd_linear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Soil diffusion using linear flux model </p>
<h2>Solved using finite difference </h2>

</div>
</div>
<a class="anchor" id="a4ba8678df60e842632cbd1a6df29d06f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::soil_diffusion_fv </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Soil diffusion method </p>
<h2>Container for all the finite volume components </h2>

</div>
</div>
<a class="anchor" id="a1feebac96fced4fb559886f70e60dbb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::superimpose_parabolic_surface </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>peak_elev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a parabolic surface to the DEM. Used to try and avoid ;arge areas of fill from the fractal initiation steps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peak_elev</td><td>The peak elevation in metres. Is in the middle of the model domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>11/8/2017 </dd></dl>

</div>
</div>
<a class="anchor" id="a35c9c22122b23eb77693775e07413b81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a> LSDRasterModel::uplift_surface </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>UpliftRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply uplift field to the raster. Overloaded function so that the first simply considers uniform uplift, the second allows user to use a prescribed uplift fields of greater complexity, for example taking account of fault geometry. </p>
<p>WARNING the returned <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> only contains a very small subset of the data members of the original <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a>. Implementation NOT RECOMMENDED! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UpliftRate</td><td>the rate of uplift at that timestep </td></tr>
    <tr><td class="paramname">dt</td><td>the timestep </td></tr>
    <tr><td class="paramname">Returns</td><td>an <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> of uplift (SMM: why not just update the raster directly??) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ, comments SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 SMM comments 26/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="af59c1ff57be88a8070b16c73514da8ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_l_s_d_raster_model.html">LSDRasterModel</a> LSDRasterModel::uplift_surface </td>
          <td>(</td>
          <td class="paramtype">Array2D&lt; float &gt;&#160;</td>
          <td class="paramname"><em>UpliftRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uplift surface using specified uplift field uplift field should be specified as an array with the same dimensions as the elevation raster, permitting non-uniform uplift fields to be applied in the model. </p>
<p>WARNING the returned <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> only contains a very small subset of the data members of the original <a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a>. Implementation NOT RECOMMENDED! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UpliftRate</td><td>a 2D float array of the uplift. Can be made using the member function generate_uplift_field </td></tr>
    <tr><td class="paramname">dt</td><td>the timestep </td></tr>
    <tr><td class="paramname">an</td><td><a class="el" href="class_l_s_d_raster_model.html" title="Create model objects to use LSDRaster methods on synthetic landscapes. ">LSDRasterModel</a> object (SMM again, why not update the underlying data member of surface elevation?) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>JAJ, comments SMM </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 SMM comments 26/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a71a0471dd4661057fdb1320e62e1ea4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::uplift_surface </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intrinsic method of uplifting the Raster Uplift field attribute is incremented onto RasterData itself There are no parameters, but rather it simply passes upflift to the get upflift at cell function. </p>
<p>Uplift is calculated based on data_members max_uplift, timestep and uplift mode. This uses the uplift_mode to determine how uplift is calculated (0) - block uplift 1 - tilt block 2 - gaussian 3 - quadratic 4 - periodic </p>
<dl class="section author"><dt>Author</dt><dd>JAJ commented SMM 26/06/2014 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014, commented 26/06/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a88771b6e458a3c323233491586075c25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::wash_out </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This assumes that all sediment transported from rivers into channels is removed. It checks the raster to see where the channels are which at this point is determined by a threshold drainage area, and then removes all the sediment to those pixels. </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<a class="anchor" id="a4477dc73fd3b0b50d241133f2b3bd227"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LSDRasterModel::write_report </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method calculates some features of the landscape at set times. The frequency of the reports are set by the data member report_delay One of the things it does is calculates erosion rates, and stores this as a data member. </p>
<dl class="section author"><dt>Author</dt><dd>JAJ </dd></dl>
<dl class="section date"><dt>Date</dt><dd>01/01/2014 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a221d96c9081b11d6ab60b87696b24fd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short LSDRasterModel::D_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether or not D is periodic D_mode == 1 sine wave D_mode == 2 square wave D_mode == 3 read from file D_mode: default is constant value </p>

</div>
</div>
<a class="anchor" id="a978652ec046ee38762fda91020382c41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short LSDRasterModel::endTime_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a mode of end times. 0 == default, run until the endTime 1 == run until a specified time after steady state 2 == run a number of cycles 3 == run to steady state, then run some cycles. </p>

</div>
</div>
<a class="anchor" id="a5b30bd1ce1854f21f89c11b0ec454d71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short LSDRasterModel::K_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether or not K is periodic K_mode == 1 sine wave K_mode == 2 square wave K_mode == 3 read from file K_mode: default is constant value </p>

</div>
</div>
<a class="anchor" id="ac0a3936bc1f786a9e4147ab388a0bd25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short LSDRasterModel::period_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether or not there is only one periodicity or two 1 (default) one periodicity used without 2 Two periodicities that switch at a given interval 3 Two periodicities used as a compound sin wave 4 Same as three, but weightings switch at a given interval (as in 2) </p>

</div>
</div>
<a class="anchor" id="a09f22e311afb70a0c2acfe4aa190139d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string,string&gt; LSDRasterModel::RM_method_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This holds names of methods. For example, if the key is 'sed_transport_law', the string is the method which is used to calculate sediment transport (such as 'wilcock' or 'einstein') </p>

</div>
</div>
<a class="anchor" id="a6aa718ffbfb7d7a2fc15818219c04478"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string,string&gt; LSDRasterModel::RM_support_file_names</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This holds names of supporting files, for example files that contain node of junction indices to be loaded. </p>

</div>
</div>
<a class="anchor" id="ab533276c540cf946adec779670f0cfc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array2D&lt;float&gt; LSDRasterModel::uplift_field</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The uplift field, can be used as absolute uplift or uplift rate, depending on the calling member function </p>

</div>
</div>
<a class="anchor" id="a1956dbd31336aaf80735b8418fe9335e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LSDRasterModel::uplift_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The mode of uplift. Options are: default == block uplift 1 == tilt block 2 == gaussian 3 == quadratic 4 == periodic </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_l_s_d_raster_model_8hpp_source.html">LSDRasterModel.hpp</a></li>
<li>src/LSDRasterModel.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
